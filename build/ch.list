
build/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <__vectors_base__>:
 8000000:	20000400 	.word	0x20000400
 8000004:	080001a1 	.word	0x080001a1
 8000008:	080001a3 	.word	0x080001a3
 800000c:	080001a3 	.word	0x080001a3
 8000010:	080001a3 	.word	0x080001a3
 8000014:	080001a3 	.word	0x080001a3
 8000018:	080001a3 	.word	0x080001a3
 800001c:	080001a3 	.word	0x080001a3
 8000020:	080001a3 	.word	0x080001a3
 8000024:	080001a3 	.word	0x080001a3
 8000028:	080001a3 	.word	0x080001a3
 800002c:	08001601 	.word	0x08001601
 8000030:	080001a3 	.word	0x080001a3
 8000034:	080001a3 	.word	0x080001a3
 8000038:	080001a3 	.word	0x080001a3
 800003c:	080001a3 	.word	0x080001a3
 8000040:	080001a3 	.word	0x080001a3
 8000044:	080001a3 	.word	0x080001a3
 8000048:	080001a3 	.word	0x080001a3
 800004c:	080001a3 	.word	0x080001a3
 8000050:	080001a3 	.word	0x080001a3
 8000054:	080001a3 	.word	0x080001a3
 8000058:	080001a3 	.word	0x080001a3
 800005c:	080001a3 	.word	0x080001a3
 8000060:	080001a3 	.word	0x080001a3
 8000064:	080001a3 	.word	0x080001a3
 8000068:	080001a3 	.word	0x080001a3
 800006c:	080001a3 	.word	0x080001a3
 8000070:	080001a3 	.word	0x080001a3
 8000074:	080001a3 	.word	0x080001a3
 8000078:	080001a3 	.word	0x080001a3
 800007c:	080001a3 	.word	0x080001a3
 8000080:	080001a3 	.word	0x080001a3
 8000084:	080001a3 	.word	0x080001a3
 8000088:	080001a3 	.word	0x080001a3
 800008c:	080001a3 	.word	0x080001a3
 8000090:	080001a3 	.word	0x080001a3
 8000094:	080001a3 	.word	0x080001a3
 8000098:	080001a3 	.word	0x080001a3
 800009c:	080001a3 	.word	0x080001a3
 80000a0:	080001a3 	.word	0x080001a3
 80000a4:	080001a3 	.word	0x080001a3
 80000a8:	080001a3 	.word	0x080001a3
 80000ac:	080001a3 	.word	0x080001a3
 80000b0:	08001a01 	.word	0x08001a01
 80000b4:	080001a3 	.word	0x080001a3
 80000b8:	080001a3 	.word	0x080001a3
 80000bc:	080001a3 	.word	0x080001a3
 80000c0:	080001a3 	.word	0x080001a3
 80000c4:	080001a3 	.word	0x080001a3
 80000c8:	080001a3 	.word	0x080001a3
 80000cc:	080001a3 	.word	0x080001a3
 80000d0:	080001a3 	.word	0x080001a3
 80000d4:	080001a3 	.word	0x080001a3
 80000d8:	080001a3 	.word	0x080001a3
 80000dc:	080001a3 	.word	0x080001a3
 80000e0:	080001a3 	.word	0x080001a3
 80000e4:	080001a3 	.word	0x080001a3
 80000e8:	080001a3 	.word	0x080001a3
 80000ec:	080001a3 	.word	0x080001a3
 80000f0:	080001a3 	.word	0x080001a3
 80000f4:	080001a3 	.word	0x080001a3
 80000f8:	080001a3 	.word	0x080001a3
 80000fc:	080001a3 	.word	0x080001a3
 8000100:	080001a3 	.word	0x080001a3
 8000104:	080001a3 	.word	0x080001a3
 8000108:	080001a3 	.word	0x080001a3
 800010c:	080001a3 	.word	0x080001a3
 8000110:	080018c1 	.word	0x080018c1
 8000114:	080001a3 	.word	0x080001a3
 8000118:	080001a3 	.word	0x080001a3
 800011c:	080001a3 	.word	0x080001a3
 8000120:	080001a3 	.word	0x080001a3
 8000124:	080001a3 	.word	0x080001a3
 8000128:	080001a3 	.word	0x080001a3
 800012c:	080001a3 	.word	0x080001a3
 8000130:	080001a3 	.word	0x080001a3
 8000134:	080001a3 	.word	0x080001a3
 8000138:	080001a3 	.word	0x080001a3
 800013c:	080001a3 	.word	0x080001a3
 8000140:	080001a3 	.word	0x080001a3
 8000144:	080001a3 	.word	0x080001a3
 8000148:	080001a3 	.word	0x080001a3
 800014c:	080001a3 	.word	0x080001a3
 8000150:	080001a3 	.word	0x080001a3
 8000154:	080001a3 	.word	0x080001a3
 8000158:	080001a3 	.word	0x080001a3
 800015c:	080001a3 	.word	0x080001a3
 8000160:	080001a3 	.word	0x080001a3
 8000164:	080001a3 	.word	0x080001a3
 8000168:	080001a3 	.word	0x080001a3
 800016c:	080001a3 	.word	0x080001a3
 8000170:	080001a3 	.word	0x080001a3
 8000174:	080001a3 	.word	0x080001a3
 8000178:	080001a3 	.word	0x080001a3
 800017c:	080001a3 	.word	0x080001a3
 8000180:	080001a3 	.word	0x080001a3
 8000184:	080001a3 	.word	0x080001a3
 8000188:	080001a3 	.word	0x080001a3
 800018c:	080001a3 	.word	0x080001a3
 8000190:	080001a3 	.word	0x080001a3
 8000194:	080001a3 	.word	0x080001a3
 8000198:	080001a3 	.word	0x080001a3
 800019c:	080001a3 	.word	0x080001a3

Disassembly of section .text:

080001a0 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 80001a0:	e002      	b.n	80001a8 <_crt0_entry>

080001a2 <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 80001a2:	f000 f800 	bl	80001a6 <_unhandled_exception>

080001a6 <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 80001a6:	e7fe      	b.n	80001a6 <_unhandled_exception>

080001a8 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80001a8:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80001aa:	4829      	ldr	r0, [pc, #164]	; (8000250 <endfiniloop+0x6>)
                msr     MSP, r0
 80001ac:	f380 8808 	msr	MSP, r0
#endif
                ldr     r0, =__main_stack_base__
 80001b0:	4828      	ldr	r0, [pc, #160]	; (8000254 <endfiniloop+0xa>)
                msr     MSPLIM, r0
 80001b2:	f380 880a 	msr	MSPLIM, r0

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80001b6:	4828      	ldr	r0, [pc, #160]	; (8000258 <endfiniloop+0xe>)
                msr     PSP, r0
 80001b8:	f380 8809 	msr	PSP, r0
                ldr     r0, =__process_stack_base__
 80001bc:	4827      	ldr	r0, [pc, #156]	; (800025c <endfiniloop+0x12>)
                msr     PSPLIM, r0
 80001be:	f380 880b 	msr	PSPLIM, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 80001c2:	4827      	ldr	r0, [pc, #156]	; (8000260 <endfiniloop+0x16>)
                ldr     r1, =SCB_VTOR
 80001c4:	4927      	ldr	r1, [pc, #156]	; (8000264 <endfiniloop+0x1a>)
                str     r0, [r1]
 80001c6:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 80001c8:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 80001ca:	f380 8814 	msr	CONTROL, r0
                isb
 80001ce:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __cpu_init
 80001d2:	f001 fcdd 	bl	8001b90 <__cpu_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 80001d6:	f001 fa73 	bl	80016c0 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 80001da:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 80001de:	491d      	ldr	r1, [pc, #116]	; (8000254 <endfiniloop+0xa>)
                ldr     r2, =__main_stack_end__
 80001e0:	4a1b      	ldr	r2, [pc, #108]	; (8000250 <endfiniloop+0x6>)

080001e2 <msloop>:
msloop:
                cmp     r1, r2
 80001e2:	4291      	cmp	r1, r2
                itt     lo
 80001e4:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 80001e6:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 80001ea:	e7fa      	bcc.n	80001e2 <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 80001ec:	491b      	ldr	r1, [pc, #108]	; (800025c <endfiniloop+0x12>)
                ldr     r2, =__process_stack_end__
 80001ee:	4a1a      	ldr	r2, [pc, #104]	; (8000258 <endfiniloop+0xe>)

080001f0 <psloop>:
psloop:
                cmp     r1, r2
 80001f0:	4291      	cmp	r1, r2
                itt     lo
 80001f2:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 80001f4:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 80001f8:	e7fa      	bcc.n	80001f0 <psloop>

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                ldr     r1, =__textdata_base__
 80001fa:	491b      	ldr	r1, [pc, #108]	; (8000268 <endfiniloop+0x1e>)
                ldr     r2, =__data_base__
 80001fc:	4a1b      	ldr	r2, [pc, #108]	; (800026c <endfiniloop+0x22>)
                ldr     r3, =__data_end__
 80001fe:	4b1c      	ldr	r3, [pc, #112]	; (8000270 <endfiniloop+0x26>)

08000200 <dloop>:
dloop:
                cmp     r2, r3
 8000200:	429a      	cmp	r2, r3
                ittt    lo
 8000202:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 8000204:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 8000208:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 800020c:	e7f8      	bcc.n	8000200 <dloop>

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                movs    r0, #0
 800020e:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
 8000210:	4918      	ldr	r1, [pc, #96]	; (8000274 <endfiniloop+0x2a>)
                ldr     r2, =__bss_end__
 8000212:	4a19      	ldr	r2, [pc, #100]	; (8000278 <endfiniloop+0x2e>)

08000214 <bloop>:
bloop:
                cmp     r1, r2
 8000214:	4291      	cmp	r1, r2
                itt     lo
 8000216:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000218:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 800021c:	e7fa      	bcc.n	8000214 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 800021e:	f001 fc6f 	bl	8001b00 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 8000222:	f001 fcad 	bl	8001b80 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 8000226:	4c15      	ldr	r4, [pc, #84]	; (800027c <endfiniloop+0x32>)
                ldr     r5, =__init_array_end__
 8000228:	4d15      	ldr	r5, [pc, #84]	; (8000280 <endfiniloop+0x36>)

0800022a <initloop>:
initloop:
                cmp     r4, r5
 800022a:	42ac      	cmp	r4, r5
                bge     endinitloop
 800022c:	da03      	bge.n	8000236 <endinitloop>
                ldr     r1, [r4], #4
 800022e:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000232:	4788      	blx	r1
                b       initloop
 8000234:	e7f9      	b.n	800022a <initloop>

08000236 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000236:	f000 ff0b 	bl	8001050 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 800023a:	4c12      	ldr	r4, [pc, #72]	; (8000284 <endfiniloop+0x3a>)
                ldr     r5, =__fini_array_end__
 800023c:	4d12      	ldr	r5, [pc, #72]	; (8000288 <endfiniloop+0x3e>)

0800023e <finiloop>:
finiloop:
                cmp     r4, r5
 800023e:	42ac      	cmp	r4, r5
                bge     endfiniloop
 8000240:	da03      	bge.n	800024a <endfiniloop>
                ldr     r1, [r4], #4
 8000242:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000246:	4788      	blx	r1
                b       finiloop
 8000248:	e7f9      	b.n	800023e <finiloop>

0800024a <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 800024a:	f001 bc91 	b.w	8001b70 <__default_exit>
 800024e:	0000      	.short	0x0000
                ldr     r0, =__main_stack_end__
 8000250:	20000400 	.word	0x20000400
                ldr     r0, =__main_stack_base__
 8000254:	20000000 	.word	0x20000000
                ldr     r0, =__process_stack_end__
 8000258:	20000800 	.word	0x20000800
                ldr     r0, =__process_stack_base__
 800025c:	20000400 	.word	0x20000400
                ldr     r0, =_vectors
 8000260:	08000000 	.word	0x08000000
                ldr     r1, =SCB_VTOR
 8000264:	e000ed08 	.word	0xe000ed08
                ldr     r1, =__textdata_base__
 8000268:	08001cbc 	.word	0x08001cbc
                ldr     r2, =__data_base__
 800026c:	20000800 	.word	0x20000800
                ldr     r3, =__data_end__
 8000270:	20000800 	.word	0x20000800
                ldr     r1, =__bss_base__
 8000274:	20000800 	.word	0x20000800
                ldr     r2, =__bss_end__
 8000278:	20000c60 	.word	0x20000c60
                ldr     r4, =__init_array_base__
 800027c:	080001a0 	.word	0x080001a0
                ldr     r5, =__init_array_end__
 8000280:	080001a0 	.word	0x080001a0
                ldr     r4, =__fini_array_base__
 8000284:	080001a0 	.word	0x080001a0
                ldr     r5, =__fini_array_end__
 8000288:	080001a0 	.word	0x080001a0

0800028c <__port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  __port_switch
__port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 800028c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                movs    r3, #0
                msr     PSPLIM, r3      /* Temporarily disabling stack check.*/
#endif

                /* Switching stacks.*/
                str     sp, [r1, #CONTEXT_OFFSET]
 8000290:	f8c1 d00c 	str.w	sp, [r1, #12]
                ldr     sp, [r0, #CONTEXT_OFFSET]
 8000294:	f8d0 d00c 	ldr.w	sp, [r0, #12]

#if CORTEX_USE_FPU
                /* Restoring FPU context.*/
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 8000298:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800029c <__port_thread_start>:
                bl      __stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 800029c:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 800029e:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80002a2:	4628      	mov	r0, r5
                blx     r4
 80002a4:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 80002a6:	2000      	movs	r0, #0
                bl      chThdExit
 80002a8:	f001 f9ba 	bl	8001620 <chThdExit>

080002ac <.zombies>:
.zombies:       b       .zombies
 80002ac:	e7fe      	b.n	80002ac <.zombies>

080002ae <__port_switch_from_isr>:
                bl      __stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_lock
#endif
                bl      chSchDoPreemption
 80002ae:	f001 f9e7 	bl	8001680 <chSchDoPreemption>

080002b2 <__port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 80002b2:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 80002b4:	e7fe      	b.n	80002b4 <__port_exit_from_isr+0x2>
	...

080002b8 <memcpy>:
 80002b8:	4684      	mov	ip, r0
 80002ba:	ea41 0300 	orr.w	r3, r1, r0
 80002be:	f013 0303 	ands.w	r3, r3, #3
 80002c2:	d149      	bne.n	8000358 <memcpy+0xa0>
 80002c4:	3a40      	subs	r2, #64	; 0x40
 80002c6:	d323      	bcc.n	8000310 <memcpy+0x58>
 80002c8:	680b      	ldr	r3, [r1, #0]
 80002ca:	6003      	str	r3, [r0, #0]
 80002cc:	684b      	ldr	r3, [r1, #4]
 80002ce:	6043      	str	r3, [r0, #4]
 80002d0:	688b      	ldr	r3, [r1, #8]
 80002d2:	6083      	str	r3, [r0, #8]
 80002d4:	68cb      	ldr	r3, [r1, #12]
 80002d6:	60c3      	str	r3, [r0, #12]
 80002d8:	690b      	ldr	r3, [r1, #16]
 80002da:	6103      	str	r3, [r0, #16]
 80002dc:	694b      	ldr	r3, [r1, #20]
 80002de:	6143      	str	r3, [r0, #20]
 80002e0:	698b      	ldr	r3, [r1, #24]
 80002e2:	6183      	str	r3, [r0, #24]
 80002e4:	69cb      	ldr	r3, [r1, #28]
 80002e6:	61c3      	str	r3, [r0, #28]
 80002e8:	6a0b      	ldr	r3, [r1, #32]
 80002ea:	6203      	str	r3, [r0, #32]
 80002ec:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 80002ee:	6243      	str	r3, [r0, #36]	; 0x24
 80002f0:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 80002f2:	6283      	str	r3, [r0, #40]	; 0x28
 80002f4:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 80002f6:	62c3      	str	r3, [r0, #44]	; 0x2c
 80002f8:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 80002fa:	6303      	str	r3, [r0, #48]	; 0x30
 80002fc:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 80002fe:	6343      	str	r3, [r0, #52]	; 0x34
 8000300:	6b8b      	ldr	r3, [r1, #56]	; 0x38
 8000302:	6383      	str	r3, [r0, #56]	; 0x38
 8000304:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 8000306:	63c3      	str	r3, [r0, #60]	; 0x3c
 8000308:	3040      	adds	r0, #64	; 0x40
 800030a:	3140      	adds	r1, #64	; 0x40
 800030c:	3a40      	subs	r2, #64	; 0x40
 800030e:	d2db      	bcs.n	80002c8 <memcpy+0x10>
 8000310:	3230      	adds	r2, #48	; 0x30
 8000312:	d30b      	bcc.n	800032c <memcpy+0x74>
 8000314:	680b      	ldr	r3, [r1, #0]
 8000316:	6003      	str	r3, [r0, #0]
 8000318:	684b      	ldr	r3, [r1, #4]
 800031a:	6043      	str	r3, [r0, #4]
 800031c:	688b      	ldr	r3, [r1, #8]
 800031e:	6083      	str	r3, [r0, #8]
 8000320:	68cb      	ldr	r3, [r1, #12]
 8000322:	60c3      	str	r3, [r0, #12]
 8000324:	3010      	adds	r0, #16
 8000326:	3110      	adds	r1, #16
 8000328:	3a10      	subs	r2, #16
 800032a:	d2f3      	bcs.n	8000314 <memcpy+0x5c>
 800032c:	320c      	adds	r2, #12
 800032e:	d305      	bcc.n	800033c <memcpy+0x84>
 8000330:	f851 3b04 	ldr.w	r3, [r1], #4
 8000334:	f840 3b04 	str.w	r3, [r0], #4
 8000338:	3a04      	subs	r2, #4
 800033a:	d2f9      	bcs.n	8000330 <memcpy+0x78>
 800033c:	3204      	adds	r2, #4
 800033e:	d008      	beq.n	8000352 <memcpy+0x9a>
 8000340:	07d2      	lsls	r2, r2, #31
 8000342:	bf1c      	itt	ne
 8000344:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000348:	f800 3b01 	strbne.w	r3, [r0], #1
 800034c:	d301      	bcc.n	8000352 <memcpy+0x9a>
 800034e:	880b      	ldrh	r3, [r1, #0]
 8000350:	8003      	strh	r3, [r0, #0]
 8000352:	4660      	mov	r0, ip
 8000354:	4770      	bx	lr
 8000356:	bf00      	nop
 8000358:	2a08      	cmp	r2, #8
 800035a:	d313      	bcc.n	8000384 <memcpy+0xcc>
 800035c:	078b      	lsls	r3, r1, #30
 800035e:	d0b1      	beq.n	80002c4 <memcpy+0xc>
 8000360:	f010 0303 	ands.w	r3, r0, #3
 8000364:	d0ae      	beq.n	80002c4 <memcpy+0xc>
 8000366:	f1c3 0304 	rsb	r3, r3, #4
 800036a:	1ad2      	subs	r2, r2, r3
 800036c:	07db      	lsls	r3, r3, #31
 800036e:	bf1c      	itt	ne
 8000370:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000374:	f800 3b01 	strbne.w	r3, [r0], #1
 8000378:	d3a4      	bcc.n	80002c4 <memcpy+0xc>
 800037a:	f831 3b02 	ldrh.w	r3, [r1], #2
 800037e:	f820 3b02 	strh.w	r3, [r0], #2
 8000382:	e79f      	b.n	80002c4 <memcpy+0xc>
 8000384:	3a04      	subs	r2, #4
 8000386:	d3d9      	bcc.n	800033c <memcpy+0x84>
 8000388:	3a01      	subs	r2, #1
 800038a:	f811 3b01 	ldrb.w	r3, [r1], #1
 800038e:	f800 3b01 	strb.w	r3, [r0], #1
 8000392:	d2f9      	bcs.n	8000388 <memcpy+0xd0>
 8000394:	780b      	ldrb	r3, [r1, #0]
 8000396:	7003      	strb	r3, [r0, #0]
 8000398:	784b      	ldrb	r3, [r1, #1]
 800039a:	7043      	strb	r3, [r0, #1]
 800039c:	788b      	ldrb	r3, [r1, #2]
 800039e:	7083      	strb	r3, [r0, #2]
 80003a0:	4660      	mov	r0, ip
 80003a2:	4770      	bx	lr
	...

080003b0 <gpio_init.constprop.0>:
                one or more parameters can be selected which are shown as below:
      \arg        GPIO_PIN_x(x=0..15), GPIO_PIN_ALL
    \param[out] none
    \retval     none
*/
void gpio_init(uint32_t gpio_periph, uint32_t mode, uint32_t speed, uint32_t pin)
 80003b0:	b4f0      	push	{r4, r5, r6, r7}

    /* GPIO mode configuration */
    temp_mode = (uint32_t)(mode & ((uint32_t)0x0FU));
    
    /* GPIO speed configuration */
    if(((uint32_t)0x00U) != ((uint32_t)mode & ((uint32_t)0x10U))){
 80003b2:	06cb      	lsls	r3, r1, #27
        }
    }

    /* configure the eight low port pins with GPIO_CTL0 */
    for(i = 0U;i < 8U;i++){
        if((1U << i) & pin){
 80003b4:	f04f 0601 	mov.w	r6, #1
void gpio_init(uint32_t gpio_periph, uint32_t mode, uint32_t speed, uint32_t pin)
 80003b8:	f04f 0300 	mov.w	r3, #0
            reg = GPIO_CTL0(gpio_periph);
            
            /* clear the specified pin mode bits */
            reg &= ~GPIO_MODE_MASK(i);
 80003bc:	f04f 0c0f 	mov.w	ip, #15
    temp_mode = (uint32_t)(mode & ((uint32_t)0x0FU));
 80003c0:	f001 050f 	and.w	r5, r1, #15
            temp_mode |= (uint32_t)speed;
 80003c4:	bf48      	it	mi
 80003c6:	f045 0503 	orrmi.w	r5, r5, #3
        if((1U << i) & pin){
 80003ca:	fa06 f103 	lsl.w	r1, r6, r3
 80003ce:	4211      	tst	r1, r2
 80003d0:	d009      	beq.n	80003e6 <gpio_init.constprop.0+0x36>
            reg = GPIO_CTL0(gpio_periph);
 80003d2:	6804      	ldr	r4, [r0, #0]
 80003d4:	0099      	lsls	r1, r3, #2
            reg &= ~GPIO_MODE_MASK(i);
 80003d6:	fa0c f701 	lsl.w	r7, ip, r1
 80003da:	ea24 0407 	bic.w	r4, r4, r7
            /* set the specified pin mode bits */
            reg |= GPIO_MODE_SET(i, temp_mode);
 80003de:	fa05 f101 	lsl.w	r1, r5, r1
 80003e2:	4321      	orrs	r1, r4
                if(GPIO_MODE_IPU == mode){
                    GPIO_BOP(gpio_periph) = (uint32_t)((1U << i) & pin);
                }
            }
            /* set GPIO_CTL0 register */
            GPIO_CTL0(gpio_periph) = reg;
 80003e4:	6001      	str	r1, [r0, #0]
 80003e6:	3301      	adds	r3, #1
    for(i = 0U;i < 8U;i++){
 80003e8:	2b08      	cmp	r3, #8
 80003ea:	d1ee      	bne.n	80003ca <gpio_init.constprop.0+0x1a>
        }
    }
    /* configure the eight high port pins with GPIO_CTL1 */
    for(i = 8U;i < 16U;i++){
        if((1U << i) & pin){
 80003ec:	2601      	movs	r6, #1
            reg = GPIO_CTL1(gpio_periph);
            
            /* clear the specified pin mode bits */
            reg &= ~GPIO_MODE_MASK(i - 8U);
 80003ee:	f04f 0c0f 	mov.w	ip, #15
        if((1U << i) & pin){
 80003f2:	fa06 f103 	lsl.w	r1, r6, r3
 80003f6:	4211      	tst	r1, r2
 80003f8:	d00a      	beq.n	8000410 <gpio_init.constprop.0+0x60>
            reg &= ~GPIO_MODE_MASK(i - 8U);
 80003fa:	0099      	lsls	r1, r3, #2
            reg = GPIO_CTL1(gpio_periph);
 80003fc:	6844      	ldr	r4, [r0, #4]
            reg &= ~GPIO_MODE_MASK(i - 8U);
 80003fe:	3920      	subs	r1, #32
 8000400:	fa0c f701 	lsl.w	r7, ip, r1
 8000404:	ea24 0407 	bic.w	r4, r4, r7
            /* set the specified pin mode bits */
            reg |= GPIO_MODE_SET(i - 8U, temp_mode);
 8000408:	fa05 f101 	lsl.w	r1, r5, r1
 800040c:	4321      	orrs	r1, r4
                if(GPIO_MODE_IPU == mode){
                    GPIO_BOP(gpio_periph) = (uint32_t)((1U << i) & pin);
                }
            }
            /* set GPIO_CTL1 register */
            GPIO_CTL1(gpio_periph) = reg;
 800040e:	6041      	str	r1, [r0, #4]
 8000410:	3301      	adds	r3, #1
    for(i = 8U;i < 16U;i++){
 8000412:	2b10      	cmp	r3, #16
 8000414:	d1ed      	bne.n	80003f2 <gpio_init.constprop.0+0x42>
        }
    }
}
 8000416:	bcf0      	pop	{r4, r5, r6, r7}
 8000418:	4770      	bx	lr
 800041a:	bf00      	nop
 800041c:	0000      	movs	r0, r0
	...

08000420 <__idle_thread>:
 __STATIC_FORCEINLINE void port_wait_for_interrupt(void) {

 #if CORTEX_ENABLE_WFI_IDLE == TRUE
   __WFI();
 #endif
 }
 8000420:	e7fe      	b.n	8000420 <__idle_thread>
 8000422:	bf00      	nop
	...

08000430 <chCoreAllocFromTop>:
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000430:	2320      	movs	r3, #32
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
 8000432:	b430      	push	{r4, r5}
 8000434:	f383 8811 	msr	BASEPRI, r3
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8000438:	4b0b      	ldr	r3, [pc, #44]	; (8000468 <chCoreAllocFromTop+0x38>)
 800043a:	4249      	negs	r1, r1
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 800043c:	e9d3 4500 	ldrd	r4, r5, [r3]
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8000440:	1a28      	subs	r0, r5, r0
 8000442:	4008      	ands	r0, r1
  prev = p - offset;
 8000444:	1a82      	subs	r2, r0, r2
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8000446:	42a2      	cmp	r2, r4
 8000448:	d307      	bcc.n	800045a <chCoreAllocFromTop+0x2a>
 800044a:	4295      	cmp	r5, r2
 800044c:	d305      	bcc.n	800045a <chCoreAllocFromTop+0x2a>
  ch_memcore.topmem = prev;
 800044e:	605a      	str	r2, [r3, #4]
 8000450:	2300      	movs	r3, #0
 8000452:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
 8000456:	bc30      	pop	{r4, r5}
 8000458:	4770      	bx	lr
    return NULL;
 800045a:	2000      	movs	r0, #0
 800045c:	2300      	movs	r3, #0
 800045e:	f383 8811 	msr	BASEPRI, r3
}
 8000462:	bc30      	pop	{r4, r5}
 8000464:	4770      	bx	lr
 8000466:	bf00      	nop
 8000468:	20000c28 	.word	0x20000c28
 800046c:	00000000 	.word	0x00000000

08000470 <notify3>:

#if STM32_SERIAL_USE_USART3 || defined(__DOXYGEN__)
static void notify3(io_queue_t *qp) {

  (void)qp;
  USART_CTL0(UART3) |= 0x80;
 8000470:	4a02      	ldr	r2, [pc, #8]	; (800047c <notify3+0xc>)
 8000472:	6813      	ldr	r3, [r2, #0]
 8000474:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000478:	6013      	str	r3, [r2, #0]
}
 800047a:	4770      	bx	lr
 800047c:	40004c0c 	.word	0x40004c0c

08000480 <__port_irq_epilogue>:
 8000480:	2320      	movs	r3, #32
 8000482:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to @p __port_switch_from_isr().
 */
void __port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8000486:	4b0d      	ldr	r3, [pc, #52]	; (80004bc <__port_irq_epilogue+0x3c>)
 8000488:	685b      	ldr	r3, [r3, #4]
 800048a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800048e:	d102      	bne.n	8000496 <__port_irq_epilogue+0x16>
 8000490:	f383 8811 	msr	BASEPRI, r3
    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
}
 8000494:	4770      	bx	lr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8000496:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
 800049a:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
 800049e:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
 80004a0:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 80004a2:	f383 8809 	msr	PSP, r3
 */
bool chSchIsPreemptionRequired(void) {
  os_instance_t *oip = currcore;
  thread_t *tp = __instance_get_currthread(oip);

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
 80004a6:	4a06      	ldr	r2, [pc, #24]	; (80004c0 <__port_irq_epilogue+0x40>)
 80004a8:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = tp->hdr.pqueue.prio;
 80004aa:	68d2      	ldr	r2, [r2, #12]
    if (chSchIsPreemptionRequired()) {
 80004ac:	6889      	ldr	r1, [r1, #8]
 80004ae:	6892      	ldr	r2, [r2, #8]
 80004b0:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)__port_switch_from_isr;
 80004b2:	bf8c      	ite	hi
 80004b4:	4a03      	ldrhi	r2, [pc, #12]	; (80004c4 <__port_irq_epilogue+0x44>)
      ectxp->pc = (uint32_t)__port_exit_from_isr;
 80004b6:	4a04      	ldrls	r2, [pc, #16]	; (80004c8 <__port_irq_epilogue+0x48>)
 80004b8:	619a      	str	r2, [r3, #24]
 80004ba:	4770      	bx	lr
 80004bc:	e000ed00 	.word	0xe000ed00
 80004c0:	20000a58 	.word	0x20000a58
 80004c4:	080002af 	.word	0x080002af
 80004c8:	080002b2 	.word	0x080002b2
 80004cc:	00000000 	.word	0x00000000

080004d0 <chCoreAllocAlignedI>:
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 80004d0:	4b08      	ldr	r3, [pc, #32]	; (80004f4 <chCoreAllocAlignedI+0x24>)
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 80004d2:	b410      	push	{r4}
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 80004d4:	e9d3 4200 	ldrd	r4, r2, [r3]
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 80004d8:	4249      	negs	r1, r1
 80004da:	1a10      	subs	r0, r2, r0
 80004dc:	4008      	ands	r0, r1
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 80004de:	42a0      	cmp	r0, r4
 80004e0:	d304      	bcc.n	80004ec <chCoreAllocAlignedI+0x1c>
 80004e2:	4282      	cmp	r2, r0
 80004e4:	d302      	bcc.n	80004ec <chCoreAllocAlignedI+0x1c>

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
}
 80004e6:	bc10      	pop	{r4}
  ch_memcore.topmem = prev;
 80004e8:	6058      	str	r0, [r3, #4]
 80004ea:	4770      	bx	lr
    return NULL;
 80004ec:	2000      	movs	r0, #0
 80004ee:	bc10      	pop	{r4}
 80004f0:	4770      	bx	lr
 80004f2:	bf00      	nop
 80004f4:	20000c28 	.word	0x20000c28
	...

08000500 <chTMStopMeasurementX>:
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch_system.tmc.offset);
 8000500:	4a0e      	ldr	r2, [pc, #56]	; (800053c <chTMStopMeasurementX+0x3c>)
  *
  * @return              The realtime counter value.
  */
 __STATIC_FORCEINLINE rtcnt_t port_rt_get_counter_value(void) {

   return DWT->CYCCNT;
 8000502:	4b0f      	ldr	r3, [pc, #60]	; (8000540 <chTMStopMeasurementX+0x40>)
 8000504:	6891      	ldr	r1, [r2, #8]
 8000506:	685b      	ldr	r3, [r3, #4]
  tmp->last = (now - tmp->last) - offset;
 8000508:	6882      	ldr	r2, [r0, #8]
 800050a:	1a5b      	subs	r3, r3, r1
 800050c:	1a9b      	subs	r3, r3, r2
  tmp->n++;
 800050e:	68c2      	ldr	r2, [r0, #12]
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8000510:	b430      	push	{r4, r5}
  tmp->cumulative += (rttime_t)tmp->last;
 8000512:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
  if (tmp->last > tmp->worst) {
 8000516:	6841      	ldr	r1, [r0, #4]
  tmp->n++;
 8000518:	3201      	adds	r2, #1
  tmp->cumulative += (rttime_t)tmp->last;
 800051a:	18e4      	adds	r4, r4, r3
  tmp->last = (now - tmp->last) - offset;
 800051c:	e9c0 3202 	strd	r3, r2, [r0, #8]
  if (tmp->last < tmp->best) {
 8000520:	6802      	ldr	r2, [r0, #0]
  tmp->cumulative += (rttime_t)tmp->last;
 8000522:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
 8000526:	428b      	cmp	r3, r1
    tmp->worst = tmp->last;
 8000528:	bf88      	it	hi
 800052a:	6043      	strhi	r3, [r0, #4]
  if (tmp->last < tmp->best) {
 800052c:	4293      	cmp	r3, r2
  tmp->cumulative += (rttime_t)tmp->last;
 800052e:	e9c0 4504 	strd	r4, r5, [r0, #16]
}
 8000532:	bc30      	pop	{r4, r5}
    tmp->best = tmp->last;
 8000534:	bf38      	it	cc
 8000536:	6003      	strcc	r3, [r0, #0]
}
 8000538:	4770      	bx	lr
 800053a:	bf00      	nop
 800053c:	20000c30 	.word	0x20000c30
 8000540:	e0001000 	.word	0xe0001000
	...

08000550 <chTMStartMeasurementX>:
 8000550:	4b01      	ldr	r3, [pc, #4]	; (8000558 <chTMStartMeasurementX+0x8>)
 8000552:	685b      	ldr	r3, [r3, #4]
  tmp->last = chSysGetRealtimeCounterX();
 8000554:	6083      	str	r3, [r0, #8]
}
 8000556:	4770      	bx	lr
 8000558:	e0001000 	.word	0xe0001000
 800055c:	00000000 	.word	0x00000000

08000560 <_ctl>:
static msg_t _ctl(void *ip, unsigned int operation, void *arg) {
  SerialDriver *sdp = (SerialDriver *)ip;

  osalDbgCheck(sdp != NULL);

  switch (operation) {
 8000560:	2901      	cmp	r1, #1
#else
    return HAL_RET_UNKNOWN_CTL;
#endif
  }
  return HAL_RET_SUCCESS;
}
 8000562:	bf14      	ite	ne
 8000564:	f06f 0013 	mvnne.w	r0, #19
 8000568:	2000      	moveq	r0, #0
 800056a:	4770      	bx	lr
 800056c:	0000      	movs	r0, r0
	...

08000570 <vt_insert_first.constprop.0>:

/**
 * @brief   Inserts a timer as first element in a delta list.
 * @note    This is the special case when the delta list is initially empty.
 */
static void vt_insert_first(virtual_timers_list_t *vtlp,
 8000570:	2a02      	cmp	r2, #2
 8000572:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000574:	4614      	mov	r4, r2
 8000576:	bf38      	it	cc
 8000578:	2402      	movcc	r4, #2
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t abstime) {
  TIMER_CH0CV(TIMER1) = (uint32_t)abstime;
  TIMER_INTF(TIMER1) = 0;
 800057a:	f04f 0e00 	mov.w	lr, #0
  TIMER_DMAINTEN(TIMER1) = TIMER_INT_CH0; 
 800057e:	2602      	movs	r6, #2
                            sysinterval_t delay) {
  sysinterval_t currdelta;

  /* The delta list is empty, the current time becomes the new
     delta list base time, the timer is inserted.*/
  vtlp->lasttime = now;
 8000580:	4b14      	ldr	r3, [pc, #80]	; (80005d4 <vt_insert_first.constprop.0+0x64>)
  TIMER_CH0CV(TIMER1) = (uint32_t)abstime;
 8000582:	4f15      	ldr	r7, [pc, #84]	; (80005d8 <vt_insert_first.constprop.0+0x68>)
static inline void ch_dlist_insert_after(ch_delta_list_t *dlhp,
                                         ch_delta_list_t *dlp,
                                         sysinterval_t delta) {

  dlp->delta      = delta;
  dlp->prev       = dlhp;
 8000584:	f103 0510 	add.w	r5, r3, #16
 8000588:	61d9      	str	r1, [r3, #28]
 800058a:	6045      	str	r5, [r0, #4]
  dlp->next       = dlp->prev->next;
 800058c:	691d      	ldr	r5, [r3, #16]
  TIMER_DMAINTEN(TIMER1) = TIMER_INT_CH0; 
 800058e:	f8df c050 	ldr.w	ip, [pc, #80]	; 80005e0 <vt_insert_first.constprop.0+0x70>
  dlp->delta      = delta;
 8000592:	6082      	str	r2, [r0, #8]
  TIMER_INTF(TIMER1) = 0;
 8000594:	4a11      	ldr	r2, [pc, #68]	; (80005dc <vt_insert_first.constprop.0+0x6c>)
  dlp->next       = dlp->prev->next;
 8000596:	6005      	str	r5, [r0, #0]
  dlp->next->prev = dlp;
 8000598:	6068      	str	r0, [r5, #4]

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 800059a:	190d      	adds	r5, r1, r4
  TIMER_CH0CV(TIMER1) = (uint32_t)abstime;
 800059c:	603d      	str	r5, [r7, #0]
  return (systime_t)TIMER_CNT(TIMER1);
 800059e:	3214      	adds	r2, #20
  TIMER_INTF(TIMER1) = 0;
 80005a0:	f842 ec14 	str.w	lr, [r2, #-20]
  TIMER_DMAINTEN(TIMER1) = TIMER_INT_CH0; 
 80005a4:	f8cc 6000 	str.w	r6, [ip]
  return (systime_t)TIMER_CNT(TIMER1);
 80005a8:	6815      	ldr	r5, [r2, #0]
  dlhp->next      = dlp;
 80005aa:	6118      	str	r0, [r3, #16]
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 80005ac:	1a68      	subs	r0, r5, r1
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
    if (likely(chTimeDiffX(now, newnow) < delay)) {
 80005ae:	4284      	cmp	r4, r0
 80005b0:	d902      	bls.n	80005b8 <vt_insert_first.constprop.0+0x48>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 80005b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (likely(chTimeDiffX(now, newnow) < delay)) {
 80005b4:	4629      	mov	r1, r5
 80005b6:	4605      	mov	r5, r0
    currdelta += (sysinterval_t)1;
 80005b8:	3601      	adds	r6, #1
  return systime + (systime_t)interval;
 80005ba:	4431      	add	r1, r6
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t abstime) {
  TIMER_CH0CV(TIMER1) = (uint32_t)abstime;
 80005bc:	6039      	str	r1, [r7, #0]
  return (systime_t)TIMER_CNT(TIMER1);
 80005be:	6810      	ldr	r0, [r2, #0]
  return (sysinterval_t)((systime_t)(end - start));
 80005c0:	1b41      	subs	r1, r0, r5
    if (likely(chTimeDiffX(now, newnow) < delay)) {
 80005c2:	42b1      	cmp	r1, r6
 80005c4:	d2f6      	bcs.n	80005b4 <vt_insert_first.constprop.0+0x44>
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 80005c6:	2e02      	cmp	r6, #2
 80005c8:	d9f3      	bls.n	80005b2 <vt_insert_first.constprop.0+0x42>
 * @param[in] mask      fault flags to be added
 */
void chRFCUCollectFaultsI(rfcu_mask_t mask) {

#if CH_CFG_SMP_MODE == FALSE
  currcore->rfcu.mask |= mask;
 80005ca:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80005cc:	f042 0201 	orr.w	r2, r2, #1
 80005d0:	635a      	str	r2, [r3, #52]	; 0x34
}
 80005d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80005d4:	20000a58 	.word	0x20000a58
 80005d8:	40000034 	.word	0x40000034
 80005dc:	40000010 	.word	0x40000010
 80005e0:	4000000c 	.word	0x4000000c
	...

080005f0 <__sch_wakeup>:
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80005f0:	2320      	movs	r3, #32
 80005f2:	f383 8811 	msr	BASEPRI, r3
  switch (tp->state) {
 80005f6:	f891 3028 	ldrb.w	r3, [r1, #40]	; 0x28
 80005fa:	2b0c      	cmp	r3, #12
 80005fc:	d810      	bhi.n	8000620 <__sch_wakeup+0x30>
 80005fe:	e8df f003 	tbb	[pc, r3]
 8000602:	0f2a      	.short	0x0f2a
 8000604:	070b260f 	.word	0x070b260f
 8000608:	0f0f0b0f 	.word	0x0f0f0b0f
 800060c:	0f0f      	.short	0x0f0f
 800060e:	0b          	.byte	0x0b
 800060f:	00          	.byte	0x00
    chSemFastSignalI(tp->u.wtsemp);
 8000610:	6aca      	ldr	r2, [r1, #44]	; 0x2c
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 8000612:	6893      	ldr	r3, [r2, #8]
 8000614:	3301      	adds	r3, #1
 8000616:	6093      	str	r3, [r2, #8]
  p->prev->next = p->next;
 8000618:	e9d1 3200 	ldrd	r3, r2, [r1]
 800061c:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 800061e:	605a      	str	r2, [r3, #4]
  tp->state = CH_STATE_READY;
 8000620:	2200      	movs	r2, #0
static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
 8000622:	b410      	push	{r4}
  tp->u.rdymsg = MSG_TIMEOUT;
 8000624:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 8000628:	698b      	ldr	r3, [r1, #24]
  } while (unlikely(pqp->prio >= p->prio));
 800062a:	6888      	ldr	r0, [r1, #8]
  tp->u.rdymsg = MSG_TIMEOUT;
 800062c:	62cc      	str	r4, [r1, #44]	; 0x2c
  tp->state = CH_STATE_READY;
 800062e:	f881 2028 	strb.w	r2, [r1, #40]	; 0x28
    pqp = pqp->next;
 8000632:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio >= p->prio));
 8000634:	689a      	ldr	r2, [r3, #8]
 8000636:	4282      	cmp	r2, r0
 8000638:	d2fb      	bcs.n	8000632 <__sch_wakeup+0x42>
  p->prev       = pqp->prev;
 800063a:	685a      	ldr	r2, [r3, #4]
 800063c:	2000      	movs	r0, #0
 800063e:	e9c1 3200 	strd	r3, r2, [r1]
  p->prev->next = p;
 8000642:	6011      	str	r1, [r2, #0]
  pqp->prev     = p;
 8000644:	6059      	str	r1, [r3, #4]
 8000646:	f380 8811 	msr	BASEPRI, r0
}
 800064a:	bc10      	pop	{r4}
 800064c:	4770      	bx	lr
    *tp->u.wttrp = NULL;
 800064e:	2200      	movs	r2, #0
 8000650:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 8000652:	601a      	str	r2, [r3, #0]
    break;
 8000654:	e7e4      	b.n	8000620 <__sch_wakeup+0x30>
 8000656:	2300      	movs	r3, #0
 8000658:	f383 8811 	msr	BASEPRI, r3
 800065c:	4770      	bx	lr
 800065e:	bf00      	nop

08000660 <chSchReadyI>:
  tp->state = CH_STATE_READY;
 8000660:	2200      	movs	r2, #0
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 8000662:	6983      	ldr	r3, [r0, #24]
  } while (unlikely(pqp->prio >= p->prio));
 8000664:	6881      	ldr	r1, [r0, #8]
  tp->state = CH_STATE_READY;
 8000666:	f880 2028 	strb.w	r2, [r0, #40]	; 0x28
    pqp = pqp->next;
 800066a:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio >= p->prio));
 800066c:	689a      	ldr	r2, [r3, #8]
 800066e:	428a      	cmp	r2, r1
 8000670:	d2fb      	bcs.n	800066a <chSchReadyI+0xa>
  p->prev       = pqp->prev;
 8000672:	685a      	ldr	r2, [r3, #4]
 8000674:	e9c0 3200 	strd	r3, r2, [r0]
  p->prev->next = p;
 8000678:	6010      	str	r0, [r2, #0]
  pqp->prev     = p;
 800067a:	6058      	str	r0, [r3, #4]
}
 800067c:	4770      	bx	lr
 800067e:	bf00      	nop

08000680 <chEvtBroadcastFlagsI.constprop.0>:
 * @param[in] esp       pointer to an @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000680:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
 8000682:	4f15      	ldr	r7, [pc, #84]	; (80006d8 <chEvtBroadcastFlagsI.constprop.0+0x58>)
 8000684:	f857 4f04 	ldr.w	r4, [r7, #4]!
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8000688:	42bc      	cmp	r4, r7
 800068a:	d01f      	beq.n	80006cc <chEvtBroadcastFlagsI.constprop.0+0x4c>
 800068c:	4605      	mov	r5, r0
    tp->u.rdymsg = MSG_OK;
 800068e:	2600      	movs	r6, #0
 8000690:	e004      	b.n	800069c <chEvtBroadcastFlagsI.constprop.0+0x1c>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8000692:	2a0b      	cmp	r2, #11
 8000694:	d01b      	beq.n	80006ce <chEvtBroadcastFlagsI.constprop.0+0x4e>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
 8000696:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 8000698:	42bc      	cmp	r4, r7
 800069a:	d017      	beq.n	80006cc <chEvtBroadcastFlagsI.constprop.0+0x4c>
        ((flags & elp->wflags) != (eventflags_t)0)) {
 800069c:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
    elp->flags |= flags;
 80006a0:	432b      	orrs	r3, r5
    if ((flags == (eventflags_t)0) ||
 80006a2:	4215      	tst	r5, r2
    elp->flags |= flags;
 80006a4:	60e3      	str	r3, [r4, #12]
    if ((flags == (eventflags_t)0) ||
 80006a6:	d0f6      	beq.n	8000696 <chEvtBroadcastFlagsI.constprop.0+0x16>
  tp->epending |= events;
 80006a8:	e9d4 0301 	ldrd	r0, r3, [r4, #4]
 80006ac:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
  if (((tp->state == CH_STATE_WTOREVT) &&
 80006ae:	f890 2028 	ldrb.w	r2, [r0, #40]	; 0x28
  tp->epending |= events;
 80006b2:	430b      	orrs	r3, r1
  if (((tp->state == CH_STATE_WTOREVT) &&
 80006b4:	2a0a      	cmp	r2, #10
  tp->epending |= events;
 80006b6:	63c3      	str	r3, [r0, #60]	; 0x3c
  if (((tp->state == CH_STATE_WTOREVT) &&
 80006b8:	d1eb      	bne.n	8000692 <chEvtBroadcastFlagsI.constprop.0+0x12>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 80006ba:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  if (((tp->state == CH_STATE_WTOREVT) &&
 80006bc:	4213      	tst	r3, r2
 80006be:	d0ea      	beq.n	8000696 <chEvtBroadcastFlagsI.constprop.0+0x16>
    tp->u.rdymsg = MSG_OK;
 80006c0:	62c6      	str	r6, [r0, #44]	; 0x2c
    (void) chSchReadyI(tp);
 80006c2:	f7ff ffcd 	bl	8000660 <chSchReadyI>
    elp = elp->next;
 80006c6:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 80006c8:	42bc      	cmp	r4, r7
 80006ca:	d1e7      	bne.n	800069c <chEvtBroadcastFlagsI.constprop.0+0x1c>
  }
}
 80006cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 80006ce:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
      ((tp->state == CH_STATE_WTANDEVT) &&
 80006d0:	ea32 0303 	bics.w	r3, r2, r3
 80006d4:	d1df      	bne.n	8000696 <chEvtBroadcastFlagsI.constprop.0+0x16>
 80006d6:	e7f3      	b.n	80006c0 <chEvtBroadcastFlagsI.constprop.0+0x40>
 80006d8:	20000800 	.word	0x20000800
 80006dc:	00000000 	.word	0x00000000

080006e0 <vt_set_alarm>:
  if (delay < currdelta) {
 80006e0:	2902      	cmp	r1, #2
 80006e2:	bf38      	it	cc
 80006e4:	2102      	movcc	r1, #2
static void vt_set_alarm(systime_t now, sysinterval_t delay) {
 80006e6:	b410      	push	{r4}
  TIMER_CH0CV(TIMER1) = (uint32_t)abstime;
 80006e8:	4c0e      	ldr	r4, [pc, #56]	; (8000724 <vt_set_alarm+0x44>)
  return systime + (systime_t)interval;
 80006ea:	1843      	adds	r3, r0, r1
  return (systime_t)TIMER_CNT(TIMER1);
 80006ec:	4a0e      	ldr	r2, [pc, #56]	; (8000728 <vt_set_alarm+0x48>)
  TIMER_CH0CV(TIMER1) = (uint32_t)abstime;
 80006ee:	6023      	str	r3, [r4, #0]
  return (systime_t)TIMER_CNT(TIMER1);
 80006f0:	6813      	ldr	r3, [r2, #0]
  return (sysinterval_t)((systime_t)(end - start));
 80006f2:	1a18      	subs	r0, r3, r0
    if (likely(nowdelta < delay)) {
 80006f4:	4281      	cmp	r1, r0
 80006f6:	d901      	bls.n	80006fc <vt_set_alarm+0x1c>
}
 80006f8:	bc10      	pop	{r4}
 80006fa:	4770      	bx	lr
    if (likely(nowdelta < delay)) {
 80006fc:	2102      	movs	r1, #2
    currdelta += (sysinterval_t)1;
 80006fe:	3101      	adds	r1, #1
  return systime + (systime_t)interval;
 8000700:	18c8      	adds	r0, r1, r3
  TIMER_CH0CV(TIMER1) = (uint32_t)abstime;
 8000702:	6020      	str	r0, [r4, #0]
  return (systime_t)TIMER_CNT(TIMER1);
 8000704:	6810      	ldr	r0, [r2, #0]
  return (sysinterval_t)((systime_t)(end - start));
 8000706:	1ac3      	subs	r3, r0, r3
    if (likely(nowdelta < delay)) {
 8000708:	428b      	cmp	r3, r1
 800070a:	d208      	bcs.n	800071e <vt_set_alarm+0x3e>
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 800070c:	2902      	cmp	r1, #2
 800070e:	d9f3      	bls.n	80006f8 <vt_set_alarm+0x18>
 8000710:	4a06      	ldr	r2, [pc, #24]	; (800072c <vt_set_alarm+0x4c>)
}
 8000712:	bc10      	pop	{r4}
 8000714:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8000716:	f043 0301 	orr.w	r3, r3, #1
 800071a:	6353      	str	r3, [r2, #52]	; 0x34
 800071c:	4770      	bx	lr
 800071e:	4603      	mov	r3, r0
 8000720:	e7ed      	b.n	80006fe <vt_set_alarm+0x1e>
 8000722:	bf00      	nop
 8000724:	40000034 	.word	0x40000034
 8000728:	40000024 	.word	0x40000024
 800072c:	20000a58 	.word	0x20000a58

08000730 <chprintf.constprop.0>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8000730:	b40e      	push	{r1, r2, r3}
 8000732:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000736:	b086      	sub	sp, #24
 8000738:	af0f      	add	r7, sp, #60	; 0x3c
 800073a:	f857 4b04 	ldr.w	r4, [r7], #4
    c = *fmt++;
 800073e:	4622      	mov	r2, r4
 8000740:	f812 1b01 	ldrb.w	r1, [r2], #1
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8000744:	9702      	str	r7, [sp, #8]
    if (c == 0) {
 8000746:	2900      	cmp	r1, #0
 8000748:	f000 8243 	beq.w	8000bd2 <chprintf.constprop.0+0x4a2>
  int n = 0;
 800074c:	f04f 0b00 	mov.w	fp, #0
 8000750:	4dc0      	ldr	r5, [pc, #768]	; (8000a54 <chprintf.constprop.0+0x324>)
 8000752:	e00c      	b.n	800076e <chprintf.constprop.0+0x3e>
      streamPut(chp, (uint8_t)c);
 8000754:	682b      	ldr	r3, [r5, #0]
 8000756:	48bf      	ldr	r0, [pc, #764]	; (8000a54 <chprintf.constprop.0+0x324>)
 8000758:	68db      	ldr	r3, [r3, #12]
      n++;
 800075a:	4614      	mov	r4, r2
 800075c:	f10b 0b01 	add.w	fp, fp, #1
      streamPut(chp, (uint8_t)c);
 8000760:	4798      	blx	r3
    c = *fmt++;
 8000762:	4622      	mov	r2, r4
 8000764:	f812 1b01 	ldrb.w	r1, [r2], #1
    if (c == 0) {
 8000768:	2900      	cmp	r1, #0
 800076a:	f000 80c1 	beq.w	80008f0 <chprintf.constprop.0+0x1c0>
    if (c != '%') {
 800076e:	2925      	cmp	r1, #37	; 0x25
 8000770:	d1f0      	bne.n	8000754 <chprintf.constprop.0+0x24>
    if (*fmt == '-') {
 8000772:	7863      	ldrb	r3, [r4, #1]
 8000774:	2b2d      	cmp	r3, #45	; 0x2d
      fmt++;
 8000776:	bf08      	it	eq
 8000778:	1ca2      	addeq	r2, r4, #2
    if (*fmt == '+') {
 800077a:	7813      	ldrb	r3, [r2, #0]
      left_align = true;
 800077c:	bf0c      	ite	eq
 800077e:	f04f 0c01 	moveq.w	ip, #1
    left_align = false;
 8000782:	f04f 0c00 	movne.w	ip, #0
    if (*fmt == '+') {
 8000786:	2b2b      	cmp	r3, #43	; 0x2b
      do_sign = true;
 8000788:	bf05      	ittet	eq
 800078a:	2601      	moveq	r6, #1
 800078c:	7853      	ldrbeq	r3, [r2, #1]
    do_sign = false;
 800078e:	2600      	movne	r6, #0
      fmt++;
 8000790:	1992      	addeq	r2, r2, r6
    if (*fmt == '0') {
 8000792:	2b30      	cmp	r3, #48	; 0x30
      filler = '0';
 8000794:	bf05      	ittet	eq
 8000796:	4699      	moveq	r9, r3
      fmt++;
 8000798:	7853      	ldrbeq	r3, [r2, #1]
    filler = ' ';
 800079a:	f04f 0920 	movne.w	r9, #32
      fmt++;
 800079e:	3201      	addeq	r2, #1
    if ( *fmt == '*') {
 80007a0:	2b2a      	cmp	r3, #42	; 0x2a
 80007a2:	f040 80ae 	bne.w	8000902 <chprintf.constprop.0+0x1d2>
      width = va_arg(ap, int);
 80007a6:	f857 1b04 	ldr.w	r1, [r7], #4
      c = *fmt++;
 80007aa:	7853      	ldrb	r3, [r2, #1]
 80007ac:	1c94      	adds	r4, r2, #2
    if (c == '.') {
 80007ae:	2b2e      	cmp	r3, #46	; 0x2e
 80007b0:	f000 8132 	beq.w	8000a18 <chprintf.constprop.0+0x2e8>
    precision = 0;
 80007b4:	2200      	movs	r2, #0
    if (c == 'l' || c == 'L') {
 80007b6:	f003 00df 	and.w	r0, r3, #223	; 0xdf
 80007ba:	284c      	cmp	r0, #76	; 0x4c
 80007bc:	f000 80b4 	beq.w	8000928 <chprintf.constprop.0+0x1f8>
 80007c0:	f1a3 0e44 	sub.w	lr, r3, #68	; 0x44
 80007c4:	f1be 0f34 	cmp.w	lr, #52	; 0x34
 80007c8:	f200 819d 	bhi.w	8000b06 <chprintf.constprop.0+0x3d6>
 80007cc:	e8df f01e 	tbh	[pc, lr, lsl #1]
 80007d0:	019b0167 	.word	0x019b0167
 80007d4:	019b019b 	.word	0x019b019b
 80007d8:	0167019b 	.word	0x0167019b
 80007dc:	019b019b 	.word	0x019b019b
 80007e0:	019b019b 	.word	0x019b019b
 80007e4:	019f019b 	.word	0x019f019b
 80007e8:	019b0035 	.word	0x019b0035
 80007ec:	019b019b 	.word	0x019b019b
 80007f0:	0096019b 	.word	0x0096019b
 80007f4:	019b019b 	.word	0x019b019b
 80007f8:	019b0035 	.word	0x019b0035
 80007fc:	019b019b 	.word	0x019b019b
 8000800:	019b019b 	.word	0x019b019b
 8000804:	019b019b 	.word	0x019b019b
 8000808:	019b019b 	.word	0x019b019b
 800080c:	0153019b 	.word	0x0153019b
 8000810:	019b0167 	.word	0x019b0167
 8000814:	019b019b 	.word	0x019b019b
 8000818:	0167019b 	.word	0x0167019b
 800081c:	019b019b 	.word	0x019b019b
 8000820:	019b019b 	.word	0x019b019b
 8000824:	019f019b 	.word	0x019f019b
 8000828:	019b0035 	.word	0x019b0035
 800082c:	012f019b 	.word	0x012f019b
 8000830:	0096019b 	.word	0x0096019b
 8000834:	019b019b 	.word	0x019b019b
 8000838:	0035      	.short	0x0035
      if (c == 0) {
 800083a:	f04f 0e10 	mov.w	lr, #16
        l = va_arg(ap, unsigned int);
 800083e:	f857 0b04 	ldr.w	r0, [r7], #4
  q = p + MAX_FILLER;
 8000842:	f10d 0317 	add.w	r3, sp, #23
 8000846:	e000      	b.n	800084a <chprintf.constprop.0+0x11a>
  } while ((ll /= radix) != 0);
 8000848:	4633      	mov	r3, r6
    i = (int)(l % radix);
 800084a:	4680      	mov	r8, r0
 800084c:	fbb0 f0fe 	udiv	r0, r0, lr
 8000850:	fb0e 8a10 	mls	sl, lr, r0, r8
    i += '0';
 8000854:	f10a 0230 	add.w	r2, sl, #48	; 0x30
    if (i > '9') {
 8000858:	2a39      	cmp	r2, #57	; 0x39
      i += 'A' - '0' - 10;
 800085a:	bfc8      	it	gt
 800085c:	f10a 0237 	addgt.w	r2, sl, #55	; 0x37
    *--q = i;
 8000860:	b2d2      	uxtb	r2, r2
  } while ((ll /= radix) != 0);
 8000862:	45f0      	cmp	r8, lr
    *--q = i;
 8000864:	f103 36ff 	add.w	r6, r3, #4294967295	; 0xffffffff
 8000868:	f803 2c01 	strb.w	r2, [r3, #-1]
  } while ((ll /= radix) != 0);
 800086c:	d2ec      	bcs.n	8000848 <chprintf.constprop.0+0x118>
 800086e:	f10d 0e17 	add.w	lr, sp, #23
 8000872:	469a      	mov	sl, r3
  i = (int)(p + MAX_FILLER - q);
 8000874:	4673      	mov	r3, lr
 8000876:	f10d 080c 	add.w	r8, sp, #12
 800087a:	1b9e      	subs	r6, r3, r6
 800087c:	4640      	mov	r0, r8
 800087e:	4653      	mov	r3, sl
 8000880:	e001      	b.n	8000886 <chprintf.constprop.0+0x156>
 8000882:	f813 2b01 	ldrb.w	r2, [r3], #1
  while (--i);
 8000886:	4573      	cmp	r3, lr
    *p++ = *q++;
 8000888:	f800 2b01 	strb.w	r2, [r0], #1
  while (--i);
 800088c:	d1f9      	bne.n	8000882 <chprintf.constprop.0+0x152>
 800088e:	1b89      	subs	r1, r1, r6
 8000890:	3e01      	subs	r6, #1
 8000892:	ea21 7ae1 	bic.w	sl, r1, r1, asr #31
    if (left_align == false) {
 8000896:	f1bc 0f00 	cmp.w	ip, #0
 800089a:	d104      	bne.n	80008a6 <chprintf.constprop.0+0x176>
    if (width < 0) {
 800089c:	2900      	cmp	r1, #0
      width = -width;
 800089e:	f1ca 0a00 	rsb	sl, sl, #0
    if (width < 0) {
 80008a2:	f300 8148 	bgt.w	8000b36 <chprintf.constprop.0+0x406>
    while (--i >= 0) {
 80008a6:	2e00      	cmp	r6, #0
 80008a8:	db0f      	blt.n	80008ca <chprintf.constprop.0+0x19a>
 80008aa:	1c73      	adds	r3, r6, #1
 80008ac:	4443      	add	r3, r8
 80008ae:	9401      	str	r4, [sp, #4]
 80008b0:	461c      	mov	r4, r3
      streamPut(chp, (uint8_t)*s++);
 80008b2:	682a      	ldr	r2, [r5, #0]
 80008b4:	f818 1b01 	ldrb.w	r1, [r8], #1
 80008b8:	4628      	mov	r0, r5
 80008ba:	68d2      	ldr	r2, [r2, #12]
 80008bc:	4790      	blx	r2
    while (--i >= 0) {
 80008be:	45a0      	cmp	r8, r4
 80008c0:	d1f7      	bne.n	80008b2 <chprintf.constprop.0+0x182>
 80008c2:	f10b 0b01 	add.w	fp, fp, #1
 80008c6:	9c01      	ldr	r4, [sp, #4]
 80008c8:	44b3      	add	fp, r6
    while (width) {
 80008ca:	f1ba 0f00 	cmp.w	sl, #0
 80008ce:	f43f af48 	beq.w	8000762 <chprintf.constprop.0+0x32>
 80008d2:	4656      	mov	r6, sl
      streamPut(chp, (uint8_t)filler);
 80008d4:	682b      	ldr	r3, [r5, #0]
 80008d6:	4649      	mov	r1, r9
 80008d8:	4628      	mov	r0, r5
 80008da:	68db      	ldr	r3, [r3, #12]
 80008dc:	4798      	blx	r3
    while (width) {
 80008de:	3e01      	subs	r6, #1
 80008e0:	d1f8      	bne.n	80008d4 <chprintf.constprop.0+0x1a4>
    c = *fmt++;
 80008e2:	4622      	mov	r2, r4
 80008e4:	f812 1b01 	ldrb.w	r1, [r2], #1
 80008e8:	44d3      	add	fp, sl
    if (c == 0) {
 80008ea:	2900      	cmp	r1, #0
 80008ec:	f47f af3f 	bne.w	800076e <chprintf.constprop.0+0x3e>
  formatted_bytes = chvprintf(chp, fmt, ap);
  va_end(ap);

  return formatted_bytes;
}
 80008f0:	4658      	mov	r0, fp
 80008f2:	b006      	add	sp, #24
 80008f4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80008f8:	b003      	add	sp, #12
 80008fa:	4770      	bx	lr
      if (c == 0) {
 80008fc:	f04f 0e0a 	mov.w	lr, #10
 8000900:	e79d      	b.n	800083e <chprintf.constprop.0+0x10e>
        c = *fmt++;
 8000902:	1c54      	adds	r4, r2, #1
        if (c == 0) {
 8000904:	2b00      	cmp	r3, #0
 8000906:	d0f3      	beq.n	80008f0 <chprintf.constprop.0+0x1c0>
      width = 0;
 8000908:	2100      	movs	r1, #0
        if (c >= '0' && c <= '9') {
 800090a:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 800090e:	b2d2      	uxtb	r2, r2
 8000910:	2a09      	cmp	r2, #9
          width = width * 10 + c;
 8000912:	eb01 0081 	add.w	r0, r1, r1, lsl #2
        if (c >= '0' && c <= '9') {
 8000916:	f63f af4a 	bhi.w	80007ae <chprintf.constprop.0+0x7e>
        c = *fmt++;
 800091a:	f814 3b01 	ldrb.w	r3, [r4], #1
          width = width * 10 + c;
 800091e:	eb02 0140 	add.w	r1, r2, r0, lsl #1
        if (c == 0) {
 8000922:	2b00      	cmp	r3, #0
 8000924:	d1f1      	bne.n	800090a <chprintf.constprop.0+0x1da>
 8000926:	e7e3      	b.n	80008f0 <chprintf.constprop.0+0x1c0>
      c = *fmt++;
 8000928:	f814 3b01 	ldrb.w	r3, [r4], #1
      if (c == 0) {
 800092c:	2b00      	cmp	r3, #0
 800092e:	d0df      	beq.n	80008f0 <chprintf.constprop.0+0x1c0>
 8000930:	f1a3 0044 	sub.w	r0, r3, #68	; 0x44
 8000934:	2834      	cmp	r0, #52	; 0x34
 8000936:	f200 80e6 	bhi.w	8000b06 <chprintf.constprop.0+0x3d6>
 800093a:	f20f 0e08 	addw	lr, pc, #8
 800093e:	f85e f020 	ldr.w	pc, [lr, r0, lsl #2]
 8000942:	bf00      	nop
 8000944:	08000a9f 	.word	0x08000a9f
 8000948:	08000b07 	.word	0x08000b07
 800094c:	08000b07 	.word	0x08000b07
 8000950:	08000b07 	.word	0x08000b07
 8000954:	08000b07 	.word	0x08000b07
 8000958:	08000a9f 	.word	0x08000a9f
 800095c:	08000b07 	.word	0x08000b07
 8000960:	08000b07 	.word	0x08000b07
 8000964:	08000b07 	.word	0x08000b07
 8000968:	08000b07 	.word	0x08000b07
 800096c:	08000b07 	.word	0x08000b07
 8000970:	08000b0f 	.word	0x08000b0f
 8000974:	0800083b 	.word	0x0800083b
 8000978:	08000b07 	.word	0x08000b07
 800097c:	08000b07 	.word	0x08000b07
 8000980:	08000b07 	.word	0x08000b07
 8000984:	08000b07 	.word	0x08000b07
 8000988:	080008fd 	.word	0x080008fd
 800098c:	08000b07 	.word	0x08000b07
 8000990:	08000b07 	.word	0x08000b07
 8000994:	0800083b 	.word	0x0800083b
 8000998:	08000b07 	.word	0x08000b07
 800099c:	08000b07 	.word	0x08000b07
 80009a0:	08000b07 	.word	0x08000b07
 80009a4:	08000b07 	.word	0x08000b07
 80009a8:	08000b07 	.word	0x08000b07
 80009ac:	08000b07 	.word	0x08000b07
 80009b0:	08000b07 	.word	0x08000b07
 80009b4:	08000b07 	.word	0x08000b07
 80009b8:	08000b07 	.word	0x08000b07
 80009bc:	08000b07 	.word	0x08000b07
 80009c0:	08000a77 	.word	0x08000a77
 80009c4:	08000a9f 	.word	0x08000a9f
 80009c8:	08000b07 	.word	0x08000b07
 80009cc:	08000b07 	.word	0x08000b07
 80009d0:	08000b07 	.word	0x08000b07
 80009d4:	08000b07 	.word	0x08000b07
 80009d8:	08000a9f 	.word	0x08000a9f
 80009dc:	08000b07 	.word	0x08000b07
 80009e0:	08000b07 	.word	0x08000b07
 80009e4:	08000b07 	.word	0x08000b07
 80009e8:	08000b07 	.word	0x08000b07
 80009ec:	08000b07 	.word	0x08000b07
 80009f0:	08000b0f 	.word	0x08000b0f
 80009f4:	0800083b 	.word	0x0800083b
 80009f8:	08000b07 	.word	0x08000b07
 80009fc:	08000b07 	.word	0x08000b07
 8000a00:	08000a2f 	.word	0x08000a2f
 8000a04:	08000b07 	.word	0x08000b07
 8000a08:	080008fd 	.word	0x080008fd
 8000a0c:	08000b07 	.word	0x08000b07
 8000a10:	08000b07 	.word	0x08000b07
 8000a14:	0800083b 	.word	0x0800083b
      c = *fmt++;
 8000a18:	7823      	ldrb	r3, [r4, #0]
      if (c == 0) {
 8000a1a:	2b00      	cmp	r3, #0
 8000a1c:	f43f af68 	beq.w	80008f0 <chprintf.constprop.0+0x1c0>
      if (c == '*') {
 8000a20:	2b2a      	cmp	r3, #42	; 0x2a
 8000a22:	d177      	bne.n	8000b14 <chprintf.constprop.0+0x3e4>
        c = *fmt++;
 8000a24:	7863      	ldrb	r3, [r4, #1]
        precision = va_arg(ap, int);
 8000a26:	f857 2b04 	ldr.w	r2, [r7], #4
        c = *fmt++;
 8000a2a:	3402      	adds	r4, #2
 8000a2c:	e6c3      	b.n	80007b6 <chprintf.constprop.0+0x86>
      if ((s = va_arg(ap, char *)) == 0) {
 8000a2e:	f857 8b04 	ldr.w	r8, [r7], #4
 8000a32:	f1b8 0f00 	cmp.w	r8, #0
 8000a36:	f000 80c2 	beq.w	8000bbe <chprintf.constprop.0+0x48e>
 8000a3a:	f898 3000 	ldrb.w	r3, [r8]
      if (precision == 0) {
 8000a3e:	2a00      	cmp	r2, #0
 8000a40:	f040 80ad 	bne.w	8000b9e <chprintf.constprop.0+0x46e>
      for (p = s; *p && (--precision >= 0); p++)
 8000a44:	2b00      	cmp	r3, #0
 8000a46:	f000 80ae 	beq.w	8000ba6 <chprintf.constprop.0+0x476>
 8000a4a:	f647 72fe 	movw	r2, #32766	; 0x7ffe
 8000a4e:	4646      	mov	r6, r8
 8000a50:	e004      	b.n	8000a5c <chprintf.constprop.0+0x32c>
 8000a52:	bf00      	nop
 8000a54:	20000800 	.word	0x20000800
 8000a58:	42d3      	cmn	r3, r2
 8000a5a:	d405      	bmi.n	8000a68 <chprintf.constprop.0+0x338>
 8000a5c:	f816 0f01 	ldrb.w	r0, [r6, #1]!
 8000a60:	eba8 0306 	sub.w	r3, r8, r6
 8000a64:	2800      	cmp	r0, #0
 8000a66:	d1f7      	bne.n	8000a58 <chprintf.constprop.0+0x328>
 8000a68:	eba6 0608 	sub.w	r6, r6, r8
 8000a6c:	1b89      	subs	r1, r1, r6
      filler = ' ';
 8000a6e:	f04f 0920 	mov.w	r9, #32
 8000a72:	3e01      	subs	r6, #1
 8000a74:	e70d      	b.n	8000892 <chprintf.constprop.0+0x162>
      filler = ' ';
 8000a76:	f04f 0920 	mov.w	r9, #32
      *p++ = va_arg(ap, int);
 8000a7a:	f857 3b04 	ldr.w	r3, [r7], #4
 8000a7e:	3901      	subs	r1, #1
 8000a80:	f88d 300c 	strb.w	r3, [sp, #12]
 8000a84:	ea21 7ae1 	bic.w	sl, r1, r1, asr #31
    if (left_align == false) {
 8000a88:	f1bc 0f00 	cmp.w	ip, #0
 8000a8c:	d103      	bne.n	8000a96 <chprintf.constprop.0+0x366>
    if (width < 0) {
 8000a8e:	2900      	cmp	r1, #0
      width = -width;
 8000a90:	f1ca 0a00 	rsb	sl, sl, #0
    if (width < 0) {
 8000a94:	dc7d      	bgt.n	8000b92 <chprintf.constprop.0+0x462>
    if (left_align == false) {
 8000a96:	2600      	movs	r6, #0
 8000a98:	f10d 080c 	add.w	r8, sp, #12
 8000a9c:	e705      	b.n	80008aa <chprintf.constprop.0+0x17a>
        l = va_arg(ap, int);
 8000a9e:	f857 eb04 	ldr.w	lr, [r7], #4
      if (l < 0) {
 8000aa2:	f1be 0f00 	cmp.w	lr, #0
 8000aa6:	db6a      	blt.n	8000b7e <chprintf.constprop.0+0x44e>
        if (do_sign) {
 8000aa8:	2e00      	cmp	r6, #0
 8000aaa:	f000 808e 	beq.w	8000bca <chprintf.constprop.0+0x49a>
          *p++ = '+';
 8000aae:	232b      	movs	r3, #43	; 0x2b
 8000ab0:	f10d 060d 	add.w	r6, sp, #13
 8000ab4:	f88d 300c 	strb.w	r3, [sp, #12]
 8000ab8:	f10d 080c 	add.w	r8, sp, #12
  q = p + MAX_FILLER;
 8000abc:	f106 030b 	add.w	r3, r6, #11
 8000ac0:	461a      	mov	r2, r3
 8000ac2:	9301      	str	r3, [sp, #4]
    i = (int)(l % radix);
 8000ac4:	4b47      	ldr	r3, [pc, #284]	; (8000be4 <chprintf.constprop.0+0x4b4>)
 8000ac6:	46f2      	mov	sl, lr
 8000ac8:	fba3 030e 	umull	r0, r3, r3, lr
 8000acc:	08db      	lsrs	r3, r3, #3
 8000ace:	4618      	mov	r0, r3
 8000ad0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8000ad4:	ebae 0343 	sub.w	r3, lr, r3, lsl #1
    i += '0';
 8000ad8:	3330      	adds	r3, #48	; 0x30
    *--q = i;
 8000ada:	b2db      	uxtb	r3, r3
  } while ((ll /= radix) != 0);
 8000adc:	f1ba 0f09 	cmp.w	sl, #9
    l /= radix;
 8000ae0:	4686      	mov	lr, r0
    *--q = i;
 8000ae2:	f802 3d01 	strb.w	r3, [r2, #-1]!
  } while ((ll /= radix) != 0);
 8000ae6:	dced      	bgt.n	8000ac4 <chprintf.constprop.0+0x394>
  i = (int)(p + MAX_FILLER - q);
 8000ae8:	9801      	ldr	r0, [sp, #4]
 8000aea:	1a80      	subs	r0, r0, r2
 8000aec:	4430      	add	r0, r6
 8000aee:	e001      	b.n	8000af4 <chprintf.constprop.0+0x3c4>
 8000af0:	f812 3f01 	ldrb.w	r3, [r2, #1]!
    *p++ = *q++;
 8000af4:	f806 3b01 	strb.w	r3, [r6], #1
  while (--i);
 8000af8:	4286      	cmp	r6, r0
 8000afa:	d1f9      	bne.n	8000af0 <chprintf.constprop.0+0x3c0>
 8000afc:	eba6 0608 	sub.w	r6, r6, r8
 8000b00:	1b89      	subs	r1, r1, r6
 8000b02:	3e01      	subs	r6, #1
 8000b04:	e6c5      	b.n	8000892 <chprintf.constprop.0+0x162>
      *p++ = c;
 8000b06:	f88d 300c 	strb.w	r3, [sp, #12]
 8000b0a:	3901      	subs	r1, #1
 8000b0c:	e7ba      	b.n	8000a84 <chprintf.constprop.0+0x354>
      if (c == 0) {
 8000b0e:	f04f 0e08 	mov.w	lr, #8
 8000b12:	e694      	b.n	800083e <chprintf.constprop.0+0x10e>
    precision = 0;
 8000b14:	2200      	movs	r2, #0
      c = *fmt++;
 8000b16:	3401      	adds	r4, #1
        while (c >= '0' && c <= '9') {
 8000b18:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
 8000b1c:	b2c0      	uxtb	r0, r0
 8000b1e:	2809      	cmp	r0, #9
          precision = precision * 10 + c;
 8000b20:	eb02 0e82 	add.w	lr, r2, r2, lsl #2
        while (c >= '0' && c <= '9') {
 8000b24:	f63f ae47 	bhi.w	80007b6 <chprintf.constprop.0+0x86>
          c = *fmt++;
 8000b28:	f814 3b01 	ldrb.w	r3, [r4], #1
          precision = precision * 10 + c;
 8000b2c:	eb00 024e 	add.w	r2, r0, lr, lsl #1
          if (c == 0) {
 8000b30:	2b00      	cmp	r3, #0
 8000b32:	d1f1      	bne.n	8000b18 <chprintf.constprop.0+0x3e8>
 8000b34:	e6dc      	b.n	80008f0 <chprintf.constprop.0+0x1c0>
      width = -width;
 8000b36:	f8cd a004 	str.w	sl, [sp, #4]
      if ((*s == '-' || *s == '+') && filler == '0') {
 8000b3a:	f898 1000 	ldrb.w	r1, [r8]
 8000b3e:	292d      	cmp	r1, #45	; 0x2d
 8000b40:	d010      	beq.n	8000b64 <chprintf.constprop.0+0x434>
 8000b42:	292b      	cmp	r1, #43	; 0x2b
 8000b44:	d00e      	beq.n	8000b64 <chprintf.constprop.0+0x434>
        streamPut(chp, (uint8_t)filler);
 8000b46:	682b      	ldr	r3, [r5, #0]
 8000b48:	4649      	mov	r1, r9
 8000b4a:	4628      	mov	r0, r5
 8000b4c:	68db      	ldr	r3, [r3, #12]
 8000b4e:	4798      	blx	r3
      } while (++width != 0);
 8000b50:	f11a 0a01 	adds.w	sl, sl, #1
 8000b54:	d1f7      	bne.n	8000b46 <chprintf.constprop.0+0x416>
 8000b56:	9b01      	ldr	r3, [sp, #4]
    while (--i >= 0) {
 8000b58:	2e00      	cmp	r6, #0
 8000b5a:	ebab 0b03 	sub.w	fp, fp, r3
 8000b5e:	f6bf aea4 	bge.w	80008aa <chprintf.constprop.0+0x17a>
 8000b62:	e5fe      	b.n	8000762 <chprintf.constprop.0+0x32>
      if ((*s == '-' || *s == '+') && filler == '0') {
 8000b64:	f1b9 0f30 	cmp.w	r9, #48	; 0x30
 8000b68:	d1ed      	bne.n	8000b46 <chprintf.constprop.0+0x416>
        streamPut(chp, (uint8_t)*s++);
 8000b6a:	682a      	ldr	r2, [r5, #0]
 8000b6c:	481e      	ldr	r0, [pc, #120]	; (8000be8 <chprintf.constprop.0+0x4b8>)
 8000b6e:	68d2      	ldr	r2, [r2, #12]
 8000b70:	4790      	blx	r2
 8000b72:	f108 0801 	add.w	r8, r8, #1
        n++;
 8000b76:	f10b 0b01 	add.w	fp, fp, #1
 8000b7a:	3e01      	subs	r6, #1
 8000b7c:	e7e3      	b.n	8000b46 <chprintf.constprop.0+0x416>
        *p++ = '-';
 8000b7e:	232d      	movs	r3, #45	; 0x2d
        l = -l;
 8000b80:	f1ce 0e00 	rsb	lr, lr, #0
        *p++ = '-';
 8000b84:	f88d 300c 	strb.w	r3, [sp, #12]
 8000b88:	f10d 060d 	add.w	r6, sp, #13
 8000b8c:	f10d 080c 	add.w	r8, sp, #12
 8000b90:	e794      	b.n	8000abc <chprintf.constprop.0+0x38c>
    if (width < 0) {
 8000b92:	4666      	mov	r6, ip
      width = -width;
 8000b94:	f8cd a004 	str.w	sl, [sp, #4]
    if (width < 0) {
 8000b98:	f10d 080c 	add.w	r8, sp, #12
 8000b9c:	e7cd      	b.n	8000b3a <chprintf.constprop.0+0x40a>
      for (p = s; *p && (--precision >= 0); p++)
 8000b9e:	b113      	cbz	r3, 8000ba6 <chprintf.constprop.0+0x476>
 8000ba0:	3a01      	subs	r2, #1
 8000ba2:	f57f af54 	bpl.w	8000a4e <chprintf.constprop.0+0x31e>
 8000ba6:	ea21 7ae1 	bic.w	sl, r1, r1, asr #31
    if (left_align == false) {
 8000baa:	f1bc 0f00 	cmp.w	ip, #0
 8000bae:	d103      	bne.n	8000bb8 <chprintf.constprop.0+0x488>
    if (width < 0) {
 8000bb0:	2900      	cmp	r1, #0
      width = -width;
 8000bb2:	f1ca 0a00 	rsb	sl, sl, #0
    if (width < 0) {
 8000bb6:	dc0e      	bgt.n	8000bd6 <chprintf.constprop.0+0x4a6>
    if (left_align == false) {
 8000bb8:	f04f 0920 	mov.w	r9, #32
 8000bbc:	e685      	b.n	80008ca <chprintf.constprop.0+0x19a>
        s = "(null)";
 8000bbe:	f8df 802c 	ldr.w	r8, [pc, #44]	; 8000bec <chprintf.constprop.0+0x4bc>
      if (precision == 0) {
 8000bc2:	2a00      	cmp	r2, #0
 8000bc4:	f43f af41 	beq.w	8000a4a <chprintf.constprop.0+0x31a>
 8000bc8:	e7ea      	b.n	8000ba0 <chprintf.constprop.0+0x470>
    p = tmpbuf;
 8000bca:	f10d 080c 	add.w	r8, sp, #12
 8000bce:	4646      	mov	r6, r8
 8000bd0:	e774      	b.n	8000abc <chprintf.constprop.0+0x38c>
  int n = 0;
 8000bd2:	468b      	mov	fp, r1
 8000bd4:	e68c      	b.n	80008f0 <chprintf.constprop.0+0x1c0>
    if (width < 0) {
 8000bd6:	f04f 0920 	mov.w	r9, #32
 8000bda:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
      width = -width;
 8000bde:	f8cd a004 	str.w	sl, [sp, #4]
 8000be2:	e7aa      	b.n	8000b3a <chprintf.constprop.0+0x40a>
 8000be4:	cccccccd 	.word	0xcccccccd
 8000be8:	20000800 	.word	0x20000800
 8000bec:	08001bac 	.word	0x08001bac

08000bf0 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
 8000bf0:	b430      	push	{r4, r5}
  ntp->state = CH_STATE_CURRENT;
 8000bf2:	2501      	movs	r5, #1
  thread_t *otp = __instance_get_currthread(oip);
 8000bf4:	4b07      	ldr	r3, [pc, #28]	; (8000c14 <chSchGoSleepS+0x24>)
 8000bf6:	68d9      	ldr	r1, [r3, #12]
  ch_priority_queue_t *p = pqp->next;
 8000bf8:	681a      	ldr	r2, [r3, #0]
  otp->state = newstate;
 8000bfa:	f881 0028 	strb.w	r0, [r1, #40]	; 0x28
  pqp->next       = p->next;
 8000bfe:	6814      	ldr	r4, [r2, #0]
  chSysSwitch(ntp, otp);
 8000c00:	4610      	mov	r0, r2
  pqp->next->prev = pqp;
 8000c02:	6063      	str	r3, [r4, #4]
  ntp->state = CH_STATE_CURRENT;
 8000c04:	f882 5028 	strb.w	r5, [r2, #40]	; 0x28
  pqp->next       = p->next;
 8000c08:	601c      	str	r4, [r3, #0]
}
 8000c0a:	bc30      	pop	{r4, r5}
  __instance_set_currthread(oip, ntp);
 8000c0c:	60da      	str	r2, [r3, #12]
  chSysSwitch(ntp, otp);
 8000c0e:	f7ff bb3d 	b.w	800028c <__port_switch>
 8000c12:	bf00      	nop
 8000c14:	20000a58 	.word	0x20000a58
	...

08000c20 <chSchGoSleepTimeoutS>:
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8000c20:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  thread_t *tp = __instance_get_currthread(currcore);
 8000c24:	4d39      	ldr	r5, [pc, #228]	; (8000d0c <chSchGoSleepTimeoutS+0xec>)
  if (TIME_INFINITE != timeout) {
 8000c26:	1c4b      	adds	r3, r1, #1
  thread_t *tp = __instance_get_currthread(currcore);
 8000c28:	f8d5 900c 	ldr.w	r9, [r5, #12]
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8000c2c:	b087      	sub	sp, #28
  if (TIME_INFINITE != timeout) {
 8000c2e:	d041      	beq.n	8000cb4 <chSchGoSleepTimeoutS+0x94>
  return (bool)(dlhp == dlhp->next);
 8000c30:	46a8      	mov	r8, r5
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  /* Timer initialization.*/
  vtp->par     = par;
  vtp->func    = vtfunc;
  vtp->reload  = (sysinterval_t)0;
 8000c32:	2700      	movs	r7, #0
 8000c34:	f858 2f10 	ldr.w	r2, [r8, #16]!
  vtp->par     = par;
 8000c38:	e9cd 9704 	strd	r9, r7, [sp, #16]
 8000c3c:	4606      	mov	r6, r0
  vtp->func    = vtfunc;
 8000c3e:	4b34      	ldr	r3, [pc, #208]	; (8000d10 <chSchGoSleepTimeoutS+0xf0>)
 8000c40:	4834      	ldr	r0, [pc, #208]	; (8000d14 <chSchGoSleepTimeoutS+0xf4>)
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8000c42:	4542      	cmp	r2, r8
 8000c44:	6800      	ldr	r0, [r0, #0]
 8000c46:	460c      	mov	r4, r1
  vtp->func    = vtfunc;
 8000c48:	9303      	str	r3, [sp, #12]
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8000c4a:	d055      	beq.n	8000cf8 <chSchGoSleepTimeoutS+0xd8>
 8000c4c:	69eb      	ldr	r3, [r5, #28]
    if (delta < vtlp->dlist.next->delta) {
 8000c4e:	6897      	ldr	r7, [r2, #8]
 8000c50:	1ac3      	subs	r3, r0, r3
    if (delta < nowdelta) {
 8000c52:	18cb      	adds	r3, r1, r3
 8000c54:	bf38      	it	cc
 8000c56:	461c      	movcc	r4, r3
    if (delta < vtlp->dlist.next->delta) {
 8000c58:	42a7      	cmp	r7, r4
 8000c5a:	d832      	bhi.n	8000cc2 <chSchGoSleepTimeoutS+0xa2>
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
  while (likely(dlp->delta < delta)) {
 8000c5c:	6893      	ldr	r3, [r2, #8]
 8000c5e:	429c      	cmp	r4, r3
 8000c60:	d904      	bls.n	8000c6c <chSchGoSleepTimeoutS+0x4c>
    /* Debug assert if the element is already in the list.*/
    chDbgAssert(dlp != dlep, "element already in list");

    delta -= dlp->delta;
    dlp = dlp->next;
 8000c62:	6812      	ldr	r2, [r2, #0]
    delta -= dlp->delta;
 8000c64:	1ae4      	subs	r4, r4, r3
  while (likely(dlp->delta < delta)) {
 8000c66:	6893      	ldr	r3, [r2, #8]
 8000c68:	42a3      	cmp	r3, r4
 8000c6a:	d3fa      	bcc.n	8000c62 <chSchGoSleepTimeoutS+0x42>
  dlp->prev->next = dlp;
 8000c6c:	466f      	mov	r7, sp
  dlp->delta -= delta;

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
 8000c6e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  dlp->delta      = delta;
 8000c72:	9402      	str	r4, [sp, #8]
  dlp->prev       = dlp->next->prev;
 8000c74:	e9d2 3101 	ldrd	r3, r1, [r2, #4]
  dlp->delta -= delta;
 8000c78:	1b0c      	subs	r4, r1, r4
  dlp->prev       = dlp->next->prev;
 8000c7a:	e9cd 2300 	strd	r2, r3, [sp]
  dlp->prev->next = dlp;
 8000c7e:	601f      	str	r7, [r3, #0]
  dlhp->prev      = dlp;
 8000c80:	e9c2 7401 	strd	r7, r4, [r2, #4]
  dlhp->delta = (sysinterval_t)-1;
 8000c84:	61a8      	str	r0, [r5, #24]
    chSchGoSleepS(newstate);
 8000c86:	4630      	mov	r0, r6
 8000c88:	f7ff ffb2 	bl	8000bf0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8000c8c:	9b00      	ldr	r3, [sp, #0]
 8000c8e:	b163      	cbz	r3, 8000caa <chSchGoSleepTimeoutS+0x8a>
  systime_t now;
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (!ch_dlist_isfirst(&vtlp->dlist, &vtp->dlist)) {
 8000c90:	692a      	ldr	r2, [r5, #16]
 8000c92:	42ba      	cmp	r2, r7
 8000c94:	d019      	beq.n	8000cca <chSchGoSleepTimeoutS+0xaa>
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {

  dlp->prev->next = dlp->next;
 8000c96:	e9dd 1401 	ldrd	r1, r4, [sp, #4]
    vtp->dlist.next = NULL;

    /* Special case when the removed element from the last position in the list,
       the value in the header must be restored, just doing it is faster than
       checking then doing.*/
    vtlp->dlist.delta = (sysinterval_t)-1;
 8000c9a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    vtp->dlist.next->delta += vtp->dlist.delta;
 8000c9e:	689a      	ldr	r2, [r3, #8]
 8000ca0:	600b      	str	r3, [r1, #0]
 8000ca2:	4422      	add	r2, r4
  dlp->next->prev = dlp->prev;
 8000ca4:	e9c3 1201 	strd	r1, r2, [r3, #4]
    vtlp->dlist.delta = (sysinterval_t)-1;
 8000ca8:	61a8      	str	r0, [r5, #24]
}
 8000caa:	f8d9 002c 	ldr.w	r0, [r9, #44]	; 0x2c
 8000cae:	b007      	add	sp, #28
 8000cb0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    chSchGoSleepS(newstate);
 8000cb4:	f7ff ff9c 	bl	8000bf0 <chSchGoSleepS>
}
 8000cb8:	f8d9 002c 	ldr.w	r0, [r9, #44]	; 0x2c
 8000cbc:	b007      	add	sp, #28
 8000cbe:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      vt_set_alarm(now, delay);
 8000cc2:	f7ff fd0d 	bl	80006e0 <vt_set_alarm>
 8000cc6:	692a      	ldr	r2, [r5, #16]
 8000cc8:	e7c8      	b.n	8000c5c <chSchGoSleepTimeoutS+0x3c>
    return;
  }

  /* Removing the first timer from the list, marking it as not armed.*/
  ch_dlist_remove_first(&vtlp->dlist);
  vtp->dlist.next = NULL;
 8000cca:	2100      	movs	r1, #0
  dlhp->next       = dlp->next;
 8000ccc:	612b      	str	r3, [r5, #16]
  dlhp->next->prev = dlhp;
 8000cce:	f8c3 8004 	str.w	r8, [r3, #4]
  return (bool)(dlhp == dlhp->next);
 8000cd2:	692a      	ldr	r2, [r5, #16]
 8000cd4:	9100      	str	r1, [sp, #0]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8000cd6:	4542      	cmp	r2, r8
 8000cd8:	d015      	beq.n	8000d06 <chSchGoSleepTimeoutS+0xe6>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  vtlp->dlist.next->delta += vtp->dlist.delta;
 8000cda:	6893      	ldr	r3, [r2, #8]
 8000cdc:	9902      	ldr	r1, [sp, #8]
 8000cde:	480d      	ldr	r0, [pc, #52]	; (8000d14 <chSchGoSleepTimeoutS+0xf4>)
 8000ce0:	440b      	add	r3, r1
 8000ce2:	6093      	str	r3, [r2, #8]

  /* Distance in ticks between the last alarm event and current time.*/
  now = chVTGetSystemTimeX();
  nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8000ce4:	69e9      	ldr	r1, [r5, #28]
 8000ce6:	6800      	ldr	r0, [r0, #0]
 8000ce8:	1a42      	subs	r2, r0, r1

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= vtlp->dlist.next->delta) {
 8000cea:	4293      	cmp	r3, r2
 8000cec:	d9dd      	bls.n	8000caa <chSchGoSleepTimeoutS+0x8a>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = vtlp->dlist.next->delta - nowdelta;
 8000cee:	1a09      	subs	r1, r1, r0

  /* Setting up the alarm.*/
  vt_set_alarm(now, delta);
 8000cf0:	4419      	add	r1, r3
 8000cf2:	f7ff fcf5 	bl	80006e0 <vt_set_alarm>
 8000cf6:	e7d8      	b.n	8000caa <chSchGoSleepTimeoutS+0x8a>
      vt_insert_first(vtlp, vtp, now, delay);
 8000cf8:	466f      	mov	r7, sp
 8000cfa:	460a      	mov	r2, r1
 8000cfc:	4601      	mov	r1, r0
 8000cfe:	4638      	mov	r0, r7
 8000d00:	f7ff fc36 	bl	8000570 <vt_insert_first.constprop.0>
 8000d04:	e7bf      	b.n	8000c86 <chSchGoSleepTimeoutS+0x66>
  TIMER_DMAINTEN(TIMER1) = 0;
 8000d06:	4b04      	ldr	r3, [pc, #16]	; (8000d18 <chSchGoSleepTimeoutS+0xf8>)
 8000d08:	6019      	str	r1, [r3, #0]
 8000d0a:	e7ce      	b.n	8000caa <chSchGoSleepTimeoutS+0x8a>
 8000d0c:	20000a58 	.word	0x20000a58
 8000d10:	080005f1 	.word	0x080005f1
 8000d14:	40000024 	.word	0x40000024
 8000d18:	4000000c 	.word	0x4000000c
 8000d1c:	00000000 	.word	0x00000000

08000d20 <chThdEnqueueTimeoutS>:
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return __sch_get_currthread();
 8000d20:	4a08      	ldr	r2, [pc, #32]	; (8000d44 <chThdEnqueueTimeoutS+0x24>)
 8000d22:	68d2      	ldr	r2, [r2, #12]
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
  thread_t *currtp = chThdGetSelfX();

  if (unlikely(TIME_IMMEDIATE == timeout)) {
 8000d24:	b151      	cbz	r1, 8000d3c <chThdEnqueueTimeoutS+0x1c>
 8000d26:	4603      	mov	r3, r0
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
 8000d28:	b410      	push	{r4}
  p->prev       = qp->prev;
 8000d2a:	6844      	ldr	r4, [r0, #4]
 8000d2c:	e9c2 0400 	strd	r0, r4, [r2]
  p->prev->next = p;
 8000d30:	6022      	str	r2, [r4, #0]
    return MSG_TIMEOUT;
  }

  ch_queue_insert(&tqp->queue, (ch_queue_t *)currtp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8000d32:	2004      	movs	r0, #4
}
 8000d34:	bc10      	pop	{r4}
  qp->prev      = p;
 8000d36:	605a      	str	r2, [r3, #4]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8000d38:	f7ff bf72 	b.w	8000c20 <chSchGoSleepTimeoutS>
}
 8000d3c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8000d40:	4770      	bx	lr
 8000d42:	bf00      	nop
 8000d44:	20000a58 	.word	0x20000a58
	...

08000d50 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, sysinterval_t timeout) {
 8000d50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000d52:	4604      	mov	r4, r0
 8000d54:	460f      	mov	r7, r1
 8000d56:	4616      	mov	r6, r2
 8000d58:	2320      	movs	r3, #32
 8000d5a:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  __stats_start_measure_crit_thd();
  __dbg_check_lock();
 8000d5e:	e005      	b.n	8000d6c <oqPutTimeout+0x1c>
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              sysinterval_t timeout) {

  return chThdEnqueueTimeoutS(tqp, timeout);
 8000d60:	4631      	mov	r1, r6
 8000d62:	4620      	mov	r0, r4
 8000d64:	f7ff ffdc 	bl	8000d20 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 8000d68:	2800      	cmp	r0, #0
 8000d6a:	db17      	blt.n	8000d9c <oqPutTimeout+0x4c>
  while (oqIsFullI(oqp)) {
 8000d6c:	68a5      	ldr	r5, [r4, #8]
 8000d6e:	2d00      	cmp	r5, #0
 8000d70:	d0f6      	beq.n	8000d60 <oqPutTimeout+0x10>
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 8000d72:	6962      	ldr	r2, [r4, #20]
  oqp->q_counter--;
 8000d74:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000d76:	1c51      	adds	r1, r2, #1
  oqp->q_counter--;
 8000d78:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 8000d7a:	6161      	str	r1, [r4, #20]
  oqp->q_counter--;
 8000d7c:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000d7e:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8000d80:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
 8000d84:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 8000d86:	bf24      	itt	cs
 8000d88:	68e3      	ldrcs	r3, [r4, #12]
 8000d8a:	6163      	strcs	r3, [r4, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 8000d8c:	69e3      	ldr	r3, [r4, #28]
 8000d8e:	b10b      	cbz	r3, 8000d94 <oqPutTimeout+0x44>
    oqp->q_notify(oqp);
 8000d90:	4620      	mov	r0, r4
 8000d92:	4798      	blx	r3
 8000d94:	2000      	movs	r0, #0
 8000d96:	f380 8811 	msr	BASEPRI, r0
  }

  osalSysUnlock();

  return MSG_OK;
}
 8000d9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000d9c:	f385 8811 	msr	BASEPRI, r5
 8000da0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000da2:	bf00      	nop
	...

08000db0 <_putt>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8000db0:	3030      	adds	r0, #48	; 0x30
 8000db2:	f7ff bfcd 	b.w	8000d50 <oqPutTimeout>
 8000db6:	bf00      	nop
	...

08000dc0 <_put>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8000dc0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000dc4:	3030      	adds	r0, #48	; 0x30
 8000dc6:	f7ff bfc3 	b.w	8000d50 <oqPutTimeout>
 8000dca:	bf00      	nop
 8000dcc:	0000      	movs	r0, r0
	...

08000dd0 <iqGetTimeout>:
msg_t iqGetTimeout(input_queue_t *iqp, sysinterval_t timeout) {
 8000dd0:	b570      	push	{r4, r5, r6, lr}
 8000dd2:	2320      	movs	r3, #32
 8000dd4:	4605      	mov	r5, r0
 8000dd6:	460e      	mov	r6, r1
 8000dd8:	f383 8811 	msr	BASEPRI, r3
 8000ddc:	e005      	b.n	8000dea <iqGetTimeout+0x1a>
 8000dde:	4631      	mov	r1, r6
 8000de0:	4628      	mov	r0, r5
 8000de2:	f7ff ff9d 	bl	8000d20 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 8000de6:	2800      	cmp	r0, #0
 8000de8:	db18      	blt.n	8000e1c <iqGetTimeout+0x4c>
  while (iqIsEmptyI(iqp)) {
 8000dea:	68ac      	ldr	r4, [r5, #8]
 8000dec:	2c00      	cmp	r4, #0
 8000dee:	d0f6      	beq.n	8000dde <iqGetTimeout+0xe>
  b = *iqp->q_rdptr++;
 8000df0:	69a9      	ldr	r1, [r5, #24]
  iqp->q_counter--;
 8000df2:	68ab      	ldr	r3, [r5, #8]
  if (iqp->q_rdptr >= iqp->q_top) {
 8000df4:	6928      	ldr	r0, [r5, #16]
  b = *iqp->q_rdptr++;
 8000df6:	1c4a      	adds	r2, r1, #1
  iqp->q_counter--;
 8000df8:	3b01      	subs	r3, #1
  if (iqp->q_rdptr >= iqp->q_top) {
 8000dfa:	4282      	cmp	r2, r0
  iqp->q_counter--;
 8000dfc:	60ab      	str	r3, [r5, #8]
    iqp->q_rdptr = iqp->q_buffer;
 8000dfe:	bf28      	it	cs
 8000e00:	68eb      	ldrcs	r3, [r5, #12]
  b = *iqp->q_rdptr++;
 8000e02:	61aa      	str	r2, [r5, #24]
 8000e04:	780c      	ldrb	r4, [r1, #0]
    iqp->q_rdptr = iqp->q_buffer;
 8000e06:	bf28      	it	cs
 8000e08:	61ab      	strcs	r3, [r5, #24]
  if (iqp->q_notify != NULL) {
 8000e0a:	69eb      	ldr	r3, [r5, #28]
 8000e0c:	b10b      	cbz	r3, 8000e12 <iqGetTimeout+0x42>
    iqp->q_notify(iqp);
 8000e0e:	4628      	mov	r0, r5
 8000e10:	4798      	blx	r3
 8000e12:	2300      	movs	r3, #0
 8000e14:	f383 8811 	msr	BASEPRI, r3
  return (msg_t)b;
 8000e18:	4620      	mov	r0, r4
}
 8000e1a:	bd70      	pop	{r4, r5, r6, pc}
 8000e1c:	f384 8811 	msr	BASEPRI, r4
 8000e20:	bd70      	pop	{r4, r5, r6, pc}
 8000e22:	bf00      	nop
	...

08000e30 <_gett>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8000e30:	300c      	adds	r0, #12
 8000e32:	f7ff bfcd 	b.w	8000dd0 <iqGetTimeout>
 8000e36:	bf00      	nop
	...

08000e40 <_get>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8000e40:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8000e44:	300c      	adds	r0, #12
 8000e46:	f7ff bfc3 	b.w	8000dd0 <iqGetTimeout>
 8000e4a:	bf00      	nop
 8000e4c:	0000      	movs	r0, r0
	...

08000e50 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 8000e50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000e54:	b085      	sub	sp, #20
 8000e56:	f04f 0920 	mov.w	r9, #32
 8000e5a:	e9cd 3202 	strd	r3, r2, [sp, #8]
  qnotify_t nfy = oqp->q_notify;
 8000e5e:	69c7      	ldr	r7, [r0, #28]
 8000e60:	f389 8811 	msr	BASEPRI, r9

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
 8000e64:	b3aa      	cbz	r2, 8000ed2 <oqWriteTimeout+0x82>
 8000e66:	4604      	mov	r4, r0
 8000e68:	460e      	mov	r6, r1
 8000e6a:	f04f 0a00 	mov.w	sl, #0
 8000e6e:	f8dd b00c 	ldr.w	fp, [sp, #12]
  if (n > oqGetEmptyI(oqp)) {
 8000e72:	68a2      	ldr	r2, [r4, #8]
 8000e74:	4593      	cmp	fp, r2
 8000e76:	bf98      	it	ls
 8000e78:	465d      	movls	r5, fp
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 8000e7a:	e9d4 2004 	ldrd	r2, r0, [r4, #16]
    n = oqGetEmptyI(oqp);
 8000e7e:	bf88      	it	hi
 8000e80:	68a5      	ldrhi	r5, [r4, #8]
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 8000e82:	eba2 0800 	sub.w	r8, r2, r0
  if (n < s1) {
 8000e86:	45a8      	cmp	r8, r5
 8000e88:	d844      	bhi.n	8000f14 <oqWriteTimeout+0xc4>
  else if (n > s1) {
 8000e8a:	d229      	bcs.n	8000ee0 <oqWriteTimeout+0x90>
    s2 = n - s1;
 8000e8c:	eba5 0308 	sub.w	r3, r5, r8
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 8000e90:	4642      	mov	r2, r8
 8000e92:	4631      	mov	r1, r6
    s2 = n - s1;
 8000e94:	9301      	str	r3, [sp, #4]
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 8000e96:	f7ff fa0f 	bl	80002b8 <memcpy>
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
 8000e9a:	eb06 0108 	add.w	r1, r6, r8
 8000e9e:	f8dd 8004 	ldr.w	r8, [sp, #4]
 8000ea2:	68e0      	ldr	r0, [r4, #12]
 8000ea4:	4642      	mov	r2, r8
 8000ea6:	f7ff fa07 	bl	80002b8 <memcpy>
    oqp->q_wrptr = oqp->q_buffer + s2;
 8000eaa:	4643      	mov	r3, r8
  oqp->q_counter -= n;
 8000eac:	68a2      	ldr	r2, [r4, #8]
    oqp->q_wrptr = oqp->q_buffer + s2;
 8000eae:	68e1      	ldr	r1, [r4, #12]
  oqp->q_counter -= n;
 8000eb0:	1b52      	subs	r2, r2, r5
    oqp->q_wrptr = oqp->q_buffer + s2;
 8000eb2:	18cb      	adds	r3, r1, r3
 8000eb4:	6163      	str	r3, [r4, #20]
  oqp->q_counter -= n;
 8000eb6:	60a2      	str	r2, [r4, #8]
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
 8000eb8:	b10f      	cbz	r7, 8000ebe <oqWriteTimeout+0x6e>
        nfy(oqp);
 8000eba:	4620      	mov	r0, r4
 8000ebc:	47b8      	blx	r7
 8000ebe:	f38a 8811 	msr	BASEPRI, sl
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      n  -= done;
 8000ec2:	ebab 0b05 	sub.w	fp, fp, r5
      bp += done;
 8000ec6:	442e      	add	r6, r5
 8000ec8:	f389 8811 	msr	BASEPRI, r9
  while (n > 0U) {
 8000ecc:	f1bb 0f00 	cmp.w	fp, #0
 8000ed0:	d1cf      	bne.n	8000e72 <oqWriteTimeout+0x22>
 8000ed2:	2300      	movs	r3, #0
  if (n > oqGetEmptyI(oqp)) {
 8000ed4:	9803      	ldr	r0, [sp, #12]
 8000ed6:	f383 8811 	msr	BASEPRI, r3
    }
  }

  osalSysUnlock();
  return max - n;
}
 8000eda:	b005      	add	sp, #20
 8000edc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8000ee0:	462a      	mov	r2, r5
 8000ee2:	4631      	mov	r1, r6
 8000ee4:	f7ff f9e8 	bl	80002b8 <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
 8000ee8:	68e2      	ldr	r2, [r4, #12]
 8000eea:	6162      	str	r2, [r4, #20]
  oqp->q_counter -= n;
 8000eec:	68a2      	ldr	r2, [r4, #8]
 8000eee:	1b52      	subs	r2, r2, r5
 8000ef0:	60a2      	str	r2, [r4, #8]
    if (done == (size_t)0) {
 8000ef2:	2d00      	cmp	r5, #0
 8000ef4:	d1e0      	bne.n	8000eb8 <oqWriteTimeout+0x68>
 8000ef6:	4620      	mov	r0, r4
 8000ef8:	9902      	ldr	r1, [sp, #8]
 8000efa:	f7ff ff11 	bl	8000d20 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
 8000efe:	2800      	cmp	r0, #0
 8000f00:	d0b7      	beq.n	8000e72 <oqWriteTimeout+0x22>
 8000f02:	9b03      	ldr	r3, [sp, #12]
 8000f04:	eba3 000b 	sub.w	r0, r3, fp
 8000f08:	2300      	movs	r3, #0
 8000f0a:	f383 8811 	msr	BASEPRI, r3
}
 8000f0e:	b005      	add	sp, #20
 8000f10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8000f14:	462a      	mov	r2, r5
 8000f16:	4631      	mov	r1, r6
 8000f18:	f7ff f9ce 	bl	80002b8 <memcpy>
    oqp->q_wrptr += n;
 8000f1c:	6962      	ldr	r2, [r4, #20]
 8000f1e:	442a      	add	r2, r5
 8000f20:	6162      	str	r2, [r4, #20]
 8000f22:	e7e3      	b.n	8000eec <oqWriteTimeout+0x9c>
	...

08000f30 <_writet>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8000f30:	3030      	adds	r0, #48	; 0x30
 8000f32:	f7ff bf8d 	b.w	8000e50 <oqWriteTimeout>
 8000f36:	bf00      	nop
	...

08000f40 <_write>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8000f40:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8000f44:	3030      	adds	r0, #48	; 0x30
 8000f46:	f7ff bf83 	b.w	8000e50 <oqWriteTimeout>
 8000f4a:	bf00      	nop
 8000f4c:	0000      	movs	r0, r0
	...

08000f50 <iqReadTimeout>:
                     size_t n, sysinterval_t timeout) {
 8000f50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000f54:	b085      	sub	sp, #20
 8000f56:	f04f 0920 	mov.w	r9, #32
 8000f5a:	e9cd 3202 	strd	r3, r2, [sp, #8]
  qnotify_t nfy = iqp->q_notify;
 8000f5e:	69c7      	ldr	r7, [r0, #28]
 8000f60:	f389 8811 	msr	BASEPRI, r9
  while (n > 0U) {
 8000f64:	2a00      	cmp	r2, #0
 8000f66:	d035      	beq.n	8000fd4 <iqReadTimeout+0x84>
 8000f68:	4604      	mov	r4, r0
 8000f6a:	460e      	mov	r6, r1
 8000f6c:	f04f 0a00 	mov.w	sl, #0
 8000f70:	f8dd b00c 	ldr.w	fp, [sp, #12]
  if (n > iqGetFullI(iqp)) {
 8000f74:	68a2      	ldr	r2, [r4, #8]
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8000f76:	69a1      	ldr	r1, [r4, #24]
  if (n > iqGetFullI(iqp)) {
 8000f78:	4593      	cmp	fp, r2
 8000f7a:	bf98      	it	ls
 8000f7c:	465d      	movls	r5, fp
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8000f7e:	6922      	ldr	r2, [r4, #16]
    n = iqGetFullI(iqp);
 8000f80:	bf88      	it	hi
 8000f82:	68a5      	ldrhi	r5, [r4, #8]
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8000f84:	eba2 0801 	sub.w	r8, r2, r1
  if (n < s1) {
 8000f88:	45a8      	cmp	r8, r5
 8000f8a:	d844      	bhi.n	8001016 <iqReadTimeout+0xc6>
  else if (n > s1) {
 8000f8c:	d229      	bcs.n	8000fe2 <iqReadTimeout+0x92>
    s2 = n - s1;
 8000f8e:	eba5 0308 	sub.w	r3, r5, r8
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 8000f92:	4642      	mov	r2, r8
 8000f94:	4630      	mov	r0, r6
    s2 = n - s1;
 8000f96:	9301      	str	r3, [sp, #4]
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 8000f98:	f7ff f98e 	bl	80002b8 <memcpy>
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
 8000f9c:	eb06 0008 	add.w	r0, r6, r8
 8000fa0:	f8dd 8004 	ldr.w	r8, [sp, #4]
 8000fa4:	68e1      	ldr	r1, [r4, #12]
 8000fa6:	4642      	mov	r2, r8
 8000fa8:	f7ff f986 	bl	80002b8 <memcpy>
    iqp->q_rdptr = iqp->q_buffer + s2;
 8000fac:	4643      	mov	r3, r8
  iqp->q_counter -= n;
 8000fae:	68a2      	ldr	r2, [r4, #8]
    iqp->q_rdptr = iqp->q_buffer + s2;
 8000fb0:	68e1      	ldr	r1, [r4, #12]
  iqp->q_counter -= n;
 8000fb2:	1b52      	subs	r2, r2, r5
    iqp->q_rdptr = iqp->q_buffer + s2;
 8000fb4:	18cb      	adds	r3, r1, r3
 8000fb6:	61a3      	str	r3, [r4, #24]
  iqp->q_counter -= n;
 8000fb8:	60a2      	str	r2, [r4, #8]
      if (nfy != NULL) {
 8000fba:	b10f      	cbz	r7, 8000fc0 <iqReadTimeout+0x70>
        nfy(iqp);
 8000fbc:	4620      	mov	r0, r4
 8000fbe:	47b8      	blx	r7
 8000fc0:	f38a 8811 	msr	BASEPRI, sl
      n  -= done;
 8000fc4:	ebab 0b05 	sub.w	fp, fp, r5
      bp += done;
 8000fc8:	442e      	add	r6, r5
 8000fca:	f389 8811 	msr	BASEPRI, r9
  while (n > 0U) {
 8000fce:	f1bb 0f00 	cmp.w	fp, #0
 8000fd2:	d1cf      	bne.n	8000f74 <iqReadTimeout+0x24>
 8000fd4:	2300      	movs	r3, #0
  if (n > iqGetFullI(iqp)) {
 8000fd6:	9803      	ldr	r0, [sp, #12]
 8000fd8:	f383 8811 	msr	BASEPRI, r3
}
 8000fdc:	b005      	add	sp, #20
 8000fde:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8000fe2:	462a      	mov	r2, r5
 8000fe4:	4630      	mov	r0, r6
 8000fe6:	f7ff f967 	bl	80002b8 <memcpy>
    iqp->q_rdptr = iqp->q_buffer;
 8000fea:	68e2      	ldr	r2, [r4, #12]
 8000fec:	61a2      	str	r2, [r4, #24]
  iqp->q_counter -= n;
 8000fee:	68a2      	ldr	r2, [r4, #8]
 8000ff0:	1b52      	subs	r2, r2, r5
 8000ff2:	60a2      	str	r2, [r4, #8]
    if (done == (size_t)0) {
 8000ff4:	2d00      	cmp	r5, #0
 8000ff6:	d1e0      	bne.n	8000fba <iqReadTimeout+0x6a>
 8000ff8:	4620      	mov	r0, r4
 8000ffa:	9902      	ldr	r1, [sp, #8]
 8000ffc:	f7ff fe90 	bl	8000d20 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
 8001000:	2800      	cmp	r0, #0
 8001002:	d0b7      	beq.n	8000f74 <iqReadTimeout+0x24>
 8001004:	9b03      	ldr	r3, [sp, #12]
 8001006:	eba3 000b 	sub.w	r0, r3, fp
 800100a:	2300      	movs	r3, #0
 800100c:	f383 8811 	msr	BASEPRI, r3
}
 8001010:	b005      	add	sp, #20
 8001012:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8001016:	462a      	mov	r2, r5
 8001018:	4630      	mov	r0, r6
 800101a:	f7ff f94d 	bl	80002b8 <memcpy>
    iqp->q_rdptr += n;
 800101e:	69a2      	ldr	r2, [r4, #24]
 8001020:	442a      	add	r2, r5
 8001022:	61a2      	str	r2, [r4, #24]
 8001024:	e7e3      	b.n	8000fee <iqReadTimeout+0x9e>
 8001026:	bf00      	nop
	...

08001030 <_readt>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8001030:	300c      	adds	r0, #12
 8001032:	f7ff bf8d 	b.w	8000f50 <iqReadTimeout>
 8001036:	bf00      	nop
	...

08001040 <_read>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8001040:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8001044:	300c      	adds	r0, #12
 8001046:	f7ff bf83 	b.w	8000f50 <iqReadTimeout>
 800104a:	bf00      	nop
 800104c:	0000      	movs	r0, r0
	...

08001050 <main>:
void nvicInit(void) {
#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC) ||   \
    defined(__CORE_CM23_H_GENERIC)
  uint32_t n = 0U;
#else
  uint32_t n = SCnSCB->ICTR;
 8001050:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
#endif

  for (uint32_t i = 0U; i <= n; i++) {
 8001054:	2200      	movs	r2, #0
    NVIC->__ICER[i] = 0xFFFFFFFFU;
 8001056:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff

/*
* Application entry point.
*/

int main(void) {
 800105a:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
  uint32_t n = SCnSCB->ICTR;
 800105e:	685c      	ldr	r4, [r3, #4]
 8001060:	b089      	sub	sp, #36	; 0x24
    NVIC->__ICER[i] = 0xFFFFFFFFU;
 8001062:	0093      	lsls	r3, r2, #2
 8001064:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 8001068:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
  for (uint32_t i = 0U; i <= n; i++) {
 800106c:	4294      	cmp	r4, r2
    NVIC->__ICER[i] = 0xFFFFFFFFU;
 800106e:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80
  for (uint32_t i = 0U; i <= n; i++) {
 8001072:	f102 0201 	add.w	r2, r2, #1
    NVIC->__ICPR[i] = 0xFFFFFFFFU;
 8001076:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180
  for (uint32_t i = 0U; i <= n; i++) {
 800107a:	d1f2      	bne.n	8001062 <main+0x12>
  iqp->q_counter = 0;
 800107c:	2200      	movs	r2, #0
  oqp->q_counter = size;
 800107e:	f44f 7080 	mov.w	r0, #256	; 0x100
#if !defined(SERIAL_ADVANCED_BUFFERING_SUPPORT) ||                          \
    (SERIAL_ADVANCED_BUFFERING_SUPPORT == FALSE) ||                         \
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 8001082:	4cc7      	ldr	r4, [pc, #796]	; (80013a0 <main+0x350>)
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8001084:	f04f 0c01 	mov.w	ip, #1
  sdp->vmt = &vmt;
 8001088:	46a1      	mov	r9, r4
    \retval     none
*/
void timer_init(uint32_t timer_periph, timer_parameter_struct* initpara)
{
    /* configure the counter prescaler value */
    TIMER_PSC(timer_periph) = (uint16_t)initpara->prescaler;
 800108a:	f244 6a4f 	movw	sl, #17999	; 0x464f

    /* configure the counter direction and aligned mode */
    if((TIMER0 == timer_periph) || (TIMER1 == timer_periph) || (TIMER2 == timer_periph)
        || (TIMER3 == timer_periph) || (TIMER4 == timer_periph) || (TIMER7 == timer_periph)){
        TIMER_CTL0(timer_periph) &= (~(uint32_t)(TIMER_CTL0_DIR | TIMER_CTL0_CAM));
 800108e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    \param[out] none
    \retval     none
*/
void rcu_periph_clock_enable(rcu_periph_enum periph)
{
    RCU_REG_VAL(periph) |= BIT(RCU_BIT_POS(periph));
 8001092:	4dc4      	ldr	r5, [pc, #784]	; (80013a4 <main+0x354>)
  iqp->q_counter = 0;
 8001094:	6162      	str	r2, [r4, #20]
  oqp->q_counter = size;
 8001096:	63a0      	str	r0, [r4, #56]	; 0x38
 8001098:	6828      	ldr	r0, [r5, #0]
 800109a:	4ec3      	ldr	r6, [pc, #780]	; (80013a8 <main+0x358>)
 800109c:	ea40 000c 	orr.w	r0, r0, ip
 80010a0:	f849 6b04 	str.w	r6, [r9], #4
  iqp->q_notify  = infy;
 80010a4:	62a2      	str	r2, [r4, #40]	; 0x28
 80010a6:	6028      	str	r0, [r5, #0]
 80010a8:	48c0      	ldr	r0, [pc, #768]	; (80013ac <main+0x35c>)
  oqp->q_top     = bp + size;
 80010aa:	f504 7b15 	add.w	fp, r4, #596	; 0x254
 80010ae:	6805      	ldr	r5, [r0, #0]
  iqp->q_link    = link;
 80010b0:	62e4      	str	r4, [r4, #44]	; 0x2c
 80010b2:	ea45 050c 	orr.w	r5, r5, ip
 80010b6:	6005      	str	r5, [r0, #0]
    \param[out] none
    \retval     none
*/
void rcu_periph_reset_disable(rcu_periph_reset_enum periph_reset)
{
    RCU_REG_VAL(periph_reset) &= ~BIT(RCU_BIT_POS(periph_reset));
 80010b8:	6805      	ldr	r5, [r0, #0]
  oqp->q_link    = link;
 80010ba:	6524      	str	r4, [r4, #80]	; 0x50
 80010bc:	f025 0501 	bic.w	r5, r5, #1
 80010c0:	6005      	str	r5, [r0, #0]
    TIMER_PSC(timer_periph) = (uint16_t)initpara->prescaler;
 80010c2:	48bb      	ldr	r0, [pc, #748]	; (80013b0 <main+0x360>)
  oqp->q_top     = bp + size;
 80010c4:	f8c4 b040 	str.w	fp, [r4, #64]	; 0x40
 80010c8:	f8c0 a000 	str.w	sl, [r0]
        TIMER_CTL0(timer_periph) &= (~(uint32_t)(TIMER_CTL0_DIR | TIMER_CTL0_CAM));
 80010cc:	6818      	ldr	r0, [r3, #0]
  NVIC->__IPR[_IP_IDX(n)] = (NVIC->__IPR[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                            (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80010ce:	f04f 5e80 	mov.w	lr, #268435456	; 0x10000000
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 80010d2:	f04f 0840 	mov.w	r8, #64	; 0x40
  oqp->q_notify  = onfy;
 80010d6:	f8df a340 	ldr.w	sl, [pc, #832]	; 8001418 <main+0x3c8>
  tmp->cumulative = (rttime_t)0;
 80010da:	2600      	movs	r6, #0
 80010dc:	f020 0070 	bic.w	r0, r0, #112	; 0x70
 80010e0:	2700      	movs	r7, #0
  esp->next = (event_listener_t *)esp;
 80010e2:	f8c4 9004 	str.w	r9, [r4, #4]
 80010e6:	f8c4 a04c 	str.w	sl, [r4, #76]	; 0x4c
 80010ea:	2504      	movs	r5, #4
 80010ec:	6018      	str	r0, [r3, #0]
  sdObjectInit(&SD1, NULL, notify1);
#endif

#if STM32_SERIAL_USE_USART3
  sdObjectInit(&SD3, NULL, notify3);
  SD3.uart_basic = UART3;
 80010ee:	48b1      	ldr	r0, [pc, #708]	; (80013b4 <main+0x364>)
        TIMER_CTL0(timer_periph) |= (uint32_t)(initpara->alignedmode & ALIGNEDMODE_MASK);
 80010f0:	f8d3 9000 	ldr.w	r9, [r3]
 80010f4:	f8c4 0254 	str.w	r0, [r4, #596]	; 0x254
  qp->next = qp;
 80010f8:	f104 000c 	add.w	r0, r4, #12
  qp->prev = qp;
 80010fc:	e9c4 0003 	strd	r0, r0, [r4, #12]
  iqp->q_buffer  = bp;
 8001100:	f104 0054 	add.w	r0, r4, #84	; 0x54
  iqp->q_wrptr   = bp;
 8001104:	e9c4 0008 	strd	r0, r0, [r4, #32]
  iqp->q_buffer  = bp;
 8001108:	61a0      	str	r0, [r4, #24]
  iqp->q_top     = bp + size;
 800110a:	f504 70aa 	add.w	r0, r4, #340	; 0x154
  oqp->q_wrptr   = bp;
 800110e:	e9c4 0011 	strd	r0, r0, [r4, #68]	; 0x44
  iqp->q_top     = bp + size;
 8001112:	61e0      	str	r0, [r4, #28]
  oqp->q_buffer  = bp;
 8001114:	63e0      	str	r0, [r4, #60]	; 0x3c
  qp->next = qp;
 8001116:	f104 0030 	add.w	r0, r4, #48	; 0x30
  qp->prev = qp;
 800111a:	e9c4 000c 	strd	r0, r0, [r4, #48]	; 0x30
  sdp->state = SD_STOP;
 800111e:	f884 c008 	strb.w	ip, [r4, #8]
        TIMER_CTL0(timer_periph) |= (uint32_t)(initpara->counterdirection & COUNTERDIRECTION_MASK);            
    }
    
    /* configure the autoreload value */
    TIMER_CAR(timer_periph) = (uint32_t)initpara->period;
 8001122:	48a5      	ldr	r0, [pc, #660]	; (80013b8 <main+0x368>)
        TIMER_CTL0(timer_periph) |= (uint32_t)(initpara->alignedmode & ALIGNEDMODE_MASK);
 8001124:	f8c3 9000 	str.w	r9, [r3]
        TIMER_CTL0(timer_periph) |= (uint32_t)(initpara->counterdirection & COUNTERDIRECTION_MASK);            
 8001128:	f8d3 9000 	ldr.w	r9, [r3]
 800112c:	f8c3 9000 	str.w	r9, [r3]
    TIMER_CAR(timer_periph) = (uint32_t)initpara->period;
 8001130:	6001      	str	r1, [r0, #0]

    if((TIMER5 != timer_periph) && (TIMER6 != timer_periph)){
        /* reset the CKDIV bit */
        TIMER_CTL0(timer_periph) &= (~(uint32_t)TIMER_CTL0_CKDIV);
 8001132:	6818      	ldr	r0, [r3, #0]
        /* configure the repetition counter value */
        TIMER_CREP(timer_periph) = (uint32_t)initpara->repetitioncounter;
    }

    /* generate an update event */
    TIMER_SWEVG(timer_periph) |= (uint32_t)TIMER_SWEVG_UPG;
 8001134:	f8df 92e4 	ldr.w	r9, [pc, #740]	; 800141c <main+0x3cc>
        TIMER_CTL0(timer_periph) &= (~(uint32_t)TIMER_CTL0_CKDIV);
 8001138:	f420 7040 	bic.w	r0, r0, #768	; 0x300
 800113c:	6018      	str	r0, [r3, #0]
        TIMER_CTL0(timer_periph) |= (uint32_t)(initpara->clockdivision & CLOCKDIVISION_MASK);
 800113e:	6818      	ldr	r0, [r3, #0]
 8001140:	6018      	str	r0, [r3, #0]
    TIMER_SWEVG(timer_periph) |= (uint32_t)TIMER_SWEVG_UPG;
 8001142:	f8d9 0000 	ldr.w	r0, [r9]
 8001146:	ea40 000c 	orr.w	r0, r0, ip
 800114a:	f8c9 0000 	str.w	r0, [r9]
    \param[out] none
    \retval     none
*/
void timer_auto_reload_shadow_enable(uint32_t timer_periph)
{
    TIMER_CTL0(timer_periph) |= (uint32_t)TIMER_CTL0_ARSE;
 800114e:	6818      	ldr	r0, [r3, #0]
 */
void chSysInit(void) {
  unsigned i;

  /* System object initialization.*/
  ch_system.state = ch_sys_initializing;
 8001150:	f8df 92cc 	ldr.w	r9, [pc, #716]	; 8001420 <main+0x3d0>
 8001154:	f040 0080 	orr.w	r0, r0, #128	; 0x80
 8001158:	6018      	str	r0, [r3, #0]
    TIMER_CTL0(timer_periph) |= (uint32_t)TIMER_CTL0_CEN;
 800115a:	6818      	ldr	r0, [r3, #0]
 800115c:	ea40 000c 	orr.w	r0, r0, ip
 8001160:	6018      	str	r0, [r3, #0]
 8001162:	4b96      	ldr	r3, [pc, #600]	; (80013bc <main+0x36c>)
 8001164:	f883 831c 	strb.w	r8, [r3, #796]	; 0x31c
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001168:	f8c3 e180 	str.w	lr, [r3, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 800116c:	f8c3 e000 	str.w	lr, [r3]
  tmp->last       = (rtcnt_t)0;
 8001170:	e9cd 2203 	strd	r2, r2, [sp, #12]
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  tcp->offset = (rtcnt_t)0;
 8001174:	e9c9 2201 	strd	r2, r2, [r9, #4]
  tmp->cumulative = (rttime_t)0;
 8001178:	e9cd 6706 	strd	r6, r7, [sp, #24]
  tmp->n          = (ucnt_t)0;
 800117c:	9205      	str	r2, [sp, #20]
  tmp->best       = (rtcnt_t)-1;
 800117e:	9102      	str	r1, [sp, #8]
 8001180:	f889 c000 	strb.w	ip, [r9]
  tmp->cumulative = (rttime_t)0;
 8001184:	ae02      	add	r6, sp, #8
  chTMObjectInit(&tm);
  i = TM_CALIBRATION_LOOP;
  do {
    chTMStartMeasurementX(&tm);
 8001186:	4630      	mov	r0, r6
 8001188:	f7ff f9e2 	bl	8000550 <chTMStartMeasurementX>
    chTMStopMeasurementX(&tm);
 800118c:	f7ff f9b8 	bl	8000500 <chTMStopMeasurementX>
    i--;
  } while (i > 0U);
 8001190:	3d01      	subs	r5, #1
 8001192:	d1f8      	bne.n	8001186 <main+0x136>
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
  mp->object_size = size;
 8001194:	f04f 0e14 	mov.w	lr, #20
 8001198:	f04f 0c1c 	mov.w	ip, #28
  mp->align = align;
 800119c:	2704      	movs	r7, #4
  ch_memcore.basemem = __heap_base__;
 800119e:	4988      	ldr	r1, [pc, #544]	; (80013c0 <main+0x370>)
  ch_memcore.topmem  = __heap_end__;
 80011a0:	f8df 8280 	ldr.w	r8, [pc, #640]	; 8001424 <main+0x3d4>
 *
 * @notapi
 */
void __heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
 80011a4:	4b87      	ldr	r3, [pc, #540]	; (80013c4 <main+0x374>)
 */
void chCoreGetStatusX(memory_area_t *map) {

  map->base = ch_memcore.basemem;
  /*lint -save -e9033 [10.8] The cast is safe.*/
  map->size = (size_t)(ch_memcore.topmem - ch_memcore.basemem);
 80011a6:	eba8 0001 	sub.w	r0, r8, r1
 80011aa:	6098      	str	r0, [r3, #8]
  ch_memcore.basemem = __heap_base__;
 80011ac:	4886      	ldr	r0, [pc, #536]	; (80013c8 <main+0x378>)
  qp->next = qp;
 80011ae:	4a87      	ldr	r2, [pc, #540]	; (80013cc <main+0x37c>)
  ch_memcore.topmem  = __heap_end__;
 80011b0:	e9c0 1800 	strd	r1, r8, [r0]
  map->base = ch_memcore.basemem;
 80011b4:	6059      	str	r1, [r3, #4]
 80011b6:	4986      	ldr	r1, [pc, #536]	; (80013d0 <main+0x380>)
  mp->object_size = size;
 80011b8:	f8c2 c030 	str.w	ip, [r2, #48]	; 0x30
 80011bc:	6019      	str	r1, [r3, #0]
  } while ((c != (char)0) && (i > 0U));
}

static inline void dyn_list_init(dyn_list_t *dlp) {

  dlp->next = (dyn_element_t *)dlp;
 80011be:	f102 0c3c 	add.w	ip, r2, #60	; 0x3c
 80011c2:	eb03 010e 	add.w	r1, r3, lr
  qp->prev = qp;
 80011c6:	e9c3 1105 	strd	r1, r1, [r3, #20]
  mp->provider = provider;
 80011ca:	4882      	ldr	r0, [pc, #520]	; (80013d4 <main+0x384>)
 80011cc:	f102 0124 	add.w	r1, r2, #36	; 0x24
 80011d0:	f8c2 c03c 	str.w	ip, [r2, #60]	; 0x3c
 80011d4:	f102 0c40 	add.w	ip, r2, #64	; 0x40
 80011d8:	6251      	str	r1, [r2, #36]	; 0x24
 80011da:	f8c2 c040 	str.w	ip, [r2, #64]	; 0x40
 80011de:	f102 0128 	add.w	r1, r2, #40	; 0x28
 80011e2:	f102 0c44 	add.w	ip, r2, #68	; 0x44
  chCoreGetStatusX(&default_heap.area);
  H_FREE_NEXT(&default_heap.header) = NULL;
  H_FREE_PAGES(&default_heap.header) = 0;
 80011e6:	e9c3 5503 	strd	r5, r5, [r3, #12]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  ch_queue_init(&mp->queue);
  mp->owner = NULL;
 80011ea:	61dd      	str	r5, [r3, #28]
 80011ec:	f102 0310 	add.w	r3, r2, #16
 80011f0:	6113      	str	r3, [r2, #16]
 80011f2:	6291      	str	r1, [r2, #40]	; 0x28
  core_id = port_get_core_id();
#else
  core_id = 0U;
#endif
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
  ch_system.instances[core_id] = oip;
 80011f4:	4b78      	ldr	r3, [pc, #480]	; (80013d8 <main+0x388>)
 80011f6:	e9c2 2200 	strd	r2, r2, [r2]

  /* Core associated to this instance.*/
  oip->core_id = core_id;

  /* Keeping a reference to the configuration data.*/
  oip->config = oicp;
 80011fa:	4978      	ldr	r1, [pc, #480]	; (80013dc <main+0x38c>)
 80011fc:	6095      	str	r5, [r2, #8]
  mp->next = NULL;
 80011fe:	6155      	str	r5, [r2, #20]
 8001200:	62d5      	str	r5, [r2, #44]	; 0x2c
  mp->object_size = size;
 8001202:	f8c2 e018 	str.w	lr, [r2, #24]
 8001206:	f8c2 c044 	str.w	ip, [r2, #68]	; 0x44
  mp->align = align;
 800120a:	61d7      	str	r7, [r2, #28]
 800120c:	6357      	str	r7, [r2, #52]	; 0x34
  mp->provider = provider;
 800120e:	6210      	str	r0, [r2, #32]
 8001210:	6390      	str	r0, [r2, #56]	; 0x38
  tcp->offset = tm.best;
 8001212:	9a02      	ldr	r2, [sp, #8]
  oip->core_id = core_id;
 8001214:	631d      	str	r5, [r3, #48]	; 0x30
  ch_system.instances[core_id] = oip;
 8001216:	e9c9 3201 	strd	r3, r2, [r9, #4]
  oip->config = oicp;
 800121a:	6399      	str	r1, [r3, #56]	; 0x38
 800121c:	f385 8811 	msr	BASEPRI, r5
  __ASM volatile ("cpsie i" : : : "memory");
 8001220:	b662      	cpsie	i
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001222:	f64f 0cff 	movw	ip, #63743	; 0xf8ff
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001226:	2010      	movs	r0, #16
 8001228:	f04f 0820 	mov.w	r8, #32
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800122c:	4a6c      	ldr	r2, [pc, #432]	; (80013e0 <main+0x390>)
  pqp->prev = pqp;
 800122e:	605b      	str	r3, [r3, #4]
 8001230:	68d1      	ldr	r1, [r2, #12]
  pqp->prio = (tprio_t)0;
 8001232:	609d      	str	r5, [r3, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001234:	ea01 0c0c 	and.w	ip, r1, ip
  reg_value  =  (reg_value                                   |
 8001238:	496a      	ldr	r1, [pc, #424]	; (80013e4 <main+0x394>)
 *
 * @notapi
 */
static inline void __rfcu_object_init(rfcu_t *rfcup) {

  rfcup->mask = (rfcu_mask_t)0;
 800123a:	635d      	str	r5, [r3, #52]	; 0x34
 800123c:	ea4c 0101 	orr.w	r1, ip, r1
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8001240:	f8df c1e4 	ldr.w	ip, [pc, #484]	; 8001428 <main+0x3d8>
  SCB->AIRCR =  reg_value;
 8001244:	60d1      	str	r1, [r2, #12]
 8001246:	f8dc 100c 	ldr.w	r1, [ip, #12]

  ch_dlist_init(&vtlp->dlist);
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  vtlp->lasttime = (systime_t)0;
 800124a:	61dd      	str	r5, [r3, #28]
 800124c:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
 8001250:	f8cc 100c 	str.w	r1, [ip, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8001254:	f8df c1b4 	ldr.w	ip, [pc, #436]	; 800140c <main+0x3bc>
  tp->owner             = oip;
 8001258:	655b      	str	r3, [r3, #84]	; 0x54
 800125a:	f8dc 1000 	ldr.w	r1, [ip]
  tp->mtxlist           = NULL;
 800125e:	67dd      	str	r5, [r3, #124]	; 0x7c
 8001260:	f041 0101 	orr.w	r1, r1, #1
 8001264:	f8cc 1000 	str.w	r1, [ip]
  return (systime_t)TIMER_CNT(TIMER1);
 8001268:	495f      	ldr	r1, [pc, #380]	; (80013e8 <main+0x398>)
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800126a:	77d0      	strb	r0, [r2, #31]
 800126c:	f882 8022 	strb.w	r8, [r2, #34]	; 0x22
 8001270:	6808      	ldr	r0, [r1, #0]
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
#if CH_CFG_USE_TIMESTAMP == TRUE
  vtlp->laststamp = (systimestamp_t)chVTGetSystemTimeX();
 8001272:	2100      	movs	r1, #0
  dlhp->delta = (sysinterval_t)-1;
 8001274:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  tp->hdr.pqueue.prio   = prio;
 8001278:	f04f 0e80 	mov.w	lr, #128	; 0x80
  oip->rlist.current->wabase = oicp->mainthread_base;
  oip->rlist.current->waend  = oicp->mainthread_end;
#endif

  /* Setting up the caller as current thread.*/
  oip->rlist.current->state = CH_STATE_CURRENT;
 800127c:	f04f 0c01 	mov.w	ip, #1
  tp->state             = CH_STATE_WTSTART;
 8001280:	f04f 0a02 	mov.w	sl, #2
 8001284:	e9c3 0108 	strd	r0, r1, [r3, #32]
  tp->name              = name;
 8001288:	4958      	ldr	r1, [pc, #352]	; (80013ec <main+0x39c>)
 800128a:	619a      	str	r2, [r3, #24]
 800128c:	6599      	str	r1, [r3, #88]	; 0x58
  oip->rlist.current->wabase = oicp->mainthread_base;
 800128e:	4a58      	ldr	r2, [pc, #352]	; (80013f0 <main+0x3a0>)
  lp->next = lp;
 8001290:	f103 016c 	add.w	r1, r3, #108	; 0x6c
 8001294:	66d9      	str	r1, [r3, #108]	; 0x6c
  tp->hdr.pqueue.prio   = prio;
 8001296:	f8c3 e044 	str.w	lr, [r3, #68]	; 0x44
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
 800129a:	f103 013c 	add.w	r1, r3, #60	; 0x3c
  tp->realprio          = prio;
 800129e:	f8c3 e080 	str.w	lr, [r3, #128]	; 0x80
  qp->next = qp;
 80012a2:	f103 0e70 	add.w	lr, r3, #112	; 0x70
  qp->prev = qp;
 80012a6:	e9c3 ee1c 	strd	lr, lr, [r3, #112]	; 0x70
 80012aa:	60d9      	str	r1, [r3, #12]
  oip->rlist.current->waend  = oicp->mainthread_end;
 80012ac:	f8df e17c 	ldr.w	lr, [pc, #380]	; 800142c <main+0x3dc>
  dlhp->next  = dlhp;
 80012b0:	f103 0110 	add.w	r1, r3, #16
  oip->rlist.current->wabase = oicp->mainthread_base;
 80012b4:	65da      	str	r2, [r3, #92]	; 0x5c
  tp->wabase = tdp->wbase;
 80012b6:	4a4f      	ldr	r2, [pc, #316]	; (80013f4 <main+0x3a4>)
  p->prev       = qp->prev;
 80012b8:	f103 0028 	add.w	r0, r3, #40	; 0x28
  dlhp->prev  = dlhp;
 80012bc:	e9c3 1104 	strd	r1, r1, [r3, #16]
  p->prev->next = p;
 80012c0:	f103 014c 	add.w	r1, r3, #76	; 0x4c
  tp->epending          = (eventmask_t)0;
 80012c4:	679d      	str	r5, [r3, #120]	; 0x78
 *
 * @notapi
 */
static inline void __dbg_object_init(system_debug_t *sdp) {

  sdp->panic_msg = NULL;
 80012c6:	f8c3 5088 	str.w	r5, [r3, #136]	; 0x88
  p->prev       = qp->prev;
 80012ca:	6518      	str	r0, [r3, #80]	; 0x50
  p->prev->next = p;
 80012cc:	6299      	str	r1, [r3, #40]	; 0x28
  pqp->next = pqp;
 80012ce:	601b      	str	r3, [r3, #0]
  oip->rlist.current->waend  = oicp->mainthread_end;
 80012d0:	f8c3 e060 	str.w	lr, [r3, #96]	; 0x60
  p->prev       = qp->prev;
 80012d4:	e9c2 0124 	strd	r0, r1, [r2, #144]	; 0x90
  tp->waend  = tdp->wend;
 80012d8:	f102 01e0 	add.w	r1, r2, #224	; 0xe0
 80012dc:	e9c2 2128 	strd	r2, r1, [r2, #160]	; 0xa0
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 80012e0:	f102 015c 	add.w	r1, r2, #92	; 0x5c
 80012e4:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c
 80012e8:	4943      	ldr	r1, [pc, #268]	; (80013f8 <main+0x3a8>)
 80012ea:	4844      	ldr	r0, [pc, #272]	; (80013fc <main+0x3ac>)
 80012ec:	67d1      	str	r1, [r2, #124]	; 0x7c
  tp->name              = name;
 80012ee:	4944      	ldr	r1, [pc, #272]	; (8001400 <main+0x3b0>)
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 80012f0:	65d0      	str	r0, [r2, #92]	; 0x5c
  tp->name              = name;
 80012f2:	f8c2 109c 	str.w	r1, [r2, #156]	; 0x9c
  lp->next = lp;
 80012f6:	f102 01b0 	add.w	r1, r2, #176	; 0xb0
  p->prev->next = p;
 80012fa:	f102 0090 	add.w	r0, r2, #144	; 0x90
  lp->next = lp;
 80012fe:	f8c2 10b0 	str.w	r1, [r2, #176]	; 0xb0
  qp->next = qp;
 8001302:	f102 01b4 	add.w	r1, r2, #180	; 0xb4
  tp->epending          = (eventmask_t)0;
 8001306:	e9c2 552f 	strd	r5, r5, [r2, #188]	; 0xbc
  qp->prev = qp;
 800130a:	e9c2 112d 	strd	r1, r1, [r2, #180]	; 0xb4
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800130e:	6615      	str	r5, [r2, #96]	; 0x60
  tp->owner             = oip;
 8001310:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
  oip->rlist.current->state = CH_STATE_CURRENT;
 8001314:	f8a3 c064 	strh.w	ip, [r3, #100]	; 0x64
  tp->refs              = (trefs_t)1;
 8001318:	f883 c066 	strb.w	ip, [r3, #102]	; 0x66
  tp->hdr.pqueue.prio   = prio;
 800131c:	f8c2 c088 	str.w	ip, [r2, #136]	; 0x88
  tp->realprio          = prio;
 8001320:	f8c2 c0c4 	str.w	ip, [r2, #196]	; 0xc4
  tp->refs              = (trefs_t)1;
 8001324:	f882 c0aa 	strb.w	ip, [r2, #170]	; 0xaa
  p->prev->next = p;
 8001328:	64d8      	str	r0, [r3, #76]	; 0x4c
  qp->prev      = p;
 800132a:	62d8      	str	r0, [r3, #44]	; 0x2c
  tp->state             = CH_STATE_WTSTART;
 800132c:	f8a2 a0a8 	strh.w	sl, [r2, #168]	; 0xa8
  return chSchReadyI(chThdCreateSuspendedI(tdp));
 8001330:	f102 0080 	add.w	r0, r2, #128	; 0x80
 8001334:	f7ff f994 	bl	8000660 <chSchReadyI>

  /* Initializing default OS instance.*/
  chInstanceObjectInit(&ch0, &ch_core0_cfg);

  /* It is alive now.*/
  ch_system.state = ch_sys_running;
 8001338:	f889 a000 	strb.w	sl, [r9]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800133c:	f385 8811 	msr	BASEPRI, r5
    *   RTOS is active.
    */
    halInit();
    chSysInit();

    palSetLineMode(LINE_UART3_TX, GDPAL_MODE(GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ));
 8001340:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8001344:	2118      	movs	r1, #24
 8001346:	482f      	ldr	r0, [pc, #188]	; (8001404 <main+0x3b4>)
 8001348:	f7ff f832 	bl	80003b0 <gpio_init.constprop.0>
    palSetLineMode(LINE_UART3_RX, GDPAL_MODE(GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ));
 800134c:	4639      	mov	r1, r7
 800134e:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8001352:	482c      	ldr	r0, [pc, #176]	; (8001404 <main+0x3b4>)
 8001354:	f7ff f82c 	bl	80003b0 <gpio_init.constprop.0>
 8001358:	f388 8811 	msr	BASEPRI, r8

  if (config == NULL) {
    config = &default_config;
  }

  if (sdp->state == SD_STOP) {
 800135c:	7a23      	ldrb	r3, [r4, #8]
 800135e:	2b01      	cmp	r3, #1
 8001360:	d067      	beq.n	8001432 <main+0x3e2>
#else
  sd_lld_start(sdp, config);
  msg = HAL_RET_SUCCESS;
#endif
  if (msg == HAL_RET_SUCCESS) {
    sdp->state = SD_READY;
 8001362:	2202      	movs	r2, #2
 8001364:	2300      	movs	r3, #0
 8001366:	7222      	strb	r2, [r4, #8]
 8001368:	f383 8811 	msr	BASEPRI, r3
    sdStart(&SD3, NULL);

    chprintf((void*)&SD3, "hello, chibios\n");  
 800136c:	4926      	ldr	r1, [pc, #152]	; (8001408 <main+0x3b8>)
 800136e:	480c      	ldr	r0, [pc, #48]	; (80013a0 <main+0x350>)
 8001370:	f7ff f9de 	bl	8000730 <chprintf.constprop.0>
 8001374:	4c25      	ldr	r4, [pc, #148]	; (800140c <main+0x3bc>)
        //     chThdSleepMilliseconds(50);   
        // } 



        chprintf((void*)&SD3, "%d\n", (x2 - x1) >> 0); 
 8001376:	4e26      	ldr	r6, [pc, #152]	; (8001410 <main+0x3c0>)
 8001378:	4d09      	ldr	r5, [pc, #36]	; (80013a0 <main+0x350>)
 800137a:	6863      	ldr	r3, [r4, #4]
 800137c:	6862      	ldr	r2, [r4, #4]
 800137e:	4631      	mov	r1, r6
 8001380:	1ad2      	subs	r2, r2, r3
 8001382:	4628      	mov	r0, r5
 8001384:	f7ff f9d4 	bl	8000730 <chprintf.constprop.0>
 8001388:	2320      	movs	r3, #32
 800138a:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(sysinterval_t ticks) {

  chDbgCheck(ticks != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 800138e:	4921      	ldr	r1, [pc, #132]	; (8001414 <main+0x3c4>)
 8001390:	2008      	movs	r0, #8
 8001392:	f7ff fc45 	bl	8000c20 <chSchGoSleepTimeoutS>
 8001396:	2300      	movs	r3, #0
 8001398:	f383 8811 	msr	BASEPRI, r3
 800139c:	e048      	b.n	8001430 <main+0x3e0>
 800139e:	bf00      	nop
 80013a0:	20000800 	.word	0x20000800
 80013a4:	4002101c 	.word	0x4002101c
 80013a8:	08001c94 	.word	0x08001c94
 80013ac:	40021010 	.word	0x40021010
 80013b0:	40000028 	.word	0x40000028
 80013b4:	40004c00 	.word	0x40004c00
 80013b8:	4000002c 	.word	0x4000002c
 80013bc:	e000e100 	.word	0xe000e100
 80013c0:	20000c60 	.word	0x20000c60
 80013c4:	20000c3c 	.word	0x20000c3c
 80013c8:	20000c28 	.word	0x20000c28
 80013cc:	20000be0 	.word	0x20000be0
 80013d0:	08000431 	.word	0x08000431
 80013d4:	080004d1 	.word	0x080004d1
 80013d8:	20000a58 	.word	0x20000a58
 80013dc:	08001bd4 	.word	0x08001bd4
 80013e0:	e000ed00 	.word	0xe000ed00
 80013e4:	05fa0300 	.word	0x05fa0300
 80013e8:	40000024 	.word	0x40000024
 80013ec:	08001be8 	.word	0x08001be8
 80013f0:	20000400 	.word	0x20000400
 80013f4:	20000b00 	.word	0x20000b00
 80013f8:	0800029d 	.word	0x0800029d
 80013fc:	08000421 	.word	0x08000421
 8001400:	08001bb4 	.word	0x08001bb4
 8001404:	40011000 	.word	0x40011000
 8001408:	08001bbc 	.word	0x08001bbc
 800140c:	e0001000 	.word	0xe0001000
 8001410:	08001bcc 	.word	0x08001bcc
 8001414:	0007a120 	.word	0x0007a120
 8001418:	08000471 	.word	0x08000471
 800141c:	40000014 	.word	0x40000014
 8001420:	20000c30 	.word	0x20000c30
 8001424:	20020000 	.word	0x20020000
 8001428:	e000edf0 	.word	0xe000edf0
 800142c:	20000800 	.word	0x20000800
 8001430:	e7a3      	b.n	800137a <main+0x32a>
    RCU_REG_VAL(periph) |= BIT(RCU_BIT_POS(periph));
 8001432:	4866      	ldr	r0, [pc, #408]	; (80015cc <main+0x57c>)
 8001434:	4966      	ldr	r1, [pc, #408]	; (80015d0 <main+0x580>)
 8001436:	6802      	ldr	r2, [r0, #0]
    uint32_t predv0, predv1, pll1mf;
#endif /* GD32E50X_CL and GD32EPRT and GD32E508*/

    /* exponent of AHB, APB1 and APB2 clock divider */
    uint8_t ahb_exp[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
    uint8_t apb1_exp[8] = {0, 0, 0, 0, 1, 2, 3, 4};
 8001438:	466f      	mov	r7, sp
    RCU_REG_VAL(periph) |= BIT(RCU_BIT_POS(periph));
 800143a:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 800143e:	6002      	str	r2, [r0, #0]
 8001440:	6808      	ldr	r0, [r1, #0]
        USART5_CTL0(usart_periph) &= ~USART5_CTL0_WL;
        /* configure USART word length */
        USART5_CTL0(usart_periph) |= (USART5_CTL0_WL & wlen); 
    }else{
        /* clear USART_CTL0 WL bit */
        USART_CTL0(usart_periph) &= ~USART_CTL0_WL;
 8001442:	4b64      	ldr	r3, [pc, #400]	; (80015d4 <main+0x584>)
 8001444:	f440 2000 	orr.w	r0, r0, #524288	; 0x80000
 8001448:	6008      	str	r0, [r1, #0]
    RCU_REG_VAL(periph_reset) &= ~BIT(RCU_BIT_POS(periph_reset));
 800144a:	6808      	ldr	r0, [r1, #0]
        USART5_CTL1(usart_periph) &= ~USART5_CTL1_STB; 
        /* configure USART stop bits */
        USART5_CTL1(usart_periph) |= (USART5_CTL1_STB & stblen);
    }else{
        /* clear USART_CTL1 STB bits */
        USART_CTL1(usart_periph) &= ~USART_CTL1_STB; 
 800144c:	4a62      	ldr	r2, [pc, #392]	; (80015d8 <main+0x588>)
 800144e:	f420 2000 	bic.w	r0, r0, #524288	; 0x80000
 8001452:	6008      	str	r0, [r1, #0]
        USART_CTL0(usart_periph) &= ~USART_CTL0_WL;
 8001454:	6819      	ldr	r1, [r3, #0]
    uint8_t ahb_exp[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
 8001456:	4d61      	ldr	r5, [pc, #388]	; (80015dc <main+0x58c>)
 8001458:	f421 5180 	bic.w	r1, r1, #4096	; 0x1000
 800145c:	6019      	str	r1, [r3, #0]
        USART_CTL0(usart_periph) |= (USART_CTL0_WL & wlen);
 800145e:	6819      	ldr	r1, [r3, #0]
 8001460:	6019      	str	r1, [r3, #0]
        USART_CTL1(usart_periph) &= ~USART_CTL1_STB; 
 8001462:	6811      	ldr	r1, [r2, #0]
 8001464:	f421 5140 	bic.w	r1, r1, #12288	; 0x3000
 8001468:	6011      	str	r1, [r2, #0]
        /* configure USARTx(x=0,1,2)/UARTx(x=3,4) stop bits */
        USART_CTL1(usart_periph) |= (USART_CTL1_STB & stblen);
 800146a:	6811      	ldr	r1, [r2, #0]
 800146c:	6011      	str	r1, [r2, #0]
        USART_CTL0(usart_periph) &= ~(USART_CTL0_PM | USART_CTL0_PCEN);
 800146e:	681a      	ldr	r2, [r3, #0]
 8001470:	f422 62c0 	bic.w	r2, r2, #1536	; 0x600
 8001474:	601a      	str	r2, [r3, #0]
        USART_CTL0(usart_periph) |= ((USART_CTL0_PM | USART_CTL0_PCEN) & paritycfg);
 8001476:	681a      	ldr	r2, [r3, #0]
 8001478:	601a      	str	r2, [r3, #0]
 800147a:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 800147e:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}
    uint8_t apb1_exp[8] = {0, 0, 0, 0, 1, 2, 3, 4};
 8001482:	e9d5 0104 	ldrd	r0, r1, [r5, #16]
 8001486:	e887 0003 	stmia.w	r7, {r0, r1}
    uint8_t apb2_exp[8] = {0, 0, 0, 0, 1, 2, 3, 4};

    sws = GET_BITS(RCU_CFG0, 2, 3);
 800148a:	4a55      	ldr	r2, [pc, #340]	; (80015e0 <main+0x590>)
 800148c:	6813      	ldr	r3, [r2, #0]
 800148e:	f3c3 0381 	ubfx	r3, r3, #2, #2
    switch(sws){
 8001492:	2b01      	cmp	r3, #1
 8001494:	d003      	beq.n	800149e <main+0x44e>
 8001496:	4553      	cmp	r3, sl
 8001498:	d044      	beq.n	8001524 <main+0x4d4>
    /* IRC8M is selected as CK_SYS */
    case SEL_IRC8M:
        cksys_freq = IRC8M_VALUE;
 800149a:	4b52      	ldr	r3, [pc, #328]	; (80015e4 <main+0x594>)
 800149c:	e000      	b.n	80014a0 <main+0x450>
    switch(sws){
 800149e:	4b52      	ldr	r3, [pc, #328]	; (80015e8 <main+0x598>)
        cksys_freq = IRC8M_VALUE;
        break;
    }

    /* calculate AHB clock frequency */
    idx = GET_BITS(RCU_CFG0, 4, 7);
 80014a0:	484f      	ldr	r0, [pc, #316]	; (80015e0 <main+0x590>)
    clk_exp = ahb_exp[idx];
 80014a2:	ad08      	add	r5, sp, #32
    idx = GET_BITS(RCU_CFG0, 4, 7);
 80014a4:	6801      	ldr	r1, [r0, #0]
    ahb_freq = cksys_freq >> clk_exp;
    
    /* calculate APB1 clock frequency */
    idx = GET_BITS(RCU_CFG0, 8, 10);
 80014a6:	6802      	ldr	r2, [r0, #0]
    idx = GET_BITS(RCU_CFG0, 4, 7);
 80014a8:	f3c1 1103 	ubfx	r1, r1, #4, #4
    clk_exp = ahb_exp[idx];
 80014ac:	4429      	add	r1, r5
 80014ae:	f811 5c18 	ldrb.w	r5, [r1, #-24]
        if(USART_CTL0(usart_periph) & USART_CTL0_OVSMOD){
 80014b2:	4e48      	ldr	r6, [pc, #288]	; (80015d4 <main+0x584>)
    clk_exp = apb1_exp[idx];
 80014b4:	a908      	add	r1, sp, #32
    idx = GET_BITS(RCU_CFG0, 8, 10);
 80014b6:	f3c2 2202 	ubfx	r2, r2, #8, #3
    clk_exp = apb1_exp[idx];
 80014ba:	440a      	add	r2, r1
 80014bc:	f812 1c20 	ldrb.w	r1, [r2, #-32]
    apb1_freq = ahb_freq >> clk_exp;
    
    /* calculate APB2 clock frequency */
    idx = GET_BITS(RCU_CFG0, 11, 13);
 80014c0:	6802      	ldr	r2, [r0, #0]
 80014c2:	6832      	ldr	r2, [r6, #0]
    ahb_freq = cksys_freq >> clk_exp;
 80014c4:	40eb      	lsrs	r3, r5
 80014c6:	f412 4f00 	tst.w	r2, #32768	; 0x8000
    apb1_freq = ahb_freq >> clk_exp;
 80014ca:	fa23 f301 	lsr.w	r3, r3, r1
            udiv = ((2U*uclk) + baudval/2U)/baudval;
 80014ce:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
        if(USART_CTL0(usart_periph) & USART_CTL0_OVSMOD){
 80014d2:	d05e      	beq.n	8001592 <main+0x542>
            udiv = ((2U*uclk) + baudval/2U)/baudval;
 80014d4:	005b      	lsls	r3, r3, #1
 80014d6:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 80014da:	fbb3 f3f2 	udiv	r3, r3, r2
            intdiv = udiv & 0x0000fff0U;
 80014de:	f64f 71f0 	movw	r1, #65520	; 0xfff0
            fradiv = (udiv>>1) & 0x00000007U;
 80014e2:	f3c3 0242 	ubfx	r2, r3, #1, #3
            intdiv = udiv & 0x0000fff0U;
 80014e6:	400b      	ands	r3, r1
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80014e8:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 80014ec:	2550      	movs	r5, #80	; 0x50
        USART_BAUD(usart_periph) = ((USART_BAUD_FRADIV | USART_BAUD_INTDIV) & (intdiv | fradiv));
 80014ee:	493f      	ldr	r1, [pc, #252]	; (80015ec <main+0x59c>)
 80014f0:	4313      	orrs	r3, r2
        ctl &= ~USART5_CTL0_REN;
        ctl |= (USART5_CTL0_REN & rxconfig);
        /* configure USART5 receive mode */
        USART5_CTL0(usart_periph) = ctl;
    }else{
        ctl = USART_CTL0(usart_periph);
 80014f2:	4a38      	ldr	r2, [pc, #224]	; (80015d4 <main+0x584>)
        USART_BAUD(usart_periph) = ((USART_BAUD_FRADIV | USART_BAUD_INTDIV) & (intdiv | fradiv));
 80014f4:	600b      	str	r3, [r1, #0]
        ctl = USART_CTL0(usart_periph);
 80014f6:	6811      	ldr	r1, [r2, #0]
 80014f8:	4b3d      	ldr	r3, [pc, #244]	; (80015f0 <main+0x5a0>)
        ctl &= ~USART_CTL0_REN;
        ctl |= (USART_CTL0_REN & rxconfig);
 80014fa:	f041 0104 	orr.w	r1, r1, #4
        /* configure USARTx(x=0,1,2)/UARTx(x=3,4) receive mode */
        USART_CTL0(usart_periph) = ctl;
 80014fe:	6011      	str	r1, [r2, #0]
        ctl = USART_CTL0(usart_periph);
 8001500:	6811      	ldr	r1, [r2, #0]
        ctl |= (USART_CTL0_TEN & txconfig);
 8001502:	f041 0108 	orr.w	r1, r1, #8
        USART_CTL0(usart_periph) = ctl;
 8001506:	6011      	str	r1, [r2, #0]
        USART_CTL0(usart_periph) |= USART_CTL0_UEN;
 8001508:	6811      	ldr	r1, [r2, #0]
 800150a:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
 800150e:	6011      	str	r1, [r2, #0]
 8001510:	f883 5334 	strb.w	r5, [r3, #820]	; 0x334
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001514:	f8c3 0184 	str.w	r0, [r3, #388]	; 0x184
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001518:	6058      	str	r0, [r3, #4]
    \param[out] none
    \retval     none
*/
void usart_interrupt_enable(uint32_t usart_periph, usart_interrupt_enum interrupt)
{
    USART_REG_VAL(usart_periph, interrupt) |= BIT(USART_BIT_POS(interrupt));
 800151a:	6813      	ldr	r3, [r2, #0]
 800151c:	f043 0320 	orr.w	r3, r3, #32
 8001520:	6013      	str	r3, [r2, #0]
 8001522:	e71e      	b.n	8001362 <main+0x312>
        pllsel = (RCU_CFG0 & RCU_CFG0_PLLSEL);
 8001524:	6813      	ldr	r3, [r2, #0]
        if(RCU_PLLSRC_HXTAL_IRC48M == pllsel) {
 8001526:	03df      	lsls	r7, r3, #15
 8001528:	d54a      	bpl.n	80015c0 <main+0x570>
            pllpresel = (RCU_CFG1 & RCU_CFG1_PLLPRESEL);
 800152a:	6a95      	ldr	r5, [r2, #40]	; 0x28
                ck_src = IRC48M_VALUE;
 800152c:	4831      	ldr	r0, [pc, #196]	; (80015f4 <main+0x5a4>)
            predv0sel = (RCU_CFG1 & RCU_CFG1_PREDV0SEL);
 800152e:	6a91      	ldr	r1, [r2, #40]	; 0x28
                ck_src = IRC48M_VALUE;
 8001530:	f015 4f80 	tst.w	r5, #1073741824	; 0x40000000
 8001534:	4b2c      	ldr	r3, [pc, #176]	; (80015e8 <main+0x598>)
 8001536:	bf18      	it	ne
 8001538:	4603      	movne	r3, r0
            if(RCU_PREDV0SRC_CKPLL1 == predv0sel){
 800153a:	03ce      	lsls	r6, r1, #15
            pllpresel = (RCU_CFG1 & RCU_CFG1_PLLPRESEL);
 800153c:	f102 0228 	add.w	r2, r2, #40	; 0x28
            if(RCU_PREDV0SRC_CKPLL1 == predv0sel){
 8001540:	d50f      	bpl.n	8001562 <main+0x512>
                predv1 = ((RCU_CFG1 & RCU_CFG1_PREDV1) >> RCU_CFG1_PREDV1_OFFSET) + 1U;
 8001542:	6811      	ldr	r1, [r2, #0]
                pll1mf = (uint32_t)((RCU_CFG1 & RCU_CFG1_PLL1MF) >> RCU_CFG1_PLL1MF_OFFSET) + 2U;
 8001544:	6812      	ldr	r2, [r2, #0]
                predv1 = ((RCU_CFG1 & RCU_CFG1_PREDV1) >> RCU_CFG1_PREDV1_OFFSET) + 1U;
 8001546:	f3c1 1103 	ubfx	r1, r1, #4, #4
                pll1mf = (uint32_t)((RCU_CFG1 & RCU_CFG1_PLL1MF) >> RCU_CFG1_PLL1MF_OFFSET) + 2U;
 800154a:	f3c2 2203 	ubfx	r2, r2, #8, #4
                    pll1mf = 20U;
 800154e:	2a0f      	cmp	r2, #15
                predv1 = ((RCU_CFG1 & RCU_CFG1_PREDV1) >> RCU_CFG1_PREDV1_OFFSET) + 1U;
 8001550:	f101 0101 	add.w	r1, r1, #1
                pll1mf = (uint32_t)((RCU_CFG1 & RCU_CFG1_PLL1MF) >> RCU_CFG1_PLL1MF_OFFSET) + 2U;
 8001554:	4452      	add	r2, sl
                ck_src = (ck_src/predv1)*pll1mf;
 8001556:	fbb3 f3f1 	udiv	r3, r3, r1
                    pll1mf = 20U;
 800155a:	bf08      	it	eq
 800155c:	2214      	moveq	r2, #20
                ck_src = (ck_src/predv1)*pll1mf;
 800155e:	fb02 f303 	mul.w	r3, r2, r3
            predv0 = (RCU_CFG1 & RCU_CFG1_PREDV0) + 1U;
 8001562:	4a25      	ldr	r2, [pc, #148]	; (80015f8 <main+0x5a8>)
 8001564:	6812      	ldr	r2, [r2, #0]
 8001566:	f002 020f 	and.w	r2, r2, #15
 800156a:	3201      	adds	r2, #1
            ck_src /= predv0;
 800156c:	fbb3 f3f2 	udiv	r3, r3, r2
        pllmf = GET_BITS(RCU_CFG0, 18, 21);
 8001570:	491b      	ldr	r1, [pc, #108]	; (80015e0 <main+0x590>)
 8001572:	680a      	ldr	r2, [r1, #0]
        if((RCU_CFG0 & RCU_CFG0_PLLMF_4)){
 8001574:	6808      	ldr	r0, [r1, #0]
        pllmf = GET_BITS(RCU_CFG0, 18, 21);
 8001576:	f3c2 4283 	ubfx	r2, r2, #18, #4
        if((RCU_CFG0 & RCU_CFG0_PLLMF_4)){
 800157a:	0085      	lsls	r5, r0, #2
        if((RCU_CFG0 & RCU_CFG0_PLLMF_5)){
 800157c:	6809      	ldr	r1, [r1, #0]
        if((RCU_CFG0 & RCU_CFG0_PLLMF_4)){
 800157e:	d512      	bpl.n	80015a6 <main+0x556>
        if((RCU_CFG0 & RCU_CFG0_PLLMF_5)){
 8001580:	0048      	lsls	r0, r1, #1
            pllmf |= 0x10U;
 8001582:	f042 0210 	orr.w	r2, r2, #16
        if((RCU_CFG0 & RCU_CFG0_PLLMF_5)){
 8001586:	d501      	bpl.n	800158c <main+0x53c>
            pllmf |= 0x20U;
 8001588:	f042 0220 	orr.w	r2, r2, #32
        cksys_freq = ck_src*pllmf;
 800158c:	fb02 3303 	mla	r3, r2, r3, r3
        if(15U == pllmf){
 8001590:	e786      	b.n	80014a0 <main+0x450>
            udiv = (uclk+baudval/2U)/baudval;
 8001592:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 8001596:	fbb3 f3f2 	udiv	r3, r3, r2
            intdiv = udiv & 0x0000fff0U;
 800159a:	f64f 71f0 	movw	r1, #65520	; 0xfff0
            fradiv = udiv & 0x0000000fU;
 800159e:	f003 020f 	and.w	r2, r3, #15
            intdiv = udiv & 0x0000fff0U;
 80015a2:	400b      	ands	r3, r1
 80015a4:	e7a0      	b.n	80014e8 <main+0x498>
        if((RCU_CFG0 & RCU_CFG0_PLLMF_5)){
 80015a6:	0049      	lsls	r1, r1, #1
 80015a8:	d4ee      	bmi.n	8001588 <main+0x538>
        if(pllmf < 15U){
 80015aa:	2a0f      	cmp	r2, #15
 80015ac:	d0ee      	beq.n	800158c <main+0x53c>
        if(15U == pllmf){
 80015ae:	2a0d      	cmp	r2, #13
            pllmf += 2U;
 80015b0:	f102 0102 	add.w	r1, r2, #2
        if(15U == pllmf){
 80015b4:	d106      	bne.n	80015c4 <main+0x574>
            cksys_freq = ck_src*6U + ck_src/2U;
 80015b6:	2106      	movs	r1, #6
 80015b8:	085a      	lsrs	r2, r3, #1
 80015ba:	fb01 2303 	mla	r3, r1, r3, r2
 80015be:	e76f      	b.n	80014a0 <main+0x450>
            ck_src = IRC8M_VALUE/2U;
 80015c0:	4b0e      	ldr	r3, [pc, #56]	; (80015fc <main+0x5ac>)
 80015c2:	e7d5      	b.n	8001570 <main+0x520>
        cksys_freq = ck_src*pllmf;
 80015c4:	fb03 f301 	mul.w	r3, r3, r1
 80015c8:	e76a      	b.n	80014a0 <main+0x450>
 80015ca:	bf00      	nop
 80015cc:	4002101c 	.word	0x4002101c
 80015d0:	40021010 	.word	0x40021010
 80015d4:	40004c0c 	.word	0x40004c0c
 80015d8:	40004c10 	.word	0x40004c10
 80015dc:	08001b94 	.word	0x08001b94
 80015e0:	40021004 	.word	0x40021004
 80015e4:	007a1200 	.word	0x007a1200
 80015e8:	017d7840 	.word	0x017d7840
 80015ec:	40004c08 	.word	0x40004c08
 80015f0:	e000e100 	.word	0xe000e100
 80015f4:	02dc6c00 	.word	0x02dc6c00
 80015f8:	4002102c 	.word	0x4002102c
 80015fc:	003d0900 	.word	0x003d0900

08001600 <SVC_Handler>:
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8001600:	f3ef 8309 	mrs	r3, PSP
    psp += sizeof (struct port_extctx);
 8001604:	3320      	adds	r3, #32
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8001606:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800160a:	2300      	movs	r3, #0
 800160c:	f383 8811 	msr	BASEPRI, r3
}
 8001610:	4770      	bx	lr
 8001612:	bf00      	nop
	...

08001620 <chThdExit>:
void chThdExit(msg_t msg) {
 8001620:	b538      	push	{r3, r4, r5, lr}
 8001622:	2320      	movs	r3, #32
 8001624:	f383 8811 	msr	BASEPRI, r3
  return __sch_get_currthread();
 8001628:	4b12      	ldr	r3, [pc, #72]	; (8001674 <chThdExit+0x54>)
 800162a:	68dc      	ldr	r4, [r3, #12]
  return (bool)(lp->next != lp);
 800162c:	6b23      	ldr	r3, [r4, #48]	; 0x30
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 800162e:	f104 0530 	add.w	r5, r4, #48	; 0x30
 8001632:	429d      	cmp	r5, r3
  currtp->u.exitcode = msg;
 8001634:	62e0      	str	r0, [r4, #44]	; 0x2c
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8001636:	d107      	bne.n	8001648 <chThdExit+0x28>
  if (unlikely(currtp->refs == (trefs_t)0)) {
 8001638:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 800163c:	b183      	cbz	r3, 8001660 <chThdExit+0x40>
}
 800163e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSchGoSleepS(CH_STATE_FINAL);
 8001642:	200f      	movs	r0, #15
 8001644:	f7ff bad4 	b.w	8000bf0 <chSchGoSleepS>
  lp->next = p->next;
 8001648:	681a      	ldr	r2, [r3, #0]
    (void) chSchReadyI(threadref(ch_list_unlink(&currtp->waiting)));
 800164a:	4618      	mov	r0, r3
 800164c:	6322      	str	r2, [r4, #48]	; 0x30
 800164e:	f7ff f807 	bl	8000660 <chSchReadyI>
  return (bool)(lp->next != lp);
 8001652:	6b23      	ldr	r3, [r4, #48]	; 0x30
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8001654:	42ab      	cmp	r3, r5
 8001656:	d1f7      	bne.n	8001648 <chThdExit+0x28>
  if (unlikely(currtp->refs == (trefs_t)0)) {
 8001658:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 800165c:	2b00      	cmp	r3, #0
 800165e:	d1ee      	bne.n	800163e <chThdExit+0x1e>
    if (unlikely(((currtp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC))) {
 8001660:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
 8001664:	079b      	lsls	r3, r3, #30
 8001666:	d1ea      	bne.n	800163e <chThdExit+0x1e>
  p->prev->next = p->next;
 8001668:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
 800166c:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 800166e:	605a      	str	r2, [r3, #4]
  return p;
 8001670:	e7e5      	b.n	800163e <chThdExit+0x1e>
 8001672:	bf00      	nop
 8001674:	20000a58 	.word	0x20000a58
	...

08001680 <chSchDoPreemption>:
  thread_t *otp = __instance_get_currthread(oip);
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  ntp->state = CH_STATE_CURRENT;
 8001680:	2301      	movs	r3, #1
void chSchDoPreemption(void) {
 8001682:	b430      	push	{r4, r5}
  tp->state = CH_STATE_READY;
 8001684:	2500      	movs	r5, #0
  thread_t *otp = __instance_get_currthread(oip);
 8001686:	4a0c      	ldr	r2, [pc, #48]	; (80016b8 <chSchDoPreemption+0x38>)
  ch_priority_queue_t *p = pqp->next;
 8001688:	6810      	ldr	r0, [r2, #0]
 800168a:	68d1      	ldr	r1, [r2, #12]
  pqp->next       = p->next;
 800168c:	6804      	ldr	r4, [r0, #0]
  pqp->next->prev = pqp;
 800168e:	6062      	str	r2, [r4, #4]
  ntp->state = CH_STATE_CURRENT;
 8001690:	f880 3028 	strb.w	r3, [r0, #40]	; 0x28
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
 8001694:	698b      	ldr	r3, [r1, #24]
  pqp->next       = p->next;
 8001696:	6014      	str	r4, [r2, #0]
  tp->state = CH_STATE_READY;
 8001698:	f881 5028 	strb.w	r5, [r1, #40]	; 0x28
  } while (unlikely(pqp->prio > p->prio));
 800169c:	688c      	ldr	r4, [r1, #8]
  __instance_set_currthread(oip, ntp);
 800169e:	60d0      	str	r0, [r2, #12]
    pqp = pqp->next;
 80016a0:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio > p->prio));
 80016a2:	689a      	ldr	r2, [r3, #8]
 80016a4:	42a2      	cmp	r2, r4
 80016a6:	d8fb      	bhi.n	80016a0 <chSchDoPreemption+0x20>
  otp = __sch_ready_ahead(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
}
 80016a8:	bc30      	pop	{r4, r5}
  p->prev       = pqp->prev;
 80016aa:	685a      	ldr	r2, [r3, #4]
 80016ac:	e9c1 3200 	strd	r3, r2, [r1]
  p->prev->next = p;
 80016b0:	6011      	str	r1, [r2, #0]
  pqp->prev     = p;
 80016b2:	6059      	str	r1, [r3, #4]
  chSysSwitch(ntp, otp);
 80016b4:	f7fe bdea 	b.w	800028c <__port_switch>
 80016b8:	20000a58 	.word	0x20000a58
 80016bc:	00000000 	.word	0x00000000

080016c0 <__early_init>:
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
#endif
    /* reset the RCU clock configuration to the default reset state */
    /* Set IRC8MEN bit */
    RCU_CTL |= RCU_CTL_IRC8MEN;
 80016c0:	4b70      	ldr	r3, [pc, #448]	; (8001884 <__early_init+0x1c4>)
 */
void boardInit(void) {

}

void __early_init(void) {
 80016c2:	b570      	push	{r4, r5, r6, lr}
    while(0U == (RCU_CTL & RCU_CTL_IRC8MSTB)){
 80016c4:	4619      	mov	r1, r3
    RCU_CTL |= RCU_CTL_IRC8MEN;
 80016c6:	681a      	ldr	r2, [r3, #0]
 80016c8:	b082      	sub	sp, #8
 80016ca:	f042 0201 	orr.w	r2, r2, #1
 80016ce:	601a      	str	r2, [r3, #0]
    while(0U == (RCU_CTL & RCU_CTL_IRC8MSTB)){
 80016d0:	680b      	ldr	r3, [r1, #0]
 80016d2:	079b      	lsls	r3, r3, #30
 80016d4:	d5fc      	bpl.n	80016d0 <__early_init+0x10>
    }
    RCU_MODIFY(0x100);
 80016d6:	2100      	movs	r1, #0
 80016d8:	4a6b      	ldr	r2, [pc, #428]	; (8001888 <__early_init+0x1c8>)
 80016da:	6813      	ldr	r3, [r2, #0]
 80016dc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80016e0:	6013      	str	r3, [r2, #0]
 80016e2:	9101      	str	r1, [sp, #4]
 80016e4:	9b01      	ldr	r3, [sp, #4]
 80016e6:	2bff      	cmp	r3, #255	; 0xff
 80016e8:	d805      	bhi.n	80016f6 <__early_init+0x36>
 80016ea:	9b01      	ldr	r3, [sp, #4]
 80016ec:	3301      	adds	r3, #1
 80016ee:	9301      	str	r3, [sp, #4]
 80016f0:	9b01      	ldr	r3, [sp, #4]
 80016f2:	2bff      	cmp	r3, #255	; 0xff
 80016f4:	d9f9      	bls.n	80016ea <__early_init+0x2a>
 80016f6:	2100      	movs	r1, #0
 80016f8:	4a63      	ldr	r2, [pc, #396]	; (8001888 <__early_init+0x1c8>)
 80016fa:	6813      	ldr	r3, [r2, #0]
 80016fc:	f043 0390 	orr.w	r3, r3, #144	; 0x90
 8001700:	6013      	str	r3, [r2, #0]
 8001702:	9101      	str	r1, [sp, #4]
 8001704:	9b01      	ldr	r3, [sp, #4]
 8001706:	2bff      	cmp	r3, #255	; 0xff
 8001708:	d805      	bhi.n	8001716 <__early_init+0x56>
 800170a:	9b01      	ldr	r3, [sp, #4]
 800170c:	3301      	adds	r3, #1
 800170e:	9301      	str	r3, [sp, #4]
 8001710:	9b01      	ldr	r3, [sp, #4]
 8001712:	2bff      	cmp	r3, #255	; 0xff
 8001714:	d9f9      	bls.n	800170a <__early_init+0x4a>
    /* disable all interrupts */
    RCU_INT = 0x00ff0000U;
#endif /* GD32F50X_EPRT and GD32F50X_HD */

    /* Reset CFG0 and CFG1 registers */
    RCU_CFG0 = 0x00000000U;
 8001716:	2400      	movs	r4, #0
    RCU_INT = 0x00ff0000U;
 8001718:	f44f 067f 	mov.w	r6, #16711680	; 0xff0000
    RCU_CFG0 &= ~RCU_CFG0_SCS;
 800171c:	495a      	ldr	r1, [pc, #360]	; (8001888 <__early_init+0x1c8>)
    RCU_CTL &= ~(RCU_CTL_PLLEN |RCU_CTL_PLL1EN | RCU_CTL_PLL2EN | RCU_CTL_CKMEN | RCU_CTL_HXTALEN);
 800171e:	4b59      	ldr	r3, [pc, #356]	; (8001884 <__early_init+0x1c4>)
    RCU_CFG0 &= ~RCU_CFG0_SCS;
 8001720:	680a      	ldr	r2, [r1, #0]
{
    uint32_t timeout = 0U;
    uint32_t stab_flag = 0U;

    /* enable HXTAL */
    RCU_CTL |= RCU_CTL_HXTALEN;
 8001722:	f64f 70ff 	movw	r0, #65535	; 0xffff
    RCU_CFG0 &= ~RCU_CFG0_SCS;
 8001726:	f022 0203 	bic.w	r2, r2, #3
 800172a:	600a      	str	r2, [r1, #0]
    RCU_CTL &= ~(RCU_CTL_PLLEN |RCU_CTL_PLL1EN | RCU_CTL_PLL2EN | RCU_CTL_CKMEN | RCU_CTL_HXTALEN);
 800172c:	681a      	ldr	r2, [r3, #0]

    /* wait until HXTAL is stable or the startup time is longer than HXTAL_STARTUP_TIMEOUT */
    do{
        timeout++;
        stab_flag = (RCU_CTL & RCU_CTL_HXTALSTB);
 800172e:	461d      	mov	r5, r3
    RCU_CTL &= ~(RCU_CTL_PLLEN |RCU_CTL_PLL1EN | RCU_CTL_PLL2EN | RCU_CTL_CKMEN | RCU_CTL_HXTALEN);
 8001730:	f022 52a8 	bic.w	r2, r2, #352321536	; 0x15000000
 8001734:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000
 8001738:	601a      	str	r2, [r3, #0]
    RCU_INT = 0x00ff0000U;
 800173a:	4a54      	ldr	r2, [pc, #336]	; (800188c <__early_init+0x1cc>)
 800173c:	6016      	str	r6, [r2, #0]
    RCU_CFG0 = 0x00000000U;
 800173e:	600c      	str	r4, [r1, #0]
    RCU_CFG1 = 0x00000000U;
 8001740:	6254      	str	r4, [r2, #36]	; 0x24
    RCU_CTL &= ~(RCU_CTL_HXTALBPS);
 8001742:	681a      	ldr	r2, [r3, #0]
 8001744:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8001748:	601a      	str	r2, [r3, #0]
    RCU_CTL |= RCU_CTL_HXTALEN;
 800174a:	681a      	ldr	r2, [r3, #0]
 800174c:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8001750:	601a      	str	r2, [r3, #0]
 8001752:	e001      	b.n	8001758 <__early_init+0x98>
    }while((0U == stab_flag) && (HXTAL_STARTUP_TIMEOUT != timeout));
 8001754:	3801      	subs	r0, #1
 8001756:	d002      	beq.n	800175e <__early_init+0x9e>
        stab_flag = (RCU_CTL & RCU_CTL_HXTALSTB);
 8001758:	682b      	ldr	r3, [r5, #0]
    }while((0U == stab_flag) && (HXTAL_STARTUP_TIMEOUT != timeout));
 800175a:	039e      	lsls	r6, r3, #14
 800175c:	d5fa      	bpl.n	8001754 <__early_init+0x94>

    /* if fail */
    if(0U == (RCU_CTL & RCU_CTL_HXTALSTB)){
 800175e:	4a49      	ldr	r2, [pc, #292]	; (8001884 <__early_init+0x1c4>)
 8001760:	6813      	ldr	r3, [r2, #0]
 8001762:	039d      	lsls	r5, r3, #14
 8001764:	f140 808c 	bpl.w	8001880 <__early_init+0x1c0>
        while(1){
        }
    }

    FMC_WS = (FMC_WS & (~FMC_WS_WSCNT)) | WS_WSCNT(4);
 8001768:	4849      	ldr	r0, [pc, #292]	; (8001890 <__early_init+0x1d0>)

    RCU_APB1EN |= RCU_APB1EN_PMUEN;
 800176a:	4c4a      	ldr	r4, [pc, #296]	; (8001894 <__early_init+0x1d4>)
    FMC_WS = (FMC_WS & (~FMC_WS_WSCNT)) | WS_WSCNT(4);
 800176c:	6801      	ldr	r1, [r0, #0]

    /* HXTAL is stable */
    /* AHB = SYSCLK */
    RCU_CFG0 |= RCU_AHB_CKSYS_DIV1;
 800176e:	4b46      	ldr	r3, [pc, #280]	; (8001888 <__early_init+0x1c8>)
    FMC_WS = (FMC_WS & (~FMC_WS_WSCNT)) | WS_WSCNT(4);
 8001770:	f021 0107 	bic.w	r1, r1, #7
 8001774:	f041 0104 	orr.w	r1, r1, #4
 8001778:	6001      	str	r1, [r0, #0]
    RCU_APB1EN |= RCU_APB1EN_PMUEN;
 800177a:	6821      	ldr	r1, [r4, #0]
    RCU_CFG1 |= (RCU_PLLPRESRC_HXTAL | RCU_PREDV0SRC_CKPLL1 | RCU_PLL1_MUL8 | RCU_PREDV1_DIV5 | RCU_PREDV0_DIV10)    ;

    /* enable PLL1 */
    RCU_CTL |= RCU_CTL_PLL1EN;
    /* wait till PLL1 is ready */
    while((RCU_CTL & RCU_CTL_PLL1STB) == 0U){
 800177c:	4610      	mov	r0, r2
    RCU_APB1EN |= RCU_APB1EN_PMUEN;
 800177e:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8001782:	6021      	str	r1, [r4, #0]
    RCU_CFG0 |= RCU_AHB_CKSYS_DIV1;
 8001784:	6819      	ldr	r1, [r3, #0]
    RCU_CFG1 &= ~(RCU_CFG1_PLLPRESEL | RCU_CFG1_PREDV0SEL | RCU_CFG1_PLL1MF | RCU_CFG1_PREDV1 | RCU_CFG1_PREDV0);
 8001786:	4d44      	ldr	r5, [pc, #272]	; (8001898 <__early_init+0x1d8>)
    RCU_CFG0 |= RCU_AHB_CKSYS_DIV1;
 8001788:	6019      	str	r1, [r3, #0]
    RCU_CFG0 |= RCU_APB2_CKAHB_DIV1;
 800178a:	6819      	ldr	r1, [r3, #0]
 800178c:	6019      	str	r1, [r3, #0]
    RCU_CFG0 |= RCU_APB1_CKAHB_DIV2;
 800178e:	6819      	ldr	r1, [r3, #0]
 8001790:	f441 6180 	orr.w	r1, r1, #1024	; 0x400
 8001794:	6019      	str	r1, [r3, #0]
    RCU_CFG0 &= ~(RCU_CFG0_PLLMF | RCU_CFG0_PLLMF_4 | RCU_CFG0_PLLMF_5);
 8001796:	6819      	ldr	r1, [r3, #0]
 8001798:	f021 41c0 	bic.w	r1, r1, #1610612736	; 0x60000000
 800179c:	f421 1170 	bic.w	r1, r1, #3932160	; 0x3c0000
 80017a0:	6019      	str	r1, [r3, #0]
    RCU_CFG0 |= (RCU_PLLSRC_HXTAL_IRC48M | RCU_PLL_MUL45);
 80017a2:	6819      	ldr	r1, [r3, #0]
 80017a4:	f041 4180 	orr.w	r1, r1, #1073741824	; 0x40000000
 80017a8:	f441 1144 	orr.w	r1, r1, #3211264	; 0x310000
 80017ac:	6019      	str	r1, [r3, #0]
    RCU_CFG1 &= ~(RCU_CFG1_PLLPRESEL | RCU_CFG1_PREDV0SEL | RCU_CFG1_PLL1MF | RCU_CFG1_PREDV1 | RCU_CFG1_PREDV0);
 80017ae:	6923      	ldr	r3, [r4, #16]
 80017b0:	402b      	ands	r3, r5
 80017b2:	6123      	str	r3, [r4, #16]
    RCU_CFG1 |= (RCU_PLLPRESRC_HXTAL | RCU_PREDV0SRC_CKPLL1 | RCU_PLL1_MUL8 | RCU_PREDV1_DIV5 | RCU_PREDV0_DIV10)    ;
 80017b4:	6923      	ldr	r3, [r4, #16]
 80017b6:	f443 3383 	orr.w	r3, r3, #67072	; 0x10600
 80017ba:	f043 0349 	orr.w	r3, r3, #73	; 0x49
 80017be:	6123      	str	r3, [r4, #16]
    RCU_CTL |= RCU_CTL_PLL1EN;
 80017c0:	6813      	ldr	r3, [r2, #0]
 80017c2:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 80017c6:	6013      	str	r3, [r2, #0]
    while((RCU_CTL & RCU_CTL_PLL1STB) == 0U){
 80017c8:	6803      	ldr	r3, [r0, #0]
 80017ca:	011c      	lsls	r4, r3, #4
 80017cc:	d5fc      	bpl.n	80017c8 <__early_init+0x108>
    while((RCU_CTL & RCU_CTL_PLL1STB) == 0U){
    }
#endif /* GD32F50X_HD */

    /* enable PLL */
    RCU_CTL |= RCU_CTL_PLLEN;
 80017ce:	6803      	ldr	r3, [r0, #0]

    /* wait until PLL is stable */
    while(0U == (RCU_CTL & RCU_CTL_PLLSTB)){
 80017d0:	4a2c      	ldr	r2, [pc, #176]	; (8001884 <__early_init+0x1c4>)
    RCU_CTL |= RCU_CTL_PLLEN;
 80017d2:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80017d6:	6003      	str	r3, [r0, #0]
    while(0U == (RCU_CTL & RCU_CTL_PLLSTB)){
 80017d8:	6813      	ldr	r3, [r2, #0]
 80017da:	0199      	lsls	r1, r3, #6
 80017dc:	d5fc      	bpl.n	80017d8 <__early_init+0x118>
    }

    /* enable the high-drive to extend the clock frequency to 180 MHz */
    PMU_CTL0 |= PMU_CTL0_HDEN;
 80017de:	4a2f      	ldr	r2, [pc, #188]	; (800189c <__early_init+0x1dc>)
    while(0U == (PMU_CS0 & PMU_CS0_HDRF)){
 80017e0:	492f      	ldr	r1, [pc, #188]	; (80018a0 <__early_init+0x1e0>)
    PMU_CTL0 |= PMU_CTL0_HDEN;
 80017e2:	6813      	ldr	r3, [r2, #0]
 80017e4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80017e8:	6013      	str	r3, [r2, #0]
    while(0U == (PMU_CS0 & PMU_CS0_HDRF)){
 80017ea:	680b      	ldr	r3, [r1, #0]
 80017ec:	03da      	lsls	r2, r3, #15
 80017ee:	d5fc      	bpl.n	80017ea <__early_init+0x12a>
    }

    /* select the high-drive mode */
    PMU_CTL0 |= PMU_CTL0_HDS;
 80017f0:	4a2a      	ldr	r2, [pc, #168]	; (800189c <__early_init+0x1dc>)
    while(0U == (PMU_CS0 & PMU_CS0_HDSRF)){
 80017f2:	492b      	ldr	r1, [pc, #172]	; (80018a0 <__early_init+0x1e0>)
    PMU_CTL0 |= PMU_CTL0_HDS;
 80017f4:	6813      	ldr	r3, [r2, #0]
 80017f6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80017fa:	6013      	str	r3, [r2, #0]
    while(0U == (PMU_CS0 & PMU_CS0_HDSRF)){
 80017fc:	680b      	ldr	r3, [r1, #0]
 80017fe:	039b      	lsls	r3, r3, #14
 8001800:	d5fc      	bpl.n	80017fc <__early_init+0x13c>
    }

    /* select PLL as system clock */
    RCU_CFG0 &= ~RCU_CFG0_SCS;
 8001802:	4b21      	ldr	r3, [pc, #132]	; (8001888 <__early_init+0x1c8>)
    RCU_CFG0 |= RCU_CKSYSSRC_PLL;

    /* wait until PLL is selected as system clock */
    while(RCU_SCSS_PLL != (RCU_CFG0 & RCU_CFG0_SCSS)){
 8001804:	4619      	mov	r1, r3
    RCU_CFG0 &= ~RCU_CFG0_SCS;
 8001806:	681a      	ldr	r2, [r3, #0]
 8001808:	f022 0203 	bic.w	r2, r2, #3
 800180c:	601a      	str	r2, [r3, #0]
    RCU_CFG0 |= RCU_CKSYSSRC_PLL;
 800180e:	681a      	ldr	r2, [r3, #0]
 8001810:	f042 0202 	orr.w	r2, r2, #2
 8001814:	601a      	str	r2, [r3, #0]
    while(RCU_SCSS_PLL != (RCU_CFG0 & RCU_CFG0_SCSS)){
 8001816:	680b      	ldr	r3, [r1, #0]
 8001818:	f003 030c 	and.w	r3, r3, #12
 800181c:	2b08      	cmp	r3, #8
 800181e:	d1fa      	bne.n	8001816 <__early_init+0x156>
    \param[out] none
    \retval     none
*/
void nvic_vector_table_set(uint32_t nvic_vict_tab, uint32_t offset)
{
    SCB->VTOR = nvic_vict_tab | (offset & NVIC_VECTTAB_OFFSET_MASK);
 8001820:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8001824:	4b1f      	ldr	r3, [pc, #124]	; (80018a4 <__early_init+0x1e4>)
 8001826:	609a      	str	r2, [r3, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8001828:	f3bf 8f4f 	dsb	sy
    // palSetLineMode(LINE_LED2, GDPAL_MODE(GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ));
    // palSetLineMode(LINE_LED3, GDPAL_MODE(GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ));

    // gpio_init(GPIOA, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_7);

    palSetPadMode(GPIOA, GPIO_PIN_7, GDPAL_MODE(GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ));
 800182c:	2110      	movs	r1, #16
    RCU_REG_VAL(periph) |= BIT(RCU_BIT_POS(periph));
 800182e:	4b1e      	ldr	r3, [pc, #120]	; (80018a8 <__early_init+0x1e8>)
 8001830:	2280      	movs	r2, #128	; 0x80
 8001832:	6818      	ldr	r0, [r3, #0]
 8001834:	f040 0004 	orr.w	r0, r0, #4
 8001838:	6018      	str	r0, [r3, #0]
 800183a:	681c      	ldr	r4, [r3, #0]
 800183c:	481b      	ldr	r0, [pc, #108]	; (80018ac <__early_init+0x1ec>)
 800183e:	f044 0408 	orr.w	r4, r4, #8
 8001842:	601c      	str	r4, [r3, #0]
 8001844:	681c      	ldr	r4, [r3, #0]
 8001846:	430c      	orrs	r4, r1
 8001848:	601c      	str	r4, [r3, #0]
 800184a:	681c      	ldr	r4, [r3, #0]
 800184c:	f044 0420 	orr.w	r4, r4, #32
 8001850:	601c      	str	r4, [r3, #0]
 8001852:	f7fe fdad 	bl	80003b0 <gpio_init.constprop.0>
    palSetPadMode(GPIOA, GPIO_PIN_8, GDPAL_MODE(GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ));
 8001856:	f44f 7280 	mov.w	r2, #256	; 0x100
 800185a:	2110      	movs	r1, #16
 800185c:	4813      	ldr	r0, [pc, #76]	; (80018ac <__early_init+0x1ec>)
 800185e:	f7fe fda7 	bl	80003b0 <gpio_init.constprop.0>
    palSetPadMode(GPIOA, GPIO_PIN_10, GDPAL_MODE(GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ));
 8001862:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8001866:	2110      	movs	r1, #16
 8001868:	4810      	ldr	r0, [pc, #64]	; (80018ac <__early_init+0x1ec>)
 800186a:	f7fe fda1 	bl	80003b0 <gpio_init.constprop.0>
    palSetPadMode(GPIOC, GPIO_PIN_13, GDPAL_MODE(GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ));    
 800186e:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8001872:	2110      	movs	r1, #16
 8001874:	480e      	ldr	r0, [pc, #56]	; (80018b0 <__early_init+0x1f0>)
}
 8001876:	b002      	add	sp, #8
 8001878:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    palSetPadMode(GPIOC, GPIO_PIN_13, GDPAL_MODE(GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ));    
 800187c:	f7fe bd98 	b.w	80003b0 <gpio_init.constprop.0>
        while(1){
 8001880:	e7fe      	b.n	8001880 <__early_init+0x1c0>
 8001882:	bf00      	nop
 8001884:	40021000 	.word	0x40021000
 8001888:	40021004 	.word	0x40021004
 800188c:	40021008 	.word	0x40021008
 8001890:	40022000 	.word	0x40022000
 8001894:	4002101c 	.word	0x4002101c
 8001898:	bffef000 	.word	0xbffef000
 800189c:	40007000 	.word	0x40007000
 80018a0:	40007004 	.word	0x40007004
 80018a4:	e000ed00 	.word	0xe000ed00
 80018a8:	40021018 	.word	0x40021018
 80018ac:	40010800 	.word	0x40010800
 80018b0:	40011000 	.word	0x40011000
	...

080018c0 <Vector110>:
OSAL_IRQ_HANDLER(Vector110) {
 80018c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
#endif
  }
}

void sd_lld_serve_interrupt(SerialDriver *sdp){
    while(USART_STAT0(sdp->uart_basic) & 0x20){
 80018c4:	4c48      	ldr	r4, [pc, #288]	; (80019e8 <Vector110+0x128>)
 80018c6:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
 80018ca:	681a      	ldr	r2, [r3, #0]
 80018cc:	0695      	lsls	r5, r2, #26
 80018ce:	d545      	bpl.n	800195c <Vector110+0x9c>
    if(USART5 == usart_periph){
 80018d0:	f8df 8124 	ldr.w	r8, [pc, #292]	; 80019f8 <Vector110+0x138>
        return (uint16_t)(GET_BITS(USART5_RDATA(usart_periph), 0U, 8U));
 80018d4:	4f45      	ldr	r7, [pc, #276]	; (80019ec <Vector110+0x12c>)
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (ch_queue_notempty(&tqp->queue)) {
 80018d6:	f104 060c 	add.w	r6, r4, #12
 80018da:	e021      	b.n	8001920 <Vector110+0x60>
  if (!iqIsFullI(iqp)) {
 80018dc:	e9d4 3208 	ldrd	r3, r2, [r4, #32]
 80018e0:	4293      	cmp	r3, r2
 80018e2:	d033      	beq.n	800194c <Vector110+0x8c>
    iqp->q_counter++;
 80018e4:	6962      	ldr	r2, [r4, #20]
    *iqp->q_wrptr++ = b;
 80018e6:	1c59      	adds	r1, r3, #1
    iqp->q_counter++;
 80018e8:	3201      	adds	r2, #1
 80018ea:	6162      	str	r2, [r4, #20]
    *iqp->q_wrptr++ = b;
 80018ec:	6221      	str	r1, [r4, #32]
 80018ee:	701d      	strb	r5, [r3, #0]
    if (iqp->q_wrptr >= iqp->q_top) {
 80018f0:	e9d4 3207 	ldrd	r3, r2, [r4, #28]
 80018f4:	429a      	cmp	r2, r3
 80018f6:	d301      	bcc.n	80018fc <Vector110+0x3c>
      iqp->q_wrptr = iqp->q_buffer;
 80018f8:	69a3      	ldr	r3, [r4, #24]
 80018fa:	6223      	str	r3, [r4, #32]
  return (bool)(qp->next != qp);
 80018fc:	68e0      	ldr	r0, [r4, #12]
 80018fe:	42b0      	cmp	r0, r6
 8001900:	d006      	beq.n	8001910 <Vector110+0x50>

  tp = threadref(ch_queue_fifo_remove(&tqp->queue));

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8001902:	2200      	movs	r2, #0
  qp->next       = p->next;
 8001904:	6803      	ldr	r3, [r0, #0]
 8001906:	60e3      	str	r3, [r4, #12]
  qp->next->prev = qp;
 8001908:	605e      	str	r6, [r3, #4]
 800190a:	62c2      	str	r2, [r0, #44]	; 0x2c
  (void) chSchReadyI(tp);
 800190c:	f7fe fea8 	bl	8000660 <chSchReadyI>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001910:	2300      	movs	r3, #0
 8001912:	f383 8811 	msr	BASEPRI, r3
 8001916:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
 800191a:	681a      	ldr	r2, [r3, #0]
 800191c:	0690      	lsls	r0, r2, #26
 800191e:	d51d      	bpl.n	800195c <Vector110+0x9c>
 8001920:	2320      	movs	r3, #32
 8001922:	f383 8811 	msr	BASEPRI, r3
      osalSysLockFromISR();
      sdIncomingDataI(sdp, usart_data_receive(sdp->uart_basic) & 0xFF);
 8001926:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
    if(USART5 == usart_periph){
 800192a:	4543      	cmp	r3, r8
        return (uint16_t)(GET_BITS(USART5_RDATA(usart_periph), 0U, 8U));
 800192c:	bf0c      	ite	eq
 800192e:	683b      	ldreq	r3, [r7, #0]
       return (uint16_t)(GET_BITS(USART_DATA(usart_periph), 0U, 8U)); 
 8001930:	685b      	ldrne	r3, [r3, #4]
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8001932:	6962      	ldr	r2, [r4, #20]
 8001934:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8001938:	b2dd      	uxtb	r5, r3
 800193a:	2a00      	cmp	r2, #0
 800193c:	d1ce      	bne.n	80018dc <Vector110+0x1c>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800193e:	2004      	movs	r0, #4
 8001940:	f7fe fe9e 	bl	8000680 <chEvtBroadcastFlagsI.constprop.0>
  if (!iqIsFullI(iqp)) {
 8001944:	e9d4 3208 	ldrd	r3, r2, [r4, #32]
 8001948:	4293      	cmp	r3, r2
 800194a:	d1cb      	bne.n	80018e4 <Vector110+0x24>
 800194c:	6962      	ldr	r2, [r4, #20]
 800194e:	2a00      	cmp	r2, #0
 8001950:	d0c8      	beq.n	80018e4 <Vector110+0x24>
 8001952:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8001956:	f7fe fe93 	bl	8000680 <chEvtBroadcastFlagsI.constprop.0>
 800195a:	e7d9      	b.n	8001910 <Vector110+0x50>
      osalSysUnlockFromISR();
    }

    if(USART_CTL0(sdp->uart_basic) & 0x80){           //trans buff empty
 800195c:	68db      	ldr	r3, [r3, #12]
 800195e:	0619      	lsls	r1, r3, #24
 8001960:	d53d      	bpl.n	80019de <Vector110+0x11e>
      while(USART_STAT0(sdp->uart_basic) & 0x80){
 8001962:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
 8001966:	681b      	ldr	r3, [r3, #0]
 8001968:	061a      	lsls	r2, r3, #24
 800196a:	d538      	bpl.n	80019de <Vector110+0x11e>
 800196c:	2620      	movs	r6, #32
 800196e:	4f20      	ldr	r7, [pc, #128]	; (80019f0 <Vector110+0x130>)
        USART_DATA(usart_periph) = ((uint16_t)USART_DATA_DATA & data);
 8001970:	4d20      	ldr	r5, [pc, #128]	; (80019f4 <Vector110+0x134>)
 8001972:	e01f      	b.n	80019b4 <Vector110+0xf4>
    oqp->q_counter++;
 8001974:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    if (oqp->q_rdptr >= oqp->q_top) {
 8001976:	6c20      	ldr	r0, [r4, #64]	; 0x40
    b = *oqp->q_rdptr++;
 8001978:	1c59      	adds	r1, r3, #1
    oqp->q_counter++;
 800197a:	3201      	adds	r2, #1
 800197c:	63a2      	str	r2, [r4, #56]	; 0x38
    b = *oqp->q_rdptr++;
 800197e:	64a1      	str	r1, [r4, #72]	; 0x48
    if (oqp->q_rdptr >= oqp->q_top) {
 8001980:	4281      	cmp	r1, r0
    b = *oqp->q_rdptr++;
 8001982:	f893 8000 	ldrb.w	r8, [r3]
    if (oqp->q_rdptr >= oqp->q_top) {
 8001986:	d301      	bcc.n	800198c <Vector110+0xcc>
      oqp->q_rdptr = oqp->q_buffer;
 8001988:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800198a:	64a3      	str	r3, [r4, #72]	; 0x48
  return (bool)(qp->next != qp);
 800198c:	6b20      	ldr	r0, [r4, #48]	; 0x30
 800198e:	42b8      	cmp	r0, r7
 8001990:	d006      	beq.n	80019a0 <Vector110+0xe0>
  tp->u.rdymsg = msg;
 8001992:	2200      	movs	r2, #0
  qp->next       = p->next;
 8001994:	6803      	ldr	r3, [r0, #0]
 8001996:	6323      	str	r3, [r4, #48]	; 0x30
  qp->next->prev = qp;
 8001998:	605f      	str	r7, [r3, #4]
 800199a:	62c2      	str	r2, [r0, #44]	; 0x2c
  (void) chSchReadyI(tp);
 800199c:	f7fe fe60 	bl	8000660 <chSchReadyI>
 80019a0:	2300      	movs	r3, #0
 80019a2:	f8c5 8000 	str.w	r8, [r5]
 80019a6:	f383 8811 	msr	BASEPRI, r3
 80019aa:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
 80019ae:	681b      	ldr	r3, [r3, #0]
 80019b0:	061b      	lsls	r3, r3, #24
 80019b2:	d514      	bpl.n	80019de <Vector110+0x11e>
 80019b4:	f386 8811 	msr	BASEPRI, r6
  if (!oqIsEmptyI(oqp)) {
 80019b8:	e9d4 2311 	ldrd	r2, r3, [r4, #68]	; 0x44
 80019bc:	429a      	cmp	r2, r3
 80019be:	d1d9      	bne.n	8001974 <Vector110+0xb4>
 80019c0:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80019c2:	2a00      	cmp	r2, #0
 80019c4:	d0d6      	beq.n	8001974 <Vector110+0xb4>
 80019c6:	2008      	movs	r0, #8
 80019c8:	f7fe fe5a 	bl	8000680 <chEvtBroadcastFlagsI.constprop.0>
        osalSysLockFromISR();
        b = oqGetI(&sdp->oqueue);
        if (b < MSG_OK) {
          chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
          // usart_interrupt_disable(UART3, USART_INT_TBE);
          USART_CTL0(sdp->uart_basic) &= ~ 0x80;
 80019cc:	f8d4 2254 	ldr.w	r2, [r4, #596]	; 0x254
 80019d0:	2100      	movs	r1, #0
 80019d2:	68d3      	ldr	r3, [r2, #12]
 80019d4:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80019d8:	60d3      	str	r3, [r2, #12]
 80019da:	f381 8811 	msr	BASEPRI, r1
}
 80019de:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  OSAL_IRQ_EPILOGUE();
 80019e2:	f7fe bd4d 	b.w	8000480 <__port_irq_epilogue>
 80019e6:	bf00      	nop
 80019e8:	20000800 	.word	0x20000800
 80019ec:	40017024 	.word	0x40017024
 80019f0:	20000830 	.word	0x20000830
 80019f4:	40004c04 	.word	0x40004c04
 80019f8:	40017000 	.word	0x40017000
 80019fc:	00000000 	.word	0x00000000

08001a00 <VectorB0>:

OSAL_IRQ_HANDLER(VectorB0) {
    uint32_t sr;

    OSAL_IRQ_PROLOGUE();
    sr = TIMER_INTF(TIMER1);
 8001a00:	4a39      	ldr	r2, [pc, #228]	; (8001ae8 <VectorB0+0xe8>)
 8001a02:	6813      	ldr	r3, [r2, #0]
    TIMER_INTF(TIMER1) = ~sr;
 8001a04:	43d9      	mvns	r1, r3

    if(sr & TIMER_INT_CH0){
 8001a06:	079b      	lsls	r3, r3, #30
    TIMER_INTF(TIMER1) = ~sr;
 8001a08:	6011      	str	r1, [r2, #0]
    if(sr & TIMER_INT_CH0){
 8001a0a:	d401      	bmi.n	8001a10 <VectorB0+0x10>
        osalSysLockFromISR();
        osalOsTimerHandlerI();
        osalSysUnlockFromISR();
    }

    OSAL_IRQ_EPILOGUE();
 8001a0c:	f7fe bd38 	b.w	8000480 <__port_irq_epilogue>
OSAL_IRQ_HANDLER(VectorB0) {
 8001a10:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8001a14:	2320      	movs	r3, #32
 8001a16:	f383 8811 	msr	BASEPRI, r3
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
void chVTDoTickI(void) {
 8001a1a:	4d34      	ldr	r5, [pc, #208]	; (8001aec <VectorB0+0xec>)
 8001a1c:	4e34      	ldr	r6, [pc, #208]	; (8001af0 <VectorB0+0xf0>)
  TIMER_DMAINTEN(TIMER1) = 0;
 8001a1e:	4f35      	ldr	r7, [pc, #212]	; (8001af4 <VectorB0+0xf4>)
 8001a20:	f105 0810 	add.w	r8, r5, #16
    lasttime = chTimeAddX(vtlp->lasttime, vtp->dlist.delta);
    vtlp->lasttime = lasttime;

    /* Removing the timer from the list, marking it as not armed.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
    vtp->dlist.next = NULL;
 8001a24:	f04f 0a00 	mov.w	sl, #0
    vtp = (virtual_timer_t *)vtlp->dlist.next;
 8001a28:	692c      	ldr	r4, [r5, #16]
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8001a2a:	69e9      	ldr	r1, [r5, #28]
  return (systime_t)TIMER_CNT(TIMER1);
 8001a2c:	6830      	ldr	r0, [r6, #0]
    if (nowdelta < vtp->dlist.delta) {
 8001a2e:	68a3      	ldr	r3, [r4, #8]
 8001a30:	1a42      	subs	r2, r0, r1
 8001a32:	429a      	cmp	r2, r3
  return systime + (systime_t)interval;
 8001a34:	eb01 0903 	add.w	r9, r1, r3
 8001a38:	d335      	bcc.n	8001aa6 <VectorB0+0xa6>
  dlp->prev->next = dlp->next;
 8001a3a:	e9d4 3200 	ldrd	r3, r2, [r4]
    vtlp->lasttime = lasttime;
 8001a3e:	f8c5 901c 	str.w	r9, [r5, #28]
 8001a42:	6013      	str	r3, [r2, #0]
  dlp->next->prev = dlp->prev;
 8001a44:	605a      	str	r2, [r3, #4]
    vtp->dlist.next = NULL;
 8001a46:	f8c4 a000 	str.w	sl, [r4]

    /* If the list becomes empty then the alarm is disabled.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8001a4a:	692b      	ldr	r3, [r5, #16]
 8001a4c:	4543      	cmp	r3, r8
  TIMER_DMAINTEN(TIMER1) = 0;
 8001a4e:	bf08      	it	eq
 8001a50:	f8c7 a000 	streq.w	sl, [r7]
 8001a54:	f38a 8811 	msr	BASEPRI, sl
    /* The callback is invoked outside the kernel critical section, it
       is re-entered on the callback return. Note that "lasttime" can be
       modified within the callback if some timer function is called.*/
    chSysUnlockFromISR();

    vtp->func(vtp, vtp->par);
 8001a58:	4620      	mov	r0, r4
 8001a5a:	e9d4 2103 	ldrd	r2, r1, [r4, #12]
 8001a5e:	4790      	blx	r2
 8001a60:	2320      	movs	r3, #32
 8001a62:	f383 8811 	msr	BASEPRI, r3

    chSysLockFromISR();

    /* If a reload is defined the timer needs to be restarted.*/
    if (unlikely(vtp->reload > (sysinterval_t)0)) {
 8001a66:	6963      	ldr	r3, [r4, #20]
 8001a68:	2b00      	cmp	r3, #0
 8001a6a:	d0dd      	beq.n	8001a28 <VectorB0+0x28>
  return (systime_t)TIMER_CNT(TIMER1);
 8001a6c:	6831      	ldr	r1, [r6, #0]
  return (sysinterval_t)((systime_t)(end - start));
 8001a6e:	eba1 0009 	sub.w	r0, r1, r9
      now = chVTGetSystemTimeX();
      nowdelta = chTimeDiffX(lasttime, now);

#if !defined(CH_VT_RFCU_DISABLED)
      /* Checking if the required reload is feasible.*/
      if (nowdelta > vtp->reload) {
 8001a72:	4283      	cmp	r3, r0
 8001a74:	d326      	bcc.n	8001ac4 <VectorB0+0xc4>
  return (bool)(dlhp == dlhp->next);
 8001a76:	692a      	ldr	r2, [r5, #16]
      /* Enqueuing the timer again using the calculated delta.*/
      delay = vtp->reload - nowdelta;
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {
 8001a78:	4542      	cmp	r2, r8
 8001a7a:	d02c      	beq.n	8001ad6 <VectorB0+0xd6>
  while (likely(dlp->delta < delta)) {
 8001a7c:	6891      	ldr	r1, [r2, #8]
 8001a7e:	428b      	cmp	r3, r1
 8001a80:	d904      	bls.n	8001a8c <VectorB0+0x8c>
    dlp = dlp->next;
 8001a82:	6812      	ldr	r2, [r2, #0]
    delta -= dlp->delta;
 8001a84:	1a5b      	subs	r3, r3, r1
  while (likely(dlp->delta < delta)) {
 8001a86:	6891      	ldr	r1, [r2, #8]
 8001a88:	4299      	cmp	r1, r3
 8001a8a:	d3fa      	bcc.n	8001a82 <VectorB0+0x82>
  dlhp->delta = (sysinterval_t)-1;
 8001a8c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  dlp->delta      = delta;
 8001a90:	60a3      	str	r3, [r4, #8]
  dlp->delta -= delta;
 8001a92:	6891      	ldr	r1, [r2, #8]
  dlp->next       = dlhp;
 8001a94:	6022      	str	r2, [r4, #0]
  dlp->delta -= delta;
 8001a96:	1acb      	subs	r3, r1, r3
  dlp->prev       = dlp->next->prev;
 8001a98:	6851      	ldr	r1, [r2, #4]
 8001a9a:	6061      	str	r1, [r4, #4]
  dlp->prev->next = dlp;
 8001a9c:	600c      	str	r4, [r1, #0]
  dlhp->prev      = dlp;
 8001a9e:	e9c2 4301 	strd	r4, r3, [r2, #4]
  dlhp->delta = (sysinterval_t)-1;
 8001aa2:	61a8      	str	r0, [r5, #24]
 8001aa4:	e7be      	b.n	8001a24 <VectorB0+0x24>
      ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
    }
  }

  /* If the list is empty, nothing else to do.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8001aa6:	4544      	cmp	r4, r8
 8001aa8:	d005      	beq.n	8001ab6 <VectorB0+0xb6>
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  vtlp->lasttime += nowdelta;
  vtp->dlist.delta -= nowdelta;
 8001aaa:	4419      	add	r1, r3
 8001aac:	1a09      	subs	r1, r1, r0
  vtlp->lasttime += nowdelta;
 8001aae:	61e8      	str	r0, [r5, #28]
  vtp->dlist.delta -= nowdelta;
 8001ab0:	60a1      	str	r1, [r4, #8]

  /* Update alarm time to next timer.*/
  vt_set_alarm(now, vtp->dlist.delta);
 8001ab2:	f7fe fe15 	bl	80006e0 <vt_set_alarm>
 8001ab6:	2300      	movs	r3, #0
 8001ab8:	f383 8811 	msr	BASEPRI, r3
}
 8001abc:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    OSAL_IRQ_EPILOGUE();
 8001ac0:	f7fe bcde 	b.w	8000480 <__port_irq_epilogue>
 8001ac4:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  return (bool)(dlhp == dlhp->next);
 8001ac6:	692a      	ldr	r2, [r5, #16]
 8001ac8:	f043 0302 	orr.w	r3, r3, #2
      if (ch_dlist_isempty(&vtlp->dlist)) {
 8001acc:	4542      	cmp	r2, r8
 8001ace:	636b      	str	r3, [r5, #52]	; 0x34
 8001ad0:	d007      	beq.n	8001ae2 <VectorB0+0xe2>
 8001ad2:	4603      	mov	r3, r0
 8001ad4:	e7d2      	b.n	8001a7c <VectorB0+0x7c>
        delay = vtp->reload - nowdelta;
 8001ad6:	444b      	add	r3, r9
 8001ad8:	1a5a      	subs	r2, r3, r1
        vt_insert_first(vtlp, vtp, now, delay);
 8001ada:	4620      	mov	r0, r4
 8001adc:	f7fe fd48 	bl	8000570 <vt_insert_first.constprop.0>
        return;
 8001ae0:	e7e9      	b.n	8001ab6 <VectorB0+0xb6>
        delay = (sysinterval_t)0;
 8001ae2:	2200      	movs	r2, #0
 8001ae4:	e7f9      	b.n	8001ada <VectorB0+0xda>
 8001ae6:	bf00      	nop
 8001ae8:	40000010 	.word	0x40000010
 8001aec:	20000a58 	.word	0x20000a58
 8001af0:	40000024 	.word	0x40000024
 8001af4:	4000000c 	.word	0x4000000c
	...

08001b00 <__init_ram_areas>:
#endif

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8001b00:	b4f0      	push	{r4, r5, r6, r7}
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8001b02:	2600      	movs	r6, #0
 8001b04:	4f13      	ldr	r7, [pc, #76]	; (8001b54 <__init_ram_areas+0x54>)
void __init_ram_areas(void) {
 8001b06:	4d14      	ldr	r5, [pc, #80]	; (8001b58 <__init_ram_areas+0x58>)
 8001b08:	4814      	ldr	r0, [pc, #80]	; (8001b5c <__init_ram_areas+0x5c>)
 8001b0a:	4b15      	ldr	r3, [pc, #84]	; (8001b60 <__init_ram_areas+0x60>)
 8001b0c:	4915      	ldr	r1, [pc, #84]	; (8001b64 <__init_ram_areas+0x64>)
 8001b0e:	f107 0c70 	add.w	ip, r7, #112	; 0x70
    while (p < rap->clear_area) {
 8001b12:	4298      	cmp	r0, r3
 8001b14:	d911      	bls.n	8001b3a <__init_ram_areas+0x3a>
 8001b16:	461a      	mov	r2, r3
 8001b18:	3904      	subs	r1, #4
      *p = *tp;
 8001b1a:	f851 4f04 	ldr.w	r4, [r1, #4]!
 8001b1e:	f842 4b04 	str.w	r4, [r2], #4
    while (p < rap->clear_area) {
 8001b22:	4290      	cmp	r0, r2
 8001b24:	d8f9      	bhi.n	8001b1a <__init_ram_areas+0x1a>
 8001b26:	1e42      	subs	r2, r0, #1
 8001b28:	1ad2      	subs	r2, r2, r3
 8001b2a:	f022 0203 	bic.w	r2, r2, #3
 8001b2e:	3204      	adds	r2, #4
 8001b30:	4413      	add	r3, r2
    while (p < rap->no_init_area) {
 8001b32:	429d      	cmp	r5, r3
 8001b34:	d903      	bls.n	8001b3e <__init_ram_areas+0x3e>
      *p = 0;
 8001b36:	f843 6b04 	str.w	r6, [r3], #4
    while (p < rap->no_init_area) {
 8001b3a:	429d      	cmp	r5, r3
 8001b3c:	d8fb      	bhi.n	8001b36 <__init_ram_areas+0x36>
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT0_AREAS_NUMBER]);
 8001b3e:	4567      	cmp	r7, ip
 8001b40:	d005      	beq.n	8001b4e <__init_ram_areas+0x4e>
 8001b42:	e9d7 1304 	ldrd	r1, r3, [r7, #16]
 8001b46:	e9d7 0506 	ldrd	r0, r5, [r7, #24]
 8001b4a:	3710      	adds	r7, #16
 8001b4c:	e7e1      	b.n	8001b12 <__init_ram_areas+0x12>
#endif
}
 8001b4e:	bcf0      	pop	{r4, r5, r6, r7}
 8001b50:	4770      	bx	lr
 8001b52:	bf00      	nop
 8001b54:	08001c14 	.word	0x08001c14
 8001b58:	20000c60 	.word	0x20000c60
 8001b5c:	20000c60 	.word	0x20000c60
 8001b60:	20000c60 	.word	0x20000c60
 8001b64:	08001cbc 	.word	0x08001cbc
	...

08001b70 <__default_exit>:
  while (true) {
 8001b70:	e7fe      	b.n	8001b70 <__default_exit>
 8001b72:	bf00      	nop
	...

08001b80 <__late_init>:
 8001b80:	4770      	bx	lr
 8001b82:	bf00      	nop
	...

08001b90 <__cpu_init>:
}
 8001b90:	4770      	bx	lr
 8001b92:	bf00      	nop
