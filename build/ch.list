
build/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <__vectors_base__>:
 8000000:	20000400 	.word	0x20000400
 8000004:	080001a1 	.word	0x080001a1
 8000008:	080001a3 	.word	0x080001a3
 800000c:	080001a3 	.word	0x080001a3
 8000010:	080001a3 	.word	0x080001a3
 8000014:	080001a3 	.word	0x080001a3
 8000018:	080001a3 	.word	0x080001a3
 800001c:	080001a3 	.word	0x080001a3
 8000020:	080001a3 	.word	0x080001a3
 8000024:	080001a3 	.word	0x080001a3
 8000028:	080001a3 	.word	0x080001a3
 800002c:	08001981 	.word	0x08001981
 8000030:	080001a3 	.word	0x080001a3
 8000034:	080001a3 	.word	0x080001a3
 8000038:	080001a3 	.word	0x080001a3
 800003c:	080001a3 	.word	0x080001a3
 8000040:	080001a3 	.word	0x080001a3
 8000044:	080001a3 	.word	0x080001a3
 8000048:	080001a3 	.word	0x080001a3
 800004c:	080001a3 	.word	0x080001a3
 8000050:	080001a3 	.word	0x080001a3
 8000054:	080001a3 	.word	0x080001a3
 8000058:	080001a3 	.word	0x080001a3
 800005c:	080001a3 	.word	0x080001a3
 8000060:	080001a3 	.word	0x080001a3
 8000064:	080001a3 	.word	0x080001a3
 8000068:	080001a3 	.word	0x080001a3
 800006c:	080001a3 	.word	0x080001a3
 8000070:	080001a3 	.word	0x080001a3
 8000074:	080001a3 	.word	0x080001a3
 8000078:	080001a3 	.word	0x080001a3
 800007c:	080001a3 	.word	0x080001a3
 8000080:	080001a3 	.word	0x080001a3
 8000084:	080001a3 	.word	0x080001a3
 8000088:	080001a3 	.word	0x080001a3
 800008c:	080001a3 	.word	0x080001a3
 8000090:	080001a3 	.word	0x080001a3
 8000094:	080001a3 	.word	0x080001a3
 8000098:	080001a3 	.word	0x080001a3
 800009c:	080001a3 	.word	0x080001a3
 80000a0:	080001a3 	.word	0x080001a3
 80000a4:	080001a3 	.word	0x080001a3
 80000a8:	080001a3 	.word	0x080001a3
 80000ac:	080001a3 	.word	0x080001a3
 80000b0:	08001cb1 	.word	0x08001cb1
 80000b4:	080001a3 	.word	0x080001a3
 80000b8:	080001a3 	.word	0x080001a3
 80000bc:	080001a3 	.word	0x080001a3
 80000c0:	080001a3 	.word	0x080001a3
 80000c4:	080001a3 	.word	0x080001a3
 80000c8:	080001a3 	.word	0x080001a3
 80000cc:	080001a3 	.word	0x080001a3
 80000d0:	080001a3 	.word	0x080001a3
 80000d4:	080001a3 	.word	0x080001a3
 80000d8:	080001a3 	.word	0x080001a3
 80000dc:	080001a3 	.word	0x080001a3
 80000e0:	080001a3 	.word	0x080001a3
 80000e4:	080001a3 	.word	0x080001a3
 80000e8:	080001a3 	.word	0x080001a3
 80000ec:	080001a3 	.word	0x080001a3
 80000f0:	080001a3 	.word	0x080001a3
 80000f4:	080001a3 	.word	0x080001a3
 80000f8:	080001a3 	.word	0x080001a3
 80000fc:	080001a3 	.word	0x080001a3
 8000100:	080001a3 	.word	0x080001a3
 8000104:	080001a3 	.word	0x080001a3
 8000108:	080001a3 	.word	0x080001a3
 800010c:	080001a3 	.word	0x080001a3
 8000110:	08001c91 	.word	0x08001c91
 8000114:	08001c41 	.word	0x08001c41
 8000118:	080001a3 	.word	0x080001a3
 800011c:	080001a3 	.word	0x080001a3
 8000120:	080001a3 	.word	0x080001a3
 8000124:	080001a3 	.word	0x080001a3
 8000128:	080001a3 	.word	0x080001a3
 800012c:	080001a3 	.word	0x080001a3
 8000130:	080001a3 	.word	0x080001a3
 8000134:	080001a3 	.word	0x080001a3
 8000138:	080001a3 	.word	0x080001a3
 800013c:	080001a3 	.word	0x080001a3
 8000140:	080001a3 	.word	0x080001a3
 8000144:	080001a3 	.word	0x080001a3
 8000148:	080001a3 	.word	0x080001a3
 800014c:	08001c31 	.word	0x08001c31
 8000150:	080001a3 	.word	0x080001a3
 8000154:	080001a3 	.word	0x080001a3
 8000158:	080001a3 	.word	0x080001a3
 800015c:	080001a3 	.word	0x080001a3
 8000160:	080001a3 	.word	0x080001a3
 8000164:	080001a3 	.word	0x080001a3
 8000168:	080001a3 	.word	0x080001a3
 800016c:	080001a3 	.word	0x080001a3
 8000170:	080001a3 	.word	0x080001a3
 8000174:	080001a3 	.word	0x080001a3
 8000178:	080001a3 	.word	0x080001a3
 800017c:	080001a3 	.word	0x080001a3
 8000180:	080001a3 	.word	0x080001a3
 8000184:	080001a3 	.word	0x080001a3
 8000188:	080001a3 	.word	0x080001a3
 800018c:	080001a3 	.word	0x080001a3
 8000190:	080001a3 	.word	0x080001a3
 8000194:	080001a3 	.word	0x080001a3
 8000198:	080001a3 	.word	0x080001a3
 800019c:	080001a3 	.word	0x080001a3

Disassembly of section .text:

080001a0 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 80001a0:	e002      	b.n	80001a8 <_crt0_entry>

080001a2 <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 80001a2:	f000 f800 	bl	80001a6 <_unhandled_exception>

080001a6 <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 80001a6:	e7fe      	b.n	80001a6 <_unhandled_exception>

080001a8 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80001a8:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80001aa:	4829      	ldr	r0, [pc, #164]	; (8000250 <endfiniloop+0x6>)
                msr     MSP, r0
 80001ac:	f380 8808 	msr	MSP, r0
#endif
                ldr     r0, =__main_stack_base__
 80001b0:	4828      	ldr	r0, [pc, #160]	; (8000254 <endfiniloop+0xa>)
                msr     MSPLIM, r0
 80001b2:	f380 880a 	msr	MSPLIM, r0

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80001b6:	4828      	ldr	r0, [pc, #160]	; (8000258 <endfiniloop+0xe>)
                msr     PSP, r0
 80001b8:	f380 8809 	msr	PSP, r0
                ldr     r0, =__process_stack_base__
 80001bc:	4827      	ldr	r0, [pc, #156]	; (800025c <endfiniloop+0x12>)
                msr     PSPLIM, r0
 80001be:	f380 880b 	msr	PSPLIM, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 80001c2:	4827      	ldr	r0, [pc, #156]	; (8000260 <endfiniloop+0x16>)
                ldr     r1, =SCB_VTOR
 80001c4:	4927      	ldr	r1, [pc, #156]	; (8000264 <endfiniloop+0x1a>)
                str     r0, [r1]
 80001c6:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 80001c8:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 80001ca:	f380 8814 	msr	CONTROL, r0
                isb
 80001ce:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __cpu_init
 80001d2:	f001 fe35 	bl	8001e40 <__cpu_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 80001d6:	f001 fc33 	bl	8001a40 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 80001da:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 80001de:	491d      	ldr	r1, [pc, #116]	; (8000254 <endfiniloop+0xa>)
                ldr     r2, =__main_stack_end__
 80001e0:	4a1b      	ldr	r2, [pc, #108]	; (8000250 <endfiniloop+0x6>)

080001e2 <msloop>:
msloop:
                cmp     r1, r2
 80001e2:	4291      	cmp	r1, r2
                itt     lo
 80001e4:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 80001e6:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 80001ea:	e7fa      	bcc.n	80001e2 <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 80001ec:	491b      	ldr	r1, [pc, #108]	; (800025c <endfiniloop+0x12>)
                ldr     r2, =__process_stack_end__
 80001ee:	4a1a      	ldr	r2, [pc, #104]	; (8000258 <endfiniloop+0xe>)

080001f0 <psloop>:
psloop:
                cmp     r1, r2
 80001f0:	4291      	cmp	r1, r2
                itt     lo
 80001f2:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 80001f4:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 80001f8:	e7fa      	bcc.n	80001f0 <psloop>

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                ldr     r1, =__textdata_base__
 80001fa:	491b      	ldr	r1, [pc, #108]	; (8000268 <endfiniloop+0x1e>)
                ldr     r2, =__data_base__
 80001fc:	4a1b      	ldr	r2, [pc, #108]	; (800026c <endfiniloop+0x22>)
                ldr     r3, =__data_end__
 80001fe:	4b1c      	ldr	r3, [pc, #112]	; (8000270 <endfiniloop+0x26>)

08000200 <dloop>:
dloop:
                cmp     r2, r3
 8000200:	429a      	cmp	r2, r3
                ittt    lo
 8000202:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 8000204:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 8000208:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 800020c:	e7f8      	bcc.n	8000200 <dloop>

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                movs    r0, #0
 800020e:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
 8000210:	4918      	ldr	r1, [pc, #96]	; (8000274 <endfiniloop+0x2a>)
                ldr     r2, =__bss_end__
 8000212:	4a19      	ldr	r2, [pc, #100]	; (8000278 <endfiniloop+0x2e>)

08000214 <bloop>:
bloop:
                cmp     r1, r2
 8000214:	4291      	cmp	r1, r2
                itt     lo
 8000216:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000218:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 800021c:	e7fa      	bcc.n	8000214 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 800021e:	f001 fdc7 	bl	8001db0 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 8000222:	f001 fe05 	bl	8001e30 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 8000226:	4c15      	ldr	r4, [pc, #84]	; (800027c <endfiniloop+0x32>)
                ldr     r5, =__init_array_end__
 8000228:	4d15      	ldr	r5, [pc, #84]	; (8000280 <endfiniloop+0x36>)

0800022a <initloop>:
initloop:
                cmp     r4, r5
 800022a:	42ac      	cmp	r4, r5
                bge     endinitloop
 800022c:	da03      	bge.n	8000236 <endinitloop>
                ldr     r1, [r4], #4
 800022e:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000232:	4788      	blx	r1
                b       initloop
 8000234:	e7f9      	b.n	800022a <initloop>

08000236 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000236:	f001 f893 	bl	8001360 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 800023a:	4c12      	ldr	r4, [pc, #72]	; (8000284 <endfiniloop+0x3a>)
                ldr     r5, =__fini_array_end__
 800023c:	4d12      	ldr	r5, [pc, #72]	; (8000288 <endfiniloop+0x3e>)

0800023e <finiloop>:
finiloop:
                cmp     r4, r5
 800023e:	42ac      	cmp	r4, r5
                bge     endfiniloop
 8000240:	da03      	bge.n	800024a <endfiniloop>
                ldr     r1, [r4], #4
 8000242:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000246:	4788      	blx	r1
                b       finiloop
 8000248:	e7f9      	b.n	800023e <finiloop>

0800024a <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 800024a:	f001 bde9 	b.w	8001e20 <__default_exit>
 800024e:	0000      	.short	0x0000
                ldr     r0, =__main_stack_end__
 8000250:	20000400 	.word	0x20000400
                ldr     r0, =__main_stack_base__
 8000254:	20000000 	.word	0x20000000
                ldr     r0, =__process_stack_end__
 8000258:	20000800 	.word	0x20000800
                ldr     r0, =__process_stack_base__
 800025c:	20000400 	.word	0x20000400
                ldr     r0, =_vectors
 8000260:	08000000 	.word	0x08000000
                ldr     r1, =SCB_VTOR
 8000264:	e000ed08 	.word	0xe000ed08
                ldr     r1, =__textdata_base__
 8000268:	08001f70 	.word	0x08001f70
                ldr     r2, =__data_base__
 800026c:	20000800 	.word	0x20000800
                ldr     r3, =__data_end__
 8000270:	20000800 	.word	0x20000800
                ldr     r1, =__bss_base__
 8000274:	20000800 	.word	0x20000800
                ldr     r2, =__bss_end__
 8000278:	20000fa4 	.word	0x20000fa4
                ldr     r4, =__init_array_base__
 800027c:	080001a0 	.word	0x080001a0
                ldr     r5, =__init_array_end__
 8000280:	080001a0 	.word	0x080001a0
                ldr     r4, =__fini_array_base__
 8000284:	080001a0 	.word	0x080001a0
                ldr     r5, =__fini_array_end__
 8000288:	080001a0 	.word	0x080001a0

0800028c <__port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  __port_switch
__port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 800028c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                movs    r3, #0
                msr     PSPLIM, r3      /* Temporarily disabling stack check.*/
#endif

                /* Switching stacks.*/
                str     sp, [r1, #CONTEXT_OFFSET]
 8000290:	f8c1 d00c 	str.w	sp, [r1, #12]
                ldr     sp, [r0, #CONTEXT_OFFSET]
 8000294:	f8d0 d00c 	ldr.w	sp, [r0, #12]

#if CORTEX_USE_FPU
                /* Restoring FPU context.*/
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 8000298:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800029c <__port_thread_start>:
                bl      __stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 800029c:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 800029e:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80002a2:	4628      	mov	r0, r5
                blx     r4
 80002a4:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 80002a6:	2000      	movs	r0, #0
                bl      chThdExit
 80002a8:	f001 fb7a 	bl	80019a0 <chThdExit>

080002ac <.zombies>:
.zombies:       b       .zombies
 80002ac:	e7fe      	b.n	80002ac <.zombies>

080002ae <__port_switch_from_isr>:
                bl      __stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_lock
#endif
                bl      chSchDoPreemption
 80002ae:	f001 fba7 	bl	8001a00 <chSchDoPreemption>

080002b2 <__port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 80002b2:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 80002b4:	e7fe      	b.n	80002b4 <__port_exit_from_isr+0x2>
	...

080002b8 <memcpy>:
 80002b8:	4684      	mov	ip, r0
 80002ba:	ea41 0300 	orr.w	r3, r1, r0
 80002be:	f013 0303 	ands.w	r3, r3, #3
 80002c2:	d149      	bne.n	8000358 <memcpy+0xa0>
 80002c4:	3a40      	subs	r2, #64	; 0x40
 80002c6:	d323      	bcc.n	8000310 <memcpy+0x58>
 80002c8:	680b      	ldr	r3, [r1, #0]
 80002ca:	6003      	str	r3, [r0, #0]
 80002cc:	684b      	ldr	r3, [r1, #4]
 80002ce:	6043      	str	r3, [r0, #4]
 80002d0:	688b      	ldr	r3, [r1, #8]
 80002d2:	6083      	str	r3, [r0, #8]
 80002d4:	68cb      	ldr	r3, [r1, #12]
 80002d6:	60c3      	str	r3, [r0, #12]
 80002d8:	690b      	ldr	r3, [r1, #16]
 80002da:	6103      	str	r3, [r0, #16]
 80002dc:	694b      	ldr	r3, [r1, #20]
 80002de:	6143      	str	r3, [r0, #20]
 80002e0:	698b      	ldr	r3, [r1, #24]
 80002e2:	6183      	str	r3, [r0, #24]
 80002e4:	69cb      	ldr	r3, [r1, #28]
 80002e6:	61c3      	str	r3, [r0, #28]
 80002e8:	6a0b      	ldr	r3, [r1, #32]
 80002ea:	6203      	str	r3, [r0, #32]
 80002ec:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 80002ee:	6243      	str	r3, [r0, #36]	; 0x24
 80002f0:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 80002f2:	6283      	str	r3, [r0, #40]	; 0x28
 80002f4:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 80002f6:	62c3      	str	r3, [r0, #44]	; 0x2c
 80002f8:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 80002fa:	6303      	str	r3, [r0, #48]	; 0x30
 80002fc:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 80002fe:	6343      	str	r3, [r0, #52]	; 0x34
 8000300:	6b8b      	ldr	r3, [r1, #56]	; 0x38
 8000302:	6383      	str	r3, [r0, #56]	; 0x38
 8000304:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 8000306:	63c3      	str	r3, [r0, #60]	; 0x3c
 8000308:	3040      	adds	r0, #64	; 0x40
 800030a:	3140      	adds	r1, #64	; 0x40
 800030c:	3a40      	subs	r2, #64	; 0x40
 800030e:	d2db      	bcs.n	80002c8 <memcpy+0x10>
 8000310:	3230      	adds	r2, #48	; 0x30
 8000312:	d30b      	bcc.n	800032c <memcpy+0x74>
 8000314:	680b      	ldr	r3, [r1, #0]
 8000316:	6003      	str	r3, [r0, #0]
 8000318:	684b      	ldr	r3, [r1, #4]
 800031a:	6043      	str	r3, [r0, #4]
 800031c:	688b      	ldr	r3, [r1, #8]
 800031e:	6083      	str	r3, [r0, #8]
 8000320:	68cb      	ldr	r3, [r1, #12]
 8000322:	60c3      	str	r3, [r0, #12]
 8000324:	3010      	adds	r0, #16
 8000326:	3110      	adds	r1, #16
 8000328:	3a10      	subs	r2, #16
 800032a:	d2f3      	bcs.n	8000314 <memcpy+0x5c>
 800032c:	320c      	adds	r2, #12
 800032e:	d305      	bcc.n	800033c <memcpy+0x84>
 8000330:	f851 3b04 	ldr.w	r3, [r1], #4
 8000334:	f840 3b04 	str.w	r3, [r0], #4
 8000338:	3a04      	subs	r2, #4
 800033a:	d2f9      	bcs.n	8000330 <memcpy+0x78>
 800033c:	3204      	adds	r2, #4
 800033e:	d008      	beq.n	8000352 <memcpy+0x9a>
 8000340:	07d2      	lsls	r2, r2, #31
 8000342:	bf1c      	itt	ne
 8000344:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000348:	f800 3b01 	strbne.w	r3, [r0], #1
 800034c:	d301      	bcc.n	8000352 <memcpy+0x9a>
 800034e:	880b      	ldrh	r3, [r1, #0]
 8000350:	8003      	strh	r3, [r0, #0]
 8000352:	4660      	mov	r0, ip
 8000354:	4770      	bx	lr
 8000356:	bf00      	nop
 8000358:	2a08      	cmp	r2, #8
 800035a:	d313      	bcc.n	8000384 <memcpy+0xcc>
 800035c:	078b      	lsls	r3, r1, #30
 800035e:	d0b1      	beq.n	80002c4 <memcpy+0xc>
 8000360:	f010 0303 	ands.w	r3, r0, #3
 8000364:	d0ae      	beq.n	80002c4 <memcpy+0xc>
 8000366:	f1c3 0304 	rsb	r3, r3, #4
 800036a:	1ad2      	subs	r2, r2, r3
 800036c:	07db      	lsls	r3, r3, #31
 800036e:	bf1c      	itt	ne
 8000370:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000374:	f800 3b01 	strbne.w	r3, [r0], #1
 8000378:	d3a4      	bcc.n	80002c4 <memcpy+0xc>
 800037a:	f831 3b02 	ldrh.w	r3, [r1], #2
 800037e:	f820 3b02 	strh.w	r3, [r0], #2
 8000382:	e79f      	b.n	80002c4 <memcpy+0xc>
 8000384:	3a04      	subs	r2, #4
 8000386:	d3d9      	bcc.n	800033c <memcpy+0x84>
 8000388:	3a01      	subs	r2, #1
 800038a:	f811 3b01 	ldrb.w	r3, [r1], #1
 800038e:	f800 3b01 	strb.w	r3, [r0], #1
 8000392:	d2f9      	bcs.n	8000388 <memcpy+0xd0>
 8000394:	780b      	ldrb	r3, [r1, #0]
 8000396:	7003      	strb	r3, [r0, #0]
 8000398:	784b      	ldrb	r3, [r1, #1]
 800039a:	7043      	strb	r3, [r0, #1]
 800039c:	788b      	ldrb	r3, [r1, #2]
 800039e:	7083      	strb	r3, [r0, #2]
 80003a0:	4660      	mov	r0, ip
 80003a2:	4770      	bx	lr
	...

080003b0 <sdObjectInit.constprop.0>:
#if !defined(SERIAL_ADVANCED_BUFFERING_SUPPORT) ||                          \
    (SERIAL_ADVANCED_BUFFERING_SUPPORT == FALSE) ||                         \
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 80003b0:	4603      	mov	r3, r0
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 80003b2:	2201      	movs	r2, #1
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 80003b4:	b4f0      	push	{r4, r5, r6, r7}
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 80003b6:	2500      	movs	r5, #0
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 80003b8:	f44f 7780 	mov.w	r7, #256	; 0x100
  sdp->vmt = &vmt;
 80003bc:	4c11      	ldr	r4, [pc, #68]	; (8000404 <sdObjectInit.constprop.0+0x54>)
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 80003be:	f500 7615 	add.w	r6, r0, #596	; 0x254
 80003c2:	f843 4b04 	str.w	r4, [r3], #4
 */
void chEvtObjectInit(event_source_t *esp) {

  chDbgCheck(esp != NULL);

  esp->next = (event_listener_t *)esp;
 80003c6:	6043      	str	r3, [r0, #4]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 80003c8:	f100 040c 	add.w	r4, r0, #12
  iqp->q_top     = bp + size;
 80003cc:	f500 73aa 	add.w	r3, r0, #340	; 0x154
  oqp->q_notify  = onfy;
 80003d0:	64c1      	str	r1, [r0, #76]	; 0x4c
  sdp->state = SD_STOP;
 80003d2:	7202      	strb	r2, [r0, #8]
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 80003d4:	f100 0130 	add.w	r1, r0, #48	; 0x30
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 80003d8:	f100 0254 	add.w	r2, r0, #84	; 0x54
  iqp->q_counter = 0;
 80003dc:	6145      	str	r5, [r0, #20]
 * @notapi
 */
static inline void ch_queue_init(ch_queue_t *qp) {

  qp->next = qp;
  qp->prev = qp;
 80003de:	e9c0 4403 	strd	r4, r4, [r0, #12]
  iqp->q_notify  = infy;
 80003e2:	6285      	str	r5, [r0, #40]	; 0x28
  oqp->q_counter = size;
 80003e4:	6387      	str	r7, [r0, #56]	; 0x38
  oqp->q_top     = bp + size;
 80003e6:	6406      	str	r6, [r0, #64]	; 0x40
  iqp->q_wrptr   = bp;
 80003e8:	e9c0 2208 	strd	r2, r2, [r0, #32]
}
 80003ec:	bcf0      	pop	{r4, r5, r6, r7}
  oqp->q_wrptr   = bp;
 80003ee:	e9c0 3311 	strd	r3, r3, [r0, #68]	; 0x44
 80003f2:	e9c0 110c 	strd	r1, r1, [r0, #48]	; 0x30
  iqp->q_link    = link;
 80003f6:	62c0      	str	r0, [r0, #44]	; 0x2c
  oqp->q_link    = link;
 80003f8:	6500      	str	r0, [r0, #80]	; 0x50
  iqp->q_buffer  = bp;
 80003fa:	6182      	str	r2, [r0, #24]
  iqp->q_top     = bp + size;
 80003fc:	61c3      	str	r3, [r0, #28]
  oqp->q_buffer  = bp;
 80003fe:	63c3      	str	r3, [r0, #60]	; 0x3c
 8000400:	4770      	bx	lr
 8000402:	bf00      	nop
 8000404:	08001f48 	.word	0x08001f48
	...

08000410 <gpio_init.constprop.0>:
                one or more parameters can be selected which are shown as below:
      \arg        GPIO_PIN_x(x=0..15), GPIO_PIN_ALL
    \param[out] none
    \retval     none
*/
void gpio_init(uint32_t gpio_periph, uint32_t mode, uint32_t speed, uint32_t pin)
 8000410:	b4f0      	push	{r4, r5, r6, r7}

    /* GPIO mode configuration */
    temp_mode = (uint32_t)(mode & ((uint32_t)0x0FU));
    
    /* GPIO speed configuration */
    if(((uint32_t)0x00U) != ((uint32_t)mode & ((uint32_t)0x10U))){
 8000412:	06cb      	lsls	r3, r1, #27
        }
    }

    /* configure the eight low port pins with GPIO_CTL0 */
    for(i = 0U;i < 8U;i++){
        if((1U << i) & pin){
 8000414:	f04f 0601 	mov.w	r6, #1
void gpio_init(uint32_t gpio_periph, uint32_t mode, uint32_t speed, uint32_t pin)
 8000418:	f04f 0300 	mov.w	r3, #0
            reg = GPIO_CTL0(gpio_periph);
            
            /* clear the specified pin mode bits */
            reg &= ~GPIO_MODE_MASK(i);
 800041c:	f04f 0c0f 	mov.w	ip, #15
    temp_mode = (uint32_t)(mode & ((uint32_t)0x0FU));
 8000420:	f001 050f 	and.w	r5, r1, #15
            temp_mode |= (uint32_t)speed;
 8000424:	bf48      	it	mi
 8000426:	f045 0503 	orrmi.w	r5, r5, #3
        if((1U << i) & pin){
 800042a:	fa06 f103 	lsl.w	r1, r6, r3
 800042e:	4211      	tst	r1, r2
 8000430:	d009      	beq.n	8000446 <gpio_init.constprop.0+0x36>
            reg = GPIO_CTL0(gpio_periph);
 8000432:	6804      	ldr	r4, [r0, #0]
 8000434:	0099      	lsls	r1, r3, #2
            reg &= ~GPIO_MODE_MASK(i);
 8000436:	fa0c f701 	lsl.w	r7, ip, r1
 800043a:	ea24 0407 	bic.w	r4, r4, r7
            /* set the specified pin mode bits */
            reg |= GPIO_MODE_SET(i, temp_mode);
 800043e:	fa05 f101 	lsl.w	r1, r5, r1
 8000442:	4321      	orrs	r1, r4
                if(GPIO_MODE_IPU == mode){
                    GPIO_BOP(gpio_periph) = (uint32_t)((1U << i) & pin);
                }
            }
            /* set GPIO_CTL0 register */
            GPIO_CTL0(gpio_periph) = reg;
 8000444:	6001      	str	r1, [r0, #0]
 8000446:	3301      	adds	r3, #1
    for(i = 0U;i < 8U;i++){
 8000448:	2b08      	cmp	r3, #8
 800044a:	d1ee      	bne.n	800042a <gpio_init.constprop.0+0x1a>
        }
    }
    /* configure the eight high port pins with GPIO_CTL1 */
    for(i = 8U;i < 16U;i++){
        if((1U << i) & pin){
 800044c:	2601      	movs	r6, #1
            reg = GPIO_CTL1(gpio_periph);
            
            /* clear the specified pin mode bits */
            reg &= ~GPIO_MODE_MASK(i - 8U);
 800044e:	f04f 0c0f 	mov.w	ip, #15
        if((1U << i) & pin){
 8000452:	fa06 f103 	lsl.w	r1, r6, r3
 8000456:	4211      	tst	r1, r2
 8000458:	d00a      	beq.n	8000470 <gpio_init.constprop.0+0x60>
            reg &= ~GPIO_MODE_MASK(i - 8U);
 800045a:	0099      	lsls	r1, r3, #2
            reg = GPIO_CTL1(gpio_periph);
 800045c:	6844      	ldr	r4, [r0, #4]
            reg &= ~GPIO_MODE_MASK(i - 8U);
 800045e:	3920      	subs	r1, #32
 8000460:	fa0c f701 	lsl.w	r7, ip, r1
 8000464:	ea24 0407 	bic.w	r4, r4, r7
            /* set the specified pin mode bits */
            reg |= GPIO_MODE_SET(i - 8U, temp_mode);
 8000468:	fa05 f101 	lsl.w	r1, r5, r1
 800046c:	4321      	orrs	r1, r4
                if(GPIO_MODE_IPU == mode){
                    GPIO_BOP(gpio_periph) = (uint32_t)((1U << i) & pin);
                }
            }
            /* set GPIO_CTL1 register */
            GPIO_CTL1(gpio_periph) = reg;
 800046e:	6041      	str	r1, [r0, #4]
 8000470:	3301      	adds	r3, #1
    for(i = 8U;i < 16U;i++){
 8000472:	2b10      	cmp	r3, #16
 8000474:	d1ed      	bne.n	8000452 <gpio_init.constprop.0+0x42>
        }
    }
}
 8000476:	bcf0      	pop	{r4, r5, r6, r7}
 8000478:	4770      	bx	lr
 800047a:	bf00      	nop
 800047c:	0000      	movs	r0, r0
	...

08000480 <__idle_thread>:
 __STATIC_FORCEINLINE void port_wait_for_interrupt(void) {

 #if CORTEX_ENABLE_WFI_IDLE == TRUE
   __WFI();
 #endif
 }
 8000480:	e7fe      	b.n	8000480 <__idle_thread>
 8000482:	bf00      	nop
	...

08000490 <chCoreAllocFromTop>:
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000490:	2320      	movs	r3, #32
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
 8000492:	b430      	push	{r4, r5}
 8000494:	f383 8811 	msr	BASEPRI, r3
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8000498:	4b0b      	ldr	r3, [pc, #44]	; (80004c8 <chCoreAllocFromTop+0x38>)
 800049a:	4249      	negs	r1, r1
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 800049c:	e9d3 4500 	ldrd	r4, r5, [r3]
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 80004a0:	1a28      	subs	r0, r5, r0
 80004a2:	4008      	ands	r0, r1
  prev = p - offset;
 80004a4:	1a82      	subs	r2, r0, r2
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 80004a6:	42a2      	cmp	r2, r4
 80004a8:	d307      	bcc.n	80004ba <chCoreAllocFromTop+0x2a>
 80004aa:	4295      	cmp	r5, r2
 80004ac:	d305      	bcc.n	80004ba <chCoreAllocFromTop+0x2a>
  ch_memcore.topmem = prev;
 80004ae:	605a      	str	r2, [r3, #4]
 80004b0:	2300      	movs	r3, #0
 80004b2:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
 80004b6:	bc30      	pop	{r4, r5}
 80004b8:	4770      	bx	lr
    return NULL;
 80004ba:	2000      	movs	r0, #0
 80004bc:	2300      	movs	r3, #0
 80004be:	f383 8811 	msr	BASEPRI, r3
}
 80004c2:	bc30      	pop	{r4, r5}
 80004c4:	4770      	bx	lr
 80004c6:	bf00      	nop
 80004c8:	20000f68 	.word	0x20000f68
 80004cc:	00000000 	.word	0x00000000

080004d0 <notify3>:

#if STM32_SERIAL_USE_USART3 || defined(__DOXYGEN__)
static void notify3(io_queue_t *qp) {

  (void)qp;
  USART_CTL0(UART3) |= 0x80;
 80004d0:	4a02      	ldr	r2, [pc, #8]	; (80004dc <notify3+0xc>)
 80004d2:	6813      	ldr	r3, [r2, #0]
 80004d4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80004d8:	6013      	str	r3, [r2, #0]
}
 80004da:	4770      	bx	lr
 80004dc:	40004c0c 	.word	0x40004c0c

080004e0 <notify4>:

#if STM32_SERIAL_USE_UART4 || defined(__DOXYGEN__)
static void notify4(io_queue_t *qp) {

  (void)qp;
  USART_CTL0(UART4) |= 0x80;
 80004e0:	4a02      	ldr	r2, [pc, #8]	; (80004ec <notify4+0xc>)
 80004e2:	6813      	ldr	r3, [r2, #0]
 80004e4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80004e8:	6013      	str	r3, [r2, #0]
}
 80004ea:	4770      	bx	lr
 80004ec:	4000500c 	.word	0x4000500c

080004f0 <rcu_clock_freq_get>:
      \arg        CK_USART: USART5 clock frequency
    \param[out] none
    \retval     clock frequency of system, AHB, APB1, APB2
*/
uint32_t rcu_clock_freq_get(rcu_clock_freq_enum clock)
{
 80004f0:	b430      	push	{r4, r5}
#if defined(GD32E50X_CL) || defined(GD32EPRT) || defined(GD32E508)
    uint32_t predv0, predv1, pll1mf;
#endif /* GD32E50X_CL and GD32EPRT and GD32E508*/

    /* exponent of AHB, APB1 and APB2 clock divider */
    uint8_t ahb_exp[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
 80004f2:	4c54      	ldr	r4, [pc, #336]	; (8000644 <rcu_clock_freq_get+0x154>)
{
 80004f4:	b088      	sub	sp, #32
    uint8_t ahb_exp[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
 80004f6:	f10d 0c20 	add.w	ip, sp, #32
{
 80004fa:	4605      	mov	r5, r0
    uint8_t ahb_exp[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
 80004fc:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 8000500:	e90c 000f 	stmdb	ip, {r0, r1, r2, r3}
    uint8_t apb1_exp[8] = {0, 0, 0, 0, 1, 2, 3, 4};
    uint8_t apb2_exp[8] = {0, 0, 0, 0, 1, 2, 3, 4};
 8000504:	466b      	mov	r3, sp
    uint8_t apb1_exp[8] = {0, 0, 0, 0, 1, 2, 3, 4};
 8000506:	aa02      	add	r2, sp, #8
 8000508:	3410      	adds	r4, #16
 800050a:	e894 0003 	ldmia.w	r4, {r0, r1}
    uint8_t apb2_exp[8] = {0, 0, 0, 0, 1, 2, 3, 4};
 800050e:	e883 0003 	stmia.w	r3, {r0, r1}
    uint8_t apb1_exp[8] = {0, 0, 0, 0, 1, 2, 3, 4};
 8000512:	e882 0003 	stmia.w	r2, {r0, r1}

    sws = GET_BITS(RCU_CFG0, 2, 3);
 8000516:	4b4c      	ldr	r3, [pc, #304]	; (8000648 <rcu_clock_freq_get+0x158>)
 8000518:	681a      	ldr	r2, [r3, #0]
 800051a:	f3c2 0281 	ubfx	r2, r2, #2, #2
    switch(sws){
 800051e:	2a01      	cmp	r2, #1
 8000520:	d070      	beq.n	8000604 <rcu_clock_freq_get+0x114>
 8000522:	2a02      	cmp	r2, #2
 8000524:	d136      	bne.n	8000594 <rcu_clock_freq_get+0xa4>
        cksys_freq = HXTAL_VALUE;
        break;
    /* PLL is selected as CK_SYS */
    case SEL_PLL:
        /* PLL clock source selection, HXTAL, IRC48M or IRC8M/2 */
        pllsel = (RCU_CFG0 & RCU_CFG0_PLLSEL);
 8000526:	681b      	ldr	r3, [r3, #0]

        if(RCU_PLLSRC_HXTAL_IRC48M == pllsel) {
 8000528:	03db      	lsls	r3, r3, #15
 800052a:	d570      	bpl.n	800060e <rcu_clock_freq_get+0x11e>
            /* PLL clock source is HXTAL or IRC48M */
            pllpresel = (RCU_CFG1 & RCU_CFG1_PLLPRESEL);
 800052c:	4b47      	ldr	r3, [pc, #284]	; (800064c <rcu_clock_freq_get+0x15c>)
            if(RCU_PLLPRESRC_HXTAL == pllpresel){
                /* PLL clock source is HXTAL */
                ck_src = HXTAL_VALUE;
            }else{
                /* PLL clock source is IRC48 */
                ck_src = IRC48M_VALUE;
 800052e:	4948      	ldr	r1, [pc, #288]	; (8000650 <rcu_clock_freq_get+0x160>)
            pllpresel = (RCU_CFG1 & RCU_CFG1_PLLPRESEL);
 8000530:	681c      	ldr	r4, [r3, #0]
            /* PREDV0 input source clock divided by 2 */
            if(RCU_CFG0_PREDV0 == predv0sel){
                ck_src = HXTAL_VALUE/2U;
            }
#elif defined(GD32E50X_CL) || defined(GD32EPRT) || defined(GD32E508)
            predv0sel = (RCU_CFG1 & RCU_CFG1_PREDV0SEL);
 8000532:	681a      	ldr	r2, [r3, #0]
                ck_src = IRC48M_VALUE;
 8000534:	f014 4f80 	tst.w	r4, #1073741824	; 0x40000000
 8000538:	4846      	ldr	r0, [pc, #280]	; (8000654 <rcu_clock_freq_get+0x164>)
 800053a:	bf18      	it	ne
 800053c:	4608      	movne	r0, r1
            /* source clock use PLL1 */
            if(RCU_PREDV0SRC_CKPLL1 == predv0sel){
 800053e:	03d4      	lsls	r4, r2, #15
 8000540:	d510      	bpl.n	8000564 <rcu_clock_freq_get+0x74>
                predv1 = ((RCU_CFG1 & RCU_CFG1_PREDV1) >> RCU_CFG1_PREDV1_OFFSET) + 1U;
 8000542:	681a      	ldr	r2, [r3, #0]
                pll1mf = (uint32_t)((RCU_CFG1 & RCU_CFG1_PLL1MF) >> RCU_CFG1_PLL1MF_OFFSET) + 2U;
 8000544:	681b      	ldr	r3, [r3, #0]
                predv1 = ((RCU_CFG1 & RCU_CFG1_PREDV1) >> RCU_CFG1_PREDV1_OFFSET) + 1U;
 8000546:	f3c2 1203 	ubfx	r2, r2, #4, #4
                pll1mf = (uint32_t)((RCU_CFG1 & RCU_CFG1_PLL1MF) >> RCU_CFG1_PLL1MF_OFFSET) + 2U;
 800054a:	f3c3 2303 	ubfx	r3, r3, #8, #4
                if(17U == pll1mf){
                    pll1mf = 20U;
 800054e:	2b0f      	cmp	r3, #15
                predv1 = ((RCU_CFG1 & RCU_CFG1_PREDV1) >> RCU_CFG1_PREDV1_OFFSET) + 1U;
 8000550:	f102 0201 	add.w	r2, r2, #1
                pll1mf = (uint32_t)((RCU_CFG1 & RCU_CFG1_PLL1MF) >> RCU_CFG1_PLL1MF_OFFSET) + 2U;
 8000554:	f103 0302 	add.w	r3, r3, #2
                }
                ck_src = (ck_src/predv1)*pll1mf;
 8000558:	fbb0 f0f2 	udiv	r0, r0, r2
                    pll1mf = 20U;
 800055c:	bf08      	it	eq
 800055e:	2314      	moveq	r3, #20
                ck_src = (ck_src/predv1)*pll1mf;
 8000560:	fb03 f000 	mul.w	r0, r3, r0
            }
            predv0 = (RCU_CFG1 & RCU_CFG1_PREDV0) + 1U;
 8000564:	4b39      	ldr	r3, [pc, #228]	; (800064c <rcu_clock_freq_get+0x15c>)
 8000566:	681b      	ldr	r3, [r3, #0]
 8000568:	f003 030f 	and.w	r3, r3, #15
 800056c:	3301      	adds	r3, #1
            ck_src /= predv0;
 800056e:	fbb0 f0f3 	udiv	r0, r0, r3
            /* PLL clock source is IRC8M/2 */
            ck_src = IRC8M_VALUE/2U;
        }

        /* PLL multiplication factor */
        pllmf = GET_BITS(RCU_CFG0, 18, 21);
 8000572:	4a35      	ldr	r2, [pc, #212]	; (8000648 <rcu_clock_freq_get+0x158>)
 8000574:	6813      	ldr	r3, [r2, #0]
        if((RCU_CFG0 & RCU_CFG0_PLLMF_4)){
 8000576:	6811      	ldr	r1, [r2, #0]
        pllmf = GET_BITS(RCU_CFG0, 18, 21);
 8000578:	f3c3 4383 	ubfx	r3, r3, #18, #4
        if((RCU_CFG0 & RCU_CFG0_PLLMF_4)){
 800057c:	0089      	lsls	r1, r1, #2
            pllmf |= 0x10U;
        }
        if((RCU_CFG0 & RCU_CFG0_PLLMF_5)){
 800057e:	6812      	ldr	r2, [r2, #0]
        if((RCU_CFG0 & RCU_CFG0_PLLMF_4)){
 8000580:	d547      	bpl.n	8000612 <rcu_clock_freq_get+0x122>
        if((RCU_CFG0 & RCU_CFG0_PLLMF_5)){
 8000582:	0054      	lsls	r4, r2, #1
            pllmf |= 0x10U;
 8000584:	f043 0310 	orr.w	r3, r3, #16
        if((RCU_CFG0 & RCU_CFG0_PLLMF_5)){
 8000588:	d501      	bpl.n	800058e <rcu_clock_freq_get+0x9e>
            pllmf |= 0x20U;
 800058a:	f043 0320 	orr.w	r3, r3, #32
        if(pllmf < 15U){
            pllmf += 2U;
        }else if((pllmf >= 15U) && (pllmf <= 64U)){
            pllmf += 1U;
        }
        cksys_freq = ck_src*pllmf;
 800058e:	fb03 0000 	mla	r0, r3, r0, r0
#if defined(GD32E50X_CL) || defined(GD32EPRT) || defined(GD32E508)
        if(15U == pllmf){
 8000592:	e000      	b.n	8000596 <rcu_clock_freq_get+0xa6>
        cksys_freq = IRC8M_VALUE;
 8000594:	4830      	ldr	r0, [pc, #192]	; (8000658 <rcu_clock_freq_get+0x168>)
        cksys_freq = IRC8M_VALUE;
        break;
    }

    /* calculate AHB clock frequency */
    idx = GET_BITS(RCU_CFG0, 4, 7);
 8000596:	492c      	ldr	r1, [pc, #176]	; (8000648 <rcu_clock_freq_get+0x158>)
 8000598:	1e6b      	subs	r3, r5, #1
 800059a:	680c      	ldr	r4, [r1, #0]
    clk_exp = ahb_exp[idx];
 800059c:	ad08      	add	r5, sp, #32
    ahb_freq = cksys_freq >> clk_exp;
    
    /* calculate APB1 clock frequency */
    idx = GET_BITS(RCU_CFG0, 8, 10);
 800059e:	680a      	ldr	r2, [r1, #0]
    idx = GET_BITS(RCU_CFG0, 4, 7);
 80005a0:	f3c4 1403 	ubfx	r4, r4, #4, #4
    clk_exp = apb1_exp[idx];
    apb1_freq = ahb_freq >> clk_exp;
    
    /* calculate APB2 clock frequency */
    idx = GET_BITS(RCU_CFG0, 11, 13);
 80005a4:	6809      	ldr	r1, [r1, #0]
    clk_exp = ahb_exp[idx];
 80005a6:	442c      	add	r4, r5
 80005a8:	f814 4c10 	ldrb.w	r4, [r4, #-16]
    idx = GET_BITS(RCU_CFG0, 11, 13);
 80005ac:	f3c1 21c2 	ubfx	r1, r1, #11, #3
    clk_exp = apb2_exp[idx];
 80005b0:	4429      	add	r1, r5
 80005b2:	f811 5c20 	ldrb.w	r5, [r1, #-32]
    idx = GET_BITS(RCU_CFG0, 8, 10);
 80005b6:	f3c2 2202 	ubfx	r2, r2, #8, #3
    ahb_freq = cksys_freq >> clk_exp;
 80005ba:	fa20 f104 	lsr.w	r1, r0, r4
    clk_exp = apb1_exp[idx];
 80005be:	ac08      	add	r4, sp, #32
 80005c0:	4422      	add	r2, r4
 80005c2:	f812 2c18 	ldrb.w	r2, [r2, #-24]
    apb2_freq = ahb_freq >> clk_exp;
 80005c6:	fa21 f505 	lsr.w	r5, r1, r5
    
    /* return the clocks frequency */
    switch(clock){
 80005ca:	2b03      	cmp	r3, #3
 80005cc:	d813      	bhi.n	80005f6 <rcu_clock_freq_get+0x106>
 80005ce:	e8df f003 	tbb	[pc, r3]
 80005d2:	1b17      	.short	0x1b17
 80005d4:	0215      	.short	0x0215
    case CK_APB2:
        ck_freq = apb2_freq;
        break;
    case CK_USART:
        /* calculate USART5 clock frequency */
        if(RCU_USART5SRC_CKAPB2 == (RCU_CFG2 & RCU_CFG2_USART5SEL)){
 80005d6:	4b21      	ldr	r3, [pc, #132]	; (800065c <rcu_clock_freq_get+0x16c>)
 80005d8:	681a      	ldr	r2, [r3, #0]
 80005da:	0792      	lsls	r2, r2, #30
 80005dc:	d00e      	beq.n	80005fc <rcu_clock_freq_get+0x10c>
            usart_freq = apb2_freq;
        }else if(RCU_USART5SRC_CKSYS == (RCU_CFG2 & RCU_CFG2_USART5SEL)){
 80005de:	681a      	ldr	r2, [r3, #0]
 80005e0:	f002 0203 	and.w	r2, r2, #3
 80005e4:	2a01      	cmp	r2, #1
 80005e6:	d006      	beq.n	80005f6 <rcu_clock_freq_get+0x106>
            usart_freq = cksys_freq;
        }else if(RCU_USART5SRC_LXTAL == (RCU_CFG2 & RCU_CFG2_USART5SEL)){
 80005e8:	681a      	ldr	r2, [r3, #0]
 80005ea:	f002 0203 	and.w	r2, r2, #3
 80005ee:	2a02      	cmp	r2, #2
 80005f0:	d11f      	bne.n	8000632 <rcu_clock_freq_get+0x142>
            usart_freq = LXTAL_VALUE;
 80005f2:	f44f 4000 	mov.w	r0, #32768	; 0x8000
        break;
    default:
        break;
    }
    return ck_freq;
}
 80005f6:	b008      	add	sp, #32
 80005f8:	bc30      	pop	{r4, r5}
 80005fa:	4770      	bx	lr
            usart_freq = apb2_freq;
 80005fc:	4628      	mov	r0, r5
 80005fe:	e7fa      	b.n	80005f6 <rcu_clock_freq_get+0x106>
    apb2_freq = ahb_freq >> clk_exp;
 8000600:	4608      	mov	r0, r1
 8000602:	e7f8      	b.n	80005f6 <rcu_clock_freq_get+0x106>
    switch(sws){
 8000604:	4813      	ldr	r0, [pc, #76]	; (8000654 <rcu_clock_freq_get+0x164>)
 8000606:	e7c6      	b.n	8000596 <rcu_clock_freq_get+0xa6>
    apb1_freq = ahb_freq >> clk_exp;
 8000608:	fa21 f002 	lsr.w	r0, r1, r2
        break;
 800060c:	e7f3      	b.n	80005f6 <rcu_clock_freq_get+0x106>
            ck_src = IRC8M_VALUE/2U;
 800060e:	4814      	ldr	r0, [pc, #80]	; (8000660 <rcu_clock_freq_get+0x170>)
 8000610:	e7af      	b.n	8000572 <rcu_clock_freq_get+0x82>
        if((RCU_CFG0 & RCU_CFG0_PLLMF_5)){
 8000612:	0051      	lsls	r1, r2, #1
 8000614:	d4b9      	bmi.n	800058a <rcu_clock_freq_get+0x9a>
        if(pllmf < 15U){
 8000616:	2b0f      	cmp	r3, #15
 8000618:	d0b9      	beq.n	800058e <rcu_clock_freq_get+0x9e>
        if(15U == pllmf){
 800061a:	2b0d      	cmp	r3, #13
            pllmf += 2U;
 800061c:	f103 0202 	add.w	r2, r3, #2
        if(15U == pllmf){
 8000620:	d104      	bne.n	800062c <rcu_clock_freq_get+0x13c>
            cksys_freq = ck_src*6U + ck_src/2U;
 8000622:	2206      	movs	r2, #6
 8000624:	0843      	lsrs	r3, r0, #1
 8000626:	fb02 3000 	mla	r0, r2, r0, r3
 800062a:	e7b4      	b.n	8000596 <rcu_clock_freq_get+0xa6>
        cksys_freq = ck_src*pllmf;
 800062c:	fb02 f000 	mul.w	r0, r2, r0
 8000630:	e7b1      	b.n	8000596 <rcu_clock_freq_get+0xa6>
        }else if(RCU_USART5SRC_IRC8M == (RCU_CFG2 & RCU_CFG2_USART5SEL)){
 8000632:	681b      	ldr	r3, [r3, #0]
            usart_freq = IRC8M_VALUE;
 8000634:	4808      	ldr	r0, [pc, #32]	; (8000658 <rcu_clock_freq_get+0x168>)
        }else if(RCU_USART5SRC_IRC8M == (RCU_CFG2 & RCU_CFG2_USART5SEL)){
 8000636:	f003 0303 	and.w	r3, r3, #3
            usart_freq = IRC8M_VALUE;
 800063a:	2b03      	cmp	r3, #3
 800063c:	bf18      	it	ne
 800063e:	2000      	movne	r0, #0
 8000640:	e7d9      	b.n	80005f6 <rcu_clock_freq_get+0x106>
 8000642:	bf00      	nop
 8000644:	08001e44 	.word	0x08001e44
 8000648:	40021004 	.word	0x40021004
 800064c:	4002102c 	.word	0x4002102c
 8000650:	02dc6c00 	.word	0x02dc6c00
 8000654:	017d7840 	.word	0x017d7840
 8000658:	007a1200 	.word	0x007a1200
 800065c:	400210d4 	.word	0x400210d4
 8000660:	003d0900 	.word	0x003d0900
	...

08000670 <rcu_periph_clock_enable>:
    RCU_REG_VAL(periph) |= BIT(RCU_BIT_POS(periph));
 8000670:	2201      	movs	r2, #1
 8000672:	0983      	lsrs	r3, r0, #6
 8000674:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8000678:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 800067c:	6819      	ldr	r1, [r3, #0]
 800067e:	f000 001f 	and.w	r0, r0, #31
 8000682:	fa02 f000 	lsl.w	r0, r2, r0
 8000686:	4308      	orrs	r0, r1
 8000688:	6018      	str	r0, [r3, #0]
}
 800068a:	4770      	bx	lr
 800068c:	0000      	movs	r0, r0
	...

08000690 <__port_irq_epilogue>:
 8000690:	2320      	movs	r3, #32
 8000692:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to @p __port_switch_from_isr().
 */
void __port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8000696:	4b0d      	ldr	r3, [pc, #52]	; (80006cc <__port_irq_epilogue+0x3c>)
 8000698:	685b      	ldr	r3, [r3, #4]
 800069a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800069e:	d102      	bne.n	80006a6 <__port_irq_epilogue+0x16>
 80006a0:	f383 8811 	msr	BASEPRI, r3
    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
}
 80006a4:	4770      	bx	lr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80006a6:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
 80006aa:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
 80006ae:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
 80006b0:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 80006b2:	f383 8809 	msr	PSP, r3
 */
bool chSchIsPreemptionRequired(void) {
  os_instance_t *oip = currcore;
  thread_t *tp = __instance_get_currthread(oip);

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
 80006b6:	4a06      	ldr	r2, [pc, #24]	; (80006d0 <__port_irq_epilogue+0x40>)
 80006b8:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = tp->hdr.pqueue.prio;
 80006ba:	68d2      	ldr	r2, [r2, #12]
    if (chSchIsPreemptionRequired()) {
 80006bc:	6889      	ldr	r1, [r1, #8]
 80006be:	6892      	ldr	r2, [r2, #8]
 80006c0:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)__port_switch_from_isr;
 80006c2:	bf8c      	ite	hi
 80006c4:	4a03      	ldrhi	r2, [pc, #12]	; (80006d4 <__port_irq_epilogue+0x44>)
      ectxp->pc = (uint32_t)__port_exit_from_isr;
 80006c6:	4a04      	ldrls	r2, [pc, #16]	; (80006d8 <__port_irq_epilogue+0x48>)
 80006c8:	619a      	str	r2, [r3, #24]
 80006ca:	4770      	bx	lr
 80006cc:	e000ed00 	.word	0xe000ed00
 80006d0:	20000d98 	.word	0x20000d98
 80006d4:	080002af 	.word	0x080002af
 80006d8:	080002b2 	.word	0x080002b2
 80006dc:	00000000 	.word	0x00000000

080006e0 <chCoreAllocAlignedI>:
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 80006e0:	4b08      	ldr	r3, [pc, #32]	; (8000704 <chCoreAllocAlignedI+0x24>)
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 80006e2:	b410      	push	{r4}
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 80006e4:	e9d3 4200 	ldrd	r4, r2, [r3]
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 80006e8:	4249      	negs	r1, r1
 80006ea:	1a10      	subs	r0, r2, r0
 80006ec:	4008      	ands	r0, r1
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 80006ee:	42a0      	cmp	r0, r4
 80006f0:	d304      	bcc.n	80006fc <chCoreAllocAlignedI+0x1c>
 80006f2:	4282      	cmp	r2, r0
 80006f4:	d302      	bcc.n	80006fc <chCoreAllocAlignedI+0x1c>

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
}
 80006f6:	bc10      	pop	{r4}
  ch_memcore.topmem = prev;
 80006f8:	6058      	str	r0, [r3, #4]
 80006fa:	4770      	bx	lr
    return NULL;
 80006fc:	2000      	movs	r0, #0
 80006fe:	bc10      	pop	{r4}
 8000700:	4770      	bx	lr
 8000702:	bf00      	nop
 8000704:	20000f68 	.word	0x20000f68
	...

08000710 <chTMStopMeasurementX>:
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch_system.tmc.offset);
 8000710:	4a0e      	ldr	r2, [pc, #56]	; (800074c <chTMStopMeasurementX+0x3c>)
  *
  * @return              The realtime counter value.
  */
 __STATIC_FORCEINLINE rtcnt_t port_rt_get_counter_value(void) {

   return DWT->CYCCNT;
 8000712:	4b0f      	ldr	r3, [pc, #60]	; (8000750 <chTMStopMeasurementX+0x40>)
 8000714:	6891      	ldr	r1, [r2, #8]
 8000716:	685b      	ldr	r3, [r3, #4]
  tmp->last = (now - tmp->last) - offset;
 8000718:	6882      	ldr	r2, [r0, #8]
 800071a:	1a5b      	subs	r3, r3, r1
 800071c:	1a9b      	subs	r3, r3, r2
  tmp->n++;
 800071e:	68c2      	ldr	r2, [r0, #12]
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8000720:	b430      	push	{r4, r5}
  tmp->cumulative += (rttime_t)tmp->last;
 8000722:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
  if (tmp->last > tmp->worst) {
 8000726:	6841      	ldr	r1, [r0, #4]
  tmp->n++;
 8000728:	3201      	adds	r2, #1
  tmp->cumulative += (rttime_t)tmp->last;
 800072a:	18e4      	adds	r4, r4, r3
  tmp->last = (now - tmp->last) - offset;
 800072c:	e9c0 3202 	strd	r3, r2, [r0, #8]
  if (tmp->last < tmp->best) {
 8000730:	6802      	ldr	r2, [r0, #0]
  tmp->cumulative += (rttime_t)tmp->last;
 8000732:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
 8000736:	428b      	cmp	r3, r1
    tmp->worst = tmp->last;
 8000738:	bf88      	it	hi
 800073a:	6043      	strhi	r3, [r0, #4]
  if (tmp->last < tmp->best) {
 800073c:	4293      	cmp	r3, r2
  tmp->cumulative += (rttime_t)tmp->last;
 800073e:	e9c0 4504 	strd	r4, r5, [r0, #16]
}
 8000742:	bc30      	pop	{r4, r5}
    tmp->best = tmp->last;
 8000744:	bf38      	it	cc
 8000746:	6003      	strcc	r3, [r0, #0]
}
 8000748:	4770      	bx	lr
 800074a:	bf00      	nop
 800074c:	20000f70 	.word	0x20000f70
 8000750:	e0001000 	.word	0xe0001000
	...

08000760 <chTMStartMeasurementX>:
 8000760:	4b01      	ldr	r3, [pc, #4]	; (8000768 <chTMStartMeasurementX+0x8>)
 8000762:	685b      	ldr	r3, [r3, #4]
  tmp->last = chSysGetRealtimeCounterX();
 8000764:	6083      	str	r3, [r0, #8]
}
 8000766:	4770      	bx	lr
 8000768:	e0001000 	.word	0xe0001000
 800076c:	00000000 	.word	0x00000000

08000770 <_ctl>:
  switch (operation) {
 8000770:	2901      	cmp	r1, #1
 8000772:	d006      	beq.n	8000782 <_ctl+0x12>
 8000774:	2906      	cmp	r1, #6
 8000776:	d101      	bne.n	800077c <_ctl+0xc>
    return sdp->iqueue.q_counter;
 8000778:	6940      	ldr	r0, [r0, #20]
 800077a:	4770      	bx	lr
    return HAL_RET_UNKNOWN_CTL;
 800077c:	f06f 0013 	mvn.w	r0, #19
}
 8000780:	4770      	bx	lr
  switch (operation) {
 8000782:	2000      	movs	r0, #0
 8000784:	4770      	bx	lr
 8000786:	bf00      	nop
	...

08000790 <vt_insert_first.constprop.0>:

/**
 * @brief   Inserts a timer as first element in a delta list.
 * @note    This is the special case when the delta list is initially empty.
 */
static void vt_insert_first(virtual_timers_list_t *vtlp,
 8000790:	2a02      	cmp	r2, #2
 8000792:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000794:	4614      	mov	r4, r2
 8000796:	bf38      	it	cc
 8000798:	2402      	movcc	r4, #2
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t abstime) {
  TIMER_CH0CV(TIMER1) = (uint32_t)abstime;
  TIMER_INTF(TIMER1) = 0;
 800079a:	f04f 0e00 	mov.w	lr, #0
  TIMER_DMAINTEN(TIMER1) = TIMER_INT_CH0; 
 800079e:	2602      	movs	r6, #2
                            sysinterval_t delay) {
  sysinterval_t currdelta;

  /* The delta list is empty, the current time becomes the new
     delta list base time, the timer is inserted.*/
  vtlp->lasttime = now;
 80007a0:	4b14      	ldr	r3, [pc, #80]	; (80007f4 <vt_insert_first.constprop.0+0x64>)
  TIMER_CH0CV(TIMER1) = (uint32_t)abstime;
 80007a2:	4f15      	ldr	r7, [pc, #84]	; (80007f8 <vt_insert_first.constprop.0+0x68>)
static inline void ch_dlist_insert_after(ch_delta_list_t *dlhp,
                                         ch_delta_list_t *dlp,
                                         sysinterval_t delta) {

  dlp->delta      = delta;
  dlp->prev       = dlhp;
 80007a4:	f103 0510 	add.w	r5, r3, #16
 80007a8:	61d9      	str	r1, [r3, #28]
 80007aa:	6045      	str	r5, [r0, #4]
  dlp->next       = dlp->prev->next;
 80007ac:	691d      	ldr	r5, [r3, #16]
  TIMER_DMAINTEN(TIMER1) = TIMER_INT_CH0; 
 80007ae:	f8df c050 	ldr.w	ip, [pc, #80]	; 8000800 <vt_insert_first.constprop.0+0x70>
  dlp->delta      = delta;
 80007b2:	6082      	str	r2, [r0, #8]
  TIMER_INTF(TIMER1) = 0;
 80007b4:	4a11      	ldr	r2, [pc, #68]	; (80007fc <vt_insert_first.constprop.0+0x6c>)
  dlp->next       = dlp->prev->next;
 80007b6:	6005      	str	r5, [r0, #0]
  dlp->next->prev = dlp;
 80007b8:	6068      	str	r0, [r5, #4]

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 80007ba:	190d      	adds	r5, r1, r4
  TIMER_CH0CV(TIMER1) = (uint32_t)abstime;
 80007bc:	603d      	str	r5, [r7, #0]
  return (systime_t)TIMER_CNT(TIMER1);
 80007be:	3214      	adds	r2, #20
  TIMER_INTF(TIMER1) = 0;
 80007c0:	f842 ec14 	str.w	lr, [r2, #-20]
  TIMER_DMAINTEN(TIMER1) = TIMER_INT_CH0; 
 80007c4:	f8cc 6000 	str.w	r6, [ip]
  return (systime_t)TIMER_CNT(TIMER1);
 80007c8:	6815      	ldr	r5, [r2, #0]
  dlhp->next      = dlp;
 80007ca:	6118      	str	r0, [r3, #16]
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 80007cc:	1a68      	subs	r0, r5, r1
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
    if (likely(chTimeDiffX(now, newnow) < delay)) {
 80007ce:	4284      	cmp	r4, r0
 80007d0:	d902      	bls.n	80007d8 <vt_insert_first.constprop.0+0x48>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 80007d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (likely(chTimeDiffX(now, newnow) < delay)) {
 80007d4:	4629      	mov	r1, r5
 80007d6:	4605      	mov	r5, r0
    currdelta += (sysinterval_t)1;
 80007d8:	3601      	adds	r6, #1
  return systime + (systime_t)interval;
 80007da:	4431      	add	r1, r6
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t abstime) {
  TIMER_CH0CV(TIMER1) = (uint32_t)abstime;
 80007dc:	6039      	str	r1, [r7, #0]
  return (systime_t)TIMER_CNT(TIMER1);
 80007de:	6810      	ldr	r0, [r2, #0]
  return (sysinterval_t)((systime_t)(end - start));
 80007e0:	1b41      	subs	r1, r0, r5
    if (likely(chTimeDiffX(now, newnow) < delay)) {
 80007e2:	42b1      	cmp	r1, r6
 80007e4:	d2f6      	bcs.n	80007d4 <vt_insert_first.constprop.0+0x44>
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 80007e6:	2e02      	cmp	r6, #2
 80007e8:	d9f3      	bls.n	80007d2 <vt_insert_first.constprop.0+0x42>
 * @param[in] mask      fault flags to be added
 */
void chRFCUCollectFaultsI(rfcu_mask_t mask) {

#if CH_CFG_SMP_MODE == FALSE
  currcore->rfcu.mask |= mask;
 80007ea:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80007ec:	f042 0201 	orr.w	r2, r2, #1
 80007f0:	635a      	str	r2, [r3, #52]	; 0x34
}
 80007f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80007f4:	20000d98 	.word	0x20000d98
 80007f8:	40000034 	.word	0x40000034
 80007fc:	40000010 	.word	0x40000010
 8000800:	4000000c 	.word	0x4000000c
	...

08000810 <__sch_wakeup>:
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000810:	2320      	movs	r3, #32
 8000812:	f383 8811 	msr	BASEPRI, r3
  switch (tp->state) {
 8000816:	f891 3028 	ldrb.w	r3, [r1, #40]	; 0x28
 800081a:	2b0c      	cmp	r3, #12
 800081c:	d810      	bhi.n	8000840 <__sch_wakeup+0x30>
 800081e:	e8df f003 	tbb	[pc, r3]
 8000822:	0f2a      	.short	0x0f2a
 8000824:	070b260f 	.word	0x070b260f
 8000828:	0f0f0b0f 	.word	0x0f0f0b0f
 800082c:	0f0f      	.short	0x0f0f
 800082e:	0b          	.byte	0x0b
 800082f:	00          	.byte	0x00
    chSemFastSignalI(tp->u.wtsemp);
 8000830:	6aca      	ldr	r2, [r1, #44]	; 0x2c
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 8000832:	6893      	ldr	r3, [r2, #8]
 8000834:	3301      	adds	r3, #1
 8000836:	6093      	str	r3, [r2, #8]
  p->prev->next = p->next;
 8000838:	e9d1 3200 	ldrd	r3, r2, [r1]
 800083c:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 800083e:	605a      	str	r2, [r3, #4]
  tp->state = CH_STATE_READY;
 8000840:	2200      	movs	r2, #0
static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
 8000842:	b410      	push	{r4}
  tp->u.rdymsg = MSG_TIMEOUT;
 8000844:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 8000848:	698b      	ldr	r3, [r1, #24]
  } while (unlikely(pqp->prio >= p->prio));
 800084a:	6888      	ldr	r0, [r1, #8]
  tp->u.rdymsg = MSG_TIMEOUT;
 800084c:	62cc      	str	r4, [r1, #44]	; 0x2c
  tp->state = CH_STATE_READY;
 800084e:	f881 2028 	strb.w	r2, [r1, #40]	; 0x28
    pqp = pqp->next;
 8000852:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio >= p->prio));
 8000854:	689a      	ldr	r2, [r3, #8]
 8000856:	4282      	cmp	r2, r0
 8000858:	d2fb      	bcs.n	8000852 <__sch_wakeup+0x42>
  p->prev       = pqp->prev;
 800085a:	685a      	ldr	r2, [r3, #4]
 800085c:	2000      	movs	r0, #0
 800085e:	e9c1 3200 	strd	r3, r2, [r1]
  p->prev->next = p;
 8000862:	6011      	str	r1, [r2, #0]
  pqp->prev     = p;
 8000864:	6059      	str	r1, [r3, #4]
 8000866:	f380 8811 	msr	BASEPRI, r0
}
 800086a:	bc10      	pop	{r4}
 800086c:	4770      	bx	lr
    *tp->u.wttrp = NULL;
 800086e:	2200      	movs	r2, #0
 8000870:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 8000872:	601a      	str	r2, [r3, #0]
    break;
 8000874:	e7e4      	b.n	8000840 <__sch_wakeup+0x30>
 8000876:	2300      	movs	r3, #0
 8000878:	f383 8811 	msr	BASEPRI, r3
 800087c:	4770      	bx	lr
 800087e:	bf00      	nop

08000880 <chSchReadyI>:
  tp->state = CH_STATE_READY;
 8000880:	2200      	movs	r2, #0
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 8000882:	6983      	ldr	r3, [r0, #24]
  } while (unlikely(pqp->prio >= p->prio));
 8000884:	6881      	ldr	r1, [r0, #8]
  tp->state = CH_STATE_READY;
 8000886:	f880 2028 	strb.w	r2, [r0, #40]	; 0x28
    pqp = pqp->next;
 800088a:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio >= p->prio));
 800088c:	689a      	ldr	r2, [r3, #8]
 800088e:	428a      	cmp	r2, r1
 8000890:	d2fb      	bcs.n	800088a <chSchReadyI+0xa>
  p->prev       = pqp->prev;
 8000892:	685a      	ldr	r2, [r3, #4]
 8000894:	e9c0 3200 	strd	r3, r2, [r0]
  p->prev->next = p;
 8000898:	6010      	str	r0, [r2, #0]
  pqp->prev     = p;
 800089a:	6058      	str	r0, [r3, #4]
}
 800089c:	4770      	bx	lr
 800089e:	bf00      	nop

080008a0 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to an @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80008a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
 80008a2:	6804      	ldr	r4, [r0, #0]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80008a4:	42a0      	cmp	r0, r4
 80008a6:	d020      	beq.n	80008ea <chEvtBroadcastFlagsI+0x4a>
 80008a8:	4607      	mov	r7, r0
 80008aa:	460d      	mov	r5, r1
    tp->u.rdymsg = MSG_OK;
 80008ac:	2600      	movs	r6, #0
 80008ae:	e004      	b.n	80008ba <chEvtBroadcastFlagsI+0x1a>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 80008b0:	2a0b      	cmp	r2, #11
 80008b2:	d01b      	beq.n	80008ec <chEvtBroadcastFlagsI+0x4c>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
 80008b4:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 80008b6:	42a7      	cmp	r7, r4
 80008b8:	d017      	beq.n	80008ea <chEvtBroadcastFlagsI+0x4a>
        ((flags & elp->wflags) != (eventflags_t)0)) {
 80008ba:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
    elp->flags |= flags;
 80008be:	432b      	orrs	r3, r5
    if ((flags == (eventflags_t)0) ||
 80008c0:	4215      	tst	r5, r2
    elp->flags |= flags;
 80008c2:	60e3      	str	r3, [r4, #12]
    if ((flags == (eventflags_t)0) ||
 80008c4:	d0f6      	beq.n	80008b4 <chEvtBroadcastFlagsI+0x14>
  tp->epending |= events;
 80008c6:	e9d4 0301 	ldrd	r0, r3, [r4, #4]
 80008ca:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
  if (((tp->state == CH_STATE_WTOREVT) &&
 80008cc:	f890 2028 	ldrb.w	r2, [r0, #40]	; 0x28
  tp->epending |= events;
 80008d0:	430b      	orrs	r3, r1
  if (((tp->state == CH_STATE_WTOREVT) &&
 80008d2:	2a0a      	cmp	r2, #10
  tp->epending |= events;
 80008d4:	63c3      	str	r3, [r0, #60]	; 0x3c
  if (((tp->state == CH_STATE_WTOREVT) &&
 80008d6:	d1eb      	bne.n	80008b0 <chEvtBroadcastFlagsI+0x10>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 80008d8:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  if (((tp->state == CH_STATE_WTOREVT) &&
 80008da:	4213      	tst	r3, r2
 80008dc:	d0ea      	beq.n	80008b4 <chEvtBroadcastFlagsI+0x14>
    tp->u.rdymsg = MSG_OK;
 80008de:	62c6      	str	r6, [r0, #44]	; 0x2c
    (void) chSchReadyI(tp);
 80008e0:	f7ff ffce 	bl	8000880 <chSchReadyI>
    elp = elp->next;
 80008e4:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 80008e6:	42a7      	cmp	r7, r4
 80008e8:	d1e7      	bne.n	80008ba <chEvtBroadcastFlagsI+0x1a>
  }
}
 80008ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 80008ec:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
      ((tp->state == CH_STATE_WTANDEVT) &&
 80008ee:	ea32 0303 	bics.w	r3, r2, r3
 80008f2:	d1df      	bne.n	80008b4 <chEvtBroadcastFlagsI+0x14>
 80008f4:	e7f3      	b.n	80008de <chEvtBroadcastFlagsI+0x3e>
 80008f6:	bf00      	nop
	...

08000900 <sd_lld_serve_interrupt>:
    }
#endif
  }
}

void sd_lld_serve_interrupt(SerialDriver *sdp){
 8000900:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    while(USART_STAT0(sdp->uart_basic) & 0x20){
 8000904:	f8d0 3254 	ldr.w	r3, [r0, #596]	; 0x254
void sd_lld_serve_interrupt(SerialDriver *sdp){
 8000908:	4604      	mov	r4, r0
    while(USART_STAT0(sdp->uart_basic) & 0x20){
 800090a:	681a      	ldr	r2, [r3, #0]
 800090c:	0695      	lsls	r5, r2, #26
 800090e:	d541      	bpl.n	8000994 <sd_lld_serve_interrupt+0x94>
 8000910:	f04f 0820 	mov.w	r8, #32

  tp = threadref(ch_queue_fifo_remove(&tqp->queue));

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8000914:	2600      	movs	r6, #0
 8000916:	f100 070c 	add.w	r7, r0, #12

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 800091a:	f100 0904 	add.w	r9, r0, #4
 800091e:	e01f      	b.n	8000960 <sd_lld_serve_interrupt+0x60>
  if (!iqIsFullI(iqp)) {
 8000920:	e9d4 3208 	ldrd	r3, r2, [r4, #32]
 8000924:	4293      	cmp	r3, r2
 8000926:	d02c      	beq.n	8000982 <sd_lld_serve_interrupt+0x82>
    iqp->q_counter++;
 8000928:	6962      	ldr	r2, [r4, #20]
    *iqp->q_wrptr++ = b;
 800092a:	1c59      	adds	r1, r3, #1
    iqp->q_counter++;
 800092c:	3201      	adds	r2, #1
 800092e:	6162      	str	r2, [r4, #20]
    *iqp->q_wrptr++ = b;
 8000930:	6221      	str	r1, [r4, #32]
 8000932:	701d      	strb	r5, [r3, #0]
    if (iqp->q_wrptr >= iqp->q_top) {
 8000934:	e9d4 3207 	ldrd	r3, r2, [r4, #28]
 8000938:	429a      	cmp	r2, r3
 800093a:	d301      	bcc.n	8000940 <sd_lld_serve_interrupt+0x40>
      iqp->q_wrptr = iqp->q_buffer;
 800093c:	69a3      	ldr	r3, [r4, #24]
 800093e:	6223      	str	r3, [r4, #32]
  return (bool)(qp->next != qp);
 8000940:	68e0      	ldr	r0, [r4, #12]
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (ch_queue_notempty(&tqp->queue)) {
 8000942:	42b8      	cmp	r0, r7
 8000944:	d005      	beq.n	8000952 <sd_lld_serve_interrupt+0x52>
  qp->next       = p->next;
 8000946:	6803      	ldr	r3, [r0, #0]
 8000948:	60e3      	str	r3, [r4, #12]
  qp->next->prev = qp;
 800094a:	605f      	str	r7, [r3, #4]
 800094c:	62c6      	str	r6, [r0, #44]	; 0x2c
  (void) chSchReadyI(tp);
 800094e:	f7ff ff97 	bl	8000880 <chSchReadyI>
 8000952:	f386 8811 	msr	BASEPRI, r6
 8000956:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
 800095a:	681a      	ldr	r2, [r3, #0]
 800095c:	0690      	lsls	r0, r2, #26
 800095e:	d519      	bpl.n	8000994 <sd_lld_serve_interrupt+0x94>
 8000960:	f388 8811 	msr	BASEPRI, r8
      osalSysLockFromISR();
      sdIncomingDataI(sdp, USART_DATA(sdp->uart_basic) & 0xFF);
 8000964:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
 8000968:	685d      	ldr	r5, [r3, #4]
  if (iqIsEmptyI(&sdp->iqueue))
 800096a:	6963      	ldr	r3, [r4, #20]
 800096c:	b2ed      	uxtb	r5, r5
 800096e:	2b00      	cmp	r3, #0
 8000970:	d1d6      	bne.n	8000920 <sd_lld_serve_interrupt+0x20>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8000972:	2104      	movs	r1, #4
 8000974:	4648      	mov	r0, r9
 8000976:	f7ff ff93 	bl	80008a0 <chEvtBroadcastFlagsI>
  if (!iqIsFullI(iqp)) {
 800097a:	e9d4 3208 	ldrd	r3, r2, [r4, #32]
 800097e:	4293      	cmp	r3, r2
 8000980:	d1d2      	bne.n	8000928 <sd_lld_serve_interrupt+0x28>
 8000982:	6962      	ldr	r2, [r4, #20]
 8000984:	2a00      	cmp	r2, #0
 8000986:	d0cf      	beq.n	8000928 <sd_lld_serve_interrupt+0x28>
 8000988:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800098c:	4648      	mov	r0, r9
 800098e:	f7ff ff87 	bl	80008a0 <chEvtBroadcastFlagsI>
 8000992:	e7de      	b.n	8000952 <sd_lld_serve_interrupt+0x52>
      osalSysUnlockFromISR();
    }

    if(USART_CTL0(sdp->uart_basic) & 0x80){           //trans buff empty
 8000994:	68da      	ldr	r2, [r3, #12]
 8000996:	0611      	lsls	r1, r2, #24
 8000998:	d539      	bpl.n	8000a0e <sd_lld_serve_interrupt+0x10e>
      while(USART_STAT0(sdp->uart_basic) & 0x80){   
 800099a:	681b      	ldr	r3, [r3, #0]
 800099c:	061a      	lsls	r2, r3, #24
 800099e:	d536      	bpl.n	8000a0e <sd_lld_serve_interrupt+0x10e>
 80009a0:	2720      	movs	r7, #32
  tp->u.rdymsg = msg;
 80009a2:	2600      	movs	r6, #0
 80009a4:	f104 0530 	add.w	r5, r4, #48	; 0x30
 80009a8:	e01f      	b.n	80009ea <sd_lld_serve_interrupt+0xea>

  /* Queue data check.*/
  if (!oqIsEmptyI(oqp)) {
    uint8_t b;

    oqp->q_counter++;
 80009aa:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    b = *oqp->q_rdptr++;
    if (oqp->q_rdptr >= oqp->q_top) {
 80009ac:	6c20      	ldr	r0, [r4, #64]	; 0x40
    b = *oqp->q_rdptr++;
 80009ae:	1c59      	adds	r1, r3, #1
    oqp->q_counter++;
 80009b0:	3201      	adds	r2, #1
 80009b2:	63a2      	str	r2, [r4, #56]	; 0x38
    b = *oqp->q_rdptr++;
 80009b4:	64a1      	str	r1, [r4, #72]	; 0x48
    if (oqp->q_rdptr >= oqp->q_top) {
 80009b6:	4281      	cmp	r1, r0
    b = *oqp->q_rdptr++;
 80009b8:	f893 8000 	ldrb.w	r8, [r3]
    if (oqp->q_rdptr >= oqp->q_top) {
 80009bc:	d301      	bcc.n	80009c2 <sd_lld_serve_interrupt+0xc2>
      oqp->q_rdptr = oqp->q_buffer;
 80009be:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80009c0:	64a3      	str	r3, [r4, #72]	; 0x48
  return (bool)(qp->next != qp);
 80009c2:	6b20      	ldr	r0, [r4, #48]	; 0x30
 80009c4:	4285      	cmp	r5, r0
 80009c6:	d005      	beq.n	80009d4 <sd_lld_serve_interrupt+0xd4>
  qp->next       = p->next;
 80009c8:	6803      	ldr	r3, [r0, #0]
 80009ca:	6323      	str	r3, [r4, #48]	; 0x30
  qp->next->prev = qp;
 80009cc:	605d      	str	r5, [r3, #4]
 80009ce:	62c6      	str	r6, [r0, #44]	; 0x2c
  (void) chSchReadyI(tp);
 80009d0:	f7ff ff56 	bl	8000880 <chSchReadyI>
          USART_CTL0(sdp->uart_basic) &= ~ 0x80;
          osalSysUnlockFromISR();
          break;
        }

        USART_DATA(sdp->uart_basic) = b;            //发送数据
 80009d4:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
 80009d8:	f8c3 8004 	str.w	r8, [r3, #4]
 80009dc:	f386 8811 	msr	BASEPRI, r6
      while(USART_STAT0(sdp->uart_basic) & 0x80){   
 80009e0:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
 80009e4:	681b      	ldr	r3, [r3, #0]
 80009e6:	061b      	lsls	r3, r3, #24
 80009e8:	d511      	bpl.n	8000a0e <sd_lld_serve_interrupt+0x10e>
 80009ea:	f387 8811 	msr	BASEPRI, r7
  if (!oqIsEmptyI(oqp)) {
 80009ee:	e9d4 2311 	ldrd	r2, r3, [r4, #68]	; 0x44
 80009f2:	429a      	cmp	r2, r3
 80009f4:	d1d9      	bne.n	80009aa <sd_lld_serve_interrupt+0xaa>
 80009f6:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80009f8:	2a00      	cmp	r2, #0
 80009fa:	d0d6      	beq.n	80009aa <sd_lld_serve_interrupt+0xaa>
          USART_CTL0(sdp->uart_basic) &= ~ 0x80;
 80009fc:	f8d4 2254 	ldr.w	r2, [r4, #596]	; 0x254
 8000a00:	2100      	movs	r1, #0
 8000a02:	68d3      	ldr	r3, [r2, #12]
 8000a04:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8000a08:	60d3      	str	r3, [r2, #12]
 8000a0a:	f381 8811 	msr	BASEPRI, r1

        osalSysUnlockFromISR();
      }
    }
}
 8000a0e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8000a12:	bf00      	nop
	...

08000a20 <vt_set_alarm>:
  if (delay < currdelta) {
 8000a20:	2902      	cmp	r1, #2
 8000a22:	bf38      	it	cc
 8000a24:	2102      	movcc	r1, #2
static void vt_set_alarm(systime_t now, sysinterval_t delay) {
 8000a26:	b410      	push	{r4}
  TIMER_CH0CV(TIMER1) = (uint32_t)abstime;
 8000a28:	4c0e      	ldr	r4, [pc, #56]	; (8000a64 <vt_set_alarm+0x44>)
  return systime + (systime_t)interval;
 8000a2a:	1843      	adds	r3, r0, r1
  return (systime_t)TIMER_CNT(TIMER1);
 8000a2c:	4a0e      	ldr	r2, [pc, #56]	; (8000a68 <vt_set_alarm+0x48>)
  TIMER_CH0CV(TIMER1) = (uint32_t)abstime;
 8000a2e:	6023      	str	r3, [r4, #0]
  return (systime_t)TIMER_CNT(TIMER1);
 8000a30:	6813      	ldr	r3, [r2, #0]
  return (sysinterval_t)((systime_t)(end - start));
 8000a32:	1a18      	subs	r0, r3, r0
    if (likely(nowdelta < delay)) {
 8000a34:	4281      	cmp	r1, r0
 8000a36:	d901      	bls.n	8000a3c <vt_set_alarm+0x1c>
}
 8000a38:	bc10      	pop	{r4}
 8000a3a:	4770      	bx	lr
    if (likely(nowdelta < delay)) {
 8000a3c:	2102      	movs	r1, #2
    currdelta += (sysinterval_t)1;
 8000a3e:	3101      	adds	r1, #1
  return systime + (systime_t)interval;
 8000a40:	18c8      	adds	r0, r1, r3
  TIMER_CH0CV(TIMER1) = (uint32_t)abstime;
 8000a42:	6020      	str	r0, [r4, #0]
  return (systime_t)TIMER_CNT(TIMER1);
 8000a44:	6810      	ldr	r0, [r2, #0]
  return (sysinterval_t)((systime_t)(end - start));
 8000a46:	1ac3      	subs	r3, r0, r3
    if (likely(nowdelta < delay)) {
 8000a48:	428b      	cmp	r3, r1
 8000a4a:	d208      	bcs.n	8000a5e <vt_set_alarm+0x3e>
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 8000a4c:	2902      	cmp	r1, #2
 8000a4e:	d9f3      	bls.n	8000a38 <vt_set_alarm+0x18>
 8000a50:	4a06      	ldr	r2, [pc, #24]	; (8000a6c <vt_set_alarm+0x4c>)
}
 8000a52:	bc10      	pop	{r4}
 8000a54:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8000a56:	f043 0301 	orr.w	r3, r3, #1
 8000a5a:	6353      	str	r3, [r2, #52]	; 0x34
 8000a5c:	4770      	bx	lr
 8000a5e:	4603      	mov	r3, r0
 8000a60:	e7ed      	b.n	8000a3e <vt_set_alarm+0x1e>
 8000a62:	bf00      	nop
 8000a64:	40000034 	.word	0x40000034
 8000a68:	40000024 	.word	0x40000024
 8000a6c:	20000d98 	.word	0x20000d98

08000a70 <chprintf.constprop.0>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8000a70:	b40e      	push	{r1, r2, r3}
 8000a72:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c = *fmt++;
 8000a76:	4ebf      	ldr	r6, [pc, #764]	; (8000d74 <chprintf.constprop.0+0x304>)
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8000a78:	b086      	sub	sp, #24
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8000a7a:	ab10      	add	r3, sp, #64	; 0x40
 8000a7c:	4698      	mov	r8, r3
  int n = 0;
 8000a7e:	f04f 0a00 	mov.w	sl, #0
    c = *fmt++;
 8000a82:	2168      	movs	r1, #104	; 0x68
 8000a84:	4dbc      	ldr	r5, [pc, #752]	; (8000d78 <chprintf.constprop.0+0x308>)
  va_start(ap, fmt);
 8000a86:	1e74      	subs	r4, r6, #1
 8000a88:	9302      	str	r3, [sp, #8]
 8000a8a:	e00c      	b.n	8000aa6 <chprintf.constprop.0+0x36>
      streamPut(chp, (uint8_t)c);
 8000a8c:	682b      	ldr	r3, [r5, #0]
 8000a8e:	48ba      	ldr	r0, [pc, #744]	; (8000d78 <chprintf.constprop.0+0x308>)
 8000a90:	68db      	ldr	r3, [r3, #12]
      n++;
 8000a92:	4634      	mov	r4, r6
 8000a94:	f10a 0a01 	add.w	sl, sl, #1
      streamPut(chp, (uint8_t)c);
 8000a98:	4798      	blx	r3
    c = *fmt++;
 8000a9a:	4626      	mov	r6, r4
 8000a9c:	f816 1b01 	ldrb.w	r1, [r6], #1
    if (c == 0) {
 8000aa0:	2900      	cmp	r1, #0
 8000aa2:	f000 80c8 	beq.w	8000c36 <chprintf.constprop.0+0x1c6>
    if (c != '%') {
 8000aa6:	2925      	cmp	r1, #37	; 0x25
 8000aa8:	d1f0      	bne.n	8000a8c <chprintf.constprop.0+0x1c>
    if (*fmt == '-') {
 8000aaa:	7863      	ldrb	r3, [r4, #1]
 8000aac:	2b2d      	cmp	r3, #45	; 0x2d
      fmt++;
 8000aae:	bf08      	it	eq
 8000ab0:	1ca6      	addeq	r6, r4, #2
    if (*fmt == '+') {
 8000ab2:	7833      	ldrb	r3, [r6, #0]
      left_align = true;
 8000ab4:	bf0c      	ite	eq
 8000ab6:	f04f 0e01 	moveq.w	lr, #1
    left_align = false;
 8000aba:	f04f 0e00 	movne.w	lr, #0
    if (*fmt == '+') {
 8000abe:	2b2b      	cmp	r3, #43	; 0x2b
      do_sign = true;
 8000ac0:	bf05      	ittet	eq
 8000ac2:	2001      	moveq	r0, #1
 8000ac4:	7873      	ldrbeq	r3, [r6, #1]
    do_sign = false;
 8000ac6:	2000      	movne	r0, #0
      fmt++;
 8000ac8:	1836      	addeq	r6, r6, r0
    if (*fmt == '0') {
 8000aca:	2b30      	cmp	r3, #48	; 0x30
      filler = '0';
 8000acc:	bf05      	ittet	eq
 8000ace:	461f      	moveq	r7, r3
      fmt++;
 8000ad0:	7873      	ldrbeq	r3, [r6, #1]
    filler = ' ';
 8000ad2:	2720      	movne	r7, #32
      fmt++;
 8000ad4:	3601      	addeq	r6, #1
    if ( *fmt == '*') {
 8000ad6:	2b2a      	cmp	r3, #42	; 0x2a
 8000ad8:	f040 80b6 	bne.w	8000c48 <chprintf.constprop.0+0x1d8>
      width = va_arg(ap, int);
 8000adc:	f858 2b04 	ldr.w	r2, [r8], #4
      c = *fmt++;
 8000ae0:	7873      	ldrb	r3, [r6, #1]
 8000ae2:	1cb4      	adds	r4, r6, #2
    if (c == '.') {
 8000ae4:	2b2e      	cmp	r3, #46	; 0x2e
 8000ae6:	f000 8139 	beq.w	8000d5c <chprintf.constprop.0+0x2ec>
    precision = 0;
 8000aea:	2100      	movs	r1, #0
    if (c == 'l' || c == 'L') {
 8000aec:	f003 06df 	and.w	r6, r3, #223	; 0xdf
 8000af0:	2e4c      	cmp	r6, #76	; 0x4c
 8000af2:	f000 80bc 	beq.w	8000c6e <chprintf.constprop.0+0x1fe>
 8000af6:	f1a3 0c44 	sub.w	ip, r3, #68	; 0x44
 8000afa:	f1bc 0f34 	cmp.w	ip, #52	; 0x34
 8000afe:	f200 819f 	bhi.w	8000e40 <chprintf.constprop.0+0x3d0>
 8000b02:	e8df f01c 	tbh	[pc, ip, lsl #1]
 8000b06:	0169      	.short	0x0169
 8000b08:	019d019d 	.word	0x019d019d
 8000b0c:	019d019d 	.word	0x019d019d
 8000b10:	019d0169 	.word	0x019d0169
 8000b14:	019d019d 	.word	0x019d019d
 8000b18:	019d019d 	.word	0x019d019d
 8000b1c:	003501a0 	.word	0x003501a0
 8000b20:	019d019d 	.word	0x019d019d
 8000b24:	019d019d 	.word	0x019d019d
 8000b28:	019d009e 	.word	0x019d009e
 8000b2c:	0035019d 	.word	0x0035019d
 8000b30:	019d019d 	.word	0x019d019d
 8000b34:	019d019d 	.word	0x019d019d
 8000b38:	019d019d 	.word	0x019d019d
 8000b3c:	019d019d 	.word	0x019d019d
 8000b40:	019d019d 	.word	0x019d019d
 8000b44:	01690156 	.word	0x01690156
 8000b48:	019d019d 	.word	0x019d019d
 8000b4c:	019d019d 	.word	0x019d019d
 8000b50:	019d0169 	.word	0x019d0169
 8000b54:	019d019d 	.word	0x019d019d
 8000b58:	019d019d 	.word	0x019d019d
 8000b5c:	003501a0 	.word	0x003501a0
 8000b60:	019d019d 	.word	0x019d019d
 8000b64:	019d013b 	.word	0x019d013b
 8000b68:	019d009e 	.word	0x019d009e
 8000b6c:	0035019d 	.word	0x0035019d
      c = 16;
 8000b70:	f04f 0c10 	mov.w	ip, #16
        l = va_arg(ap, unsigned int);
 8000b74:	f858 3b04 	ldr.w	r3, [r8], #4
  q = p + MAX_FILLER;
 8000b78:	f10d 0117 	add.w	r1, sp, #23
 8000b7c:	e000      	b.n	8000b80 <chprintf.constprop.0+0x110>
  } while ((ll /= radix) != 0);
 8000b7e:	4631      	mov	r1, r6
    i = (int)(l % radix);
 8000b80:	4699      	mov	r9, r3
 8000b82:	fbb3 f3fc 	udiv	r3, r3, ip
 8000b86:	fb0c 9b13 	mls	fp, ip, r3, r9
    i += '0';
 8000b8a:	f10b 0030 	add.w	r0, fp, #48	; 0x30
    if (i > '9') {
 8000b8e:	2839      	cmp	r0, #57	; 0x39
      i += 'A' - '0' - 10;
 8000b90:	bfc8      	it	gt
 8000b92:	f10b 0037 	addgt.w	r0, fp, #55	; 0x37
    *--q = i;
 8000b96:	b2c0      	uxtb	r0, r0
  } while ((ll /= radix) != 0);
 8000b98:	45cc      	cmp	ip, r9
    *--q = i;
 8000b9a:	f101 36ff 	add.w	r6, r1, #4294967295	; 0xffffffff
 8000b9e:	f801 0c01 	strb.w	r0, [r1, #-1]
  } while ((ll /= radix) != 0);
 8000ba2:	d9ec      	bls.n	8000b7e <chprintf.constprop.0+0x10e>
 8000ba4:	f10d 0917 	add.w	r9, sp, #23
 8000ba8:	468b      	mov	fp, r1
  i = (int)(p + MAX_FILLER - q);
 8000baa:	4649      	mov	r1, r9
 8000bac:	ab03      	add	r3, sp, #12
 8000bae:	1b8e      	subs	r6, r1, r6
 8000bb0:	469c      	mov	ip, r3
 8000bb2:	4659      	mov	r1, fp
 8000bb4:	e001      	b.n	8000bba <chprintf.constprop.0+0x14a>
 8000bb6:	f811 0b01 	ldrb.w	r0, [r1], #1
  while (--i);
 8000bba:	4589      	cmp	r9, r1
    *p++ = *q++;
 8000bbc:	f80c 0b01 	strb.w	r0, [ip], #1
  while (--i);
 8000bc0:	d1f9      	bne.n	8000bb6 <chprintf.constprop.0+0x146>
    s = tmpbuf;
 8000bc2:	4699      	mov	r9, r3
 8000bc4:	441e      	add	r6, r3
    i = (int)(p - s);
 8000bc6:	eba6 0609 	sub.w	r6, r6, r9
    if ((width -= i) < 0) {
 8000bca:	1b92      	subs	r2, r2, r6
 8000bcc:	ea22 7be2 	bic.w	fp, r2, r2, asr #31
    if (left_align == false) {
 8000bd0:	f1be 0f00 	cmp.w	lr, #0
 8000bd4:	d104      	bne.n	8000be0 <chprintf.constprop.0+0x170>
    if (width < 0) {
 8000bd6:	2a00      	cmp	r2, #0
      width = -width;
 8000bd8:	f1cb 0b00 	rsb	fp, fp, #0
    if (width < 0) {
 8000bdc:	f300 8147 	bgt.w	8000e6e <chprintf.constprop.0+0x3fe>
    while (--i >= 0) {
 8000be0:	2e00      	cmp	r6, #0
 8000be2:	dd15      	ble.n	8000c10 <chprintf.constprop.0+0x1a0>
 8000be4:	eb09 0306 	add.w	r3, r9, r6
 8000be8:	f8cd a004 	str.w	sl, [sp, #4]
 8000bec:	46ba      	mov	sl, r7
 8000bee:	4637      	mov	r7, r6
 8000bf0:	4626      	mov	r6, r4
 8000bf2:	461c      	mov	r4, r3
      streamPut(chp, (uint8_t)*s++);
 8000bf4:	682a      	ldr	r2, [r5, #0]
 8000bf6:	f819 1b01 	ldrb.w	r1, [r9], #1
 8000bfa:	4628      	mov	r0, r5
 8000bfc:	68d2      	ldr	r2, [r2, #12]
 8000bfe:	4790      	blx	r2
    while (--i >= 0) {
 8000c00:	45a1      	cmp	r9, r4
 8000c02:	d1f7      	bne.n	8000bf4 <chprintf.constprop.0+0x184>
 8000c04:	4634      	mov	r4, r6
 8000c06:	463e      	mov	r6, r7
 8000c08:	4657      	mov	r7, sl
 8000c0a:	f8dd a004 	ldr.w	sl, [sp, #4]
 8000c0e:	44b2      	add	sl, r6
    while (width) {
 8000c10:	f1bb 0f00 	cmp.w	fp, #0
 8000c14:	f43f af41 	beq.w	8000a9a <chprintf.constprop.0+0x2a>
 8000c18:	465e      	mov	r6, fp
      streamPut(chp, (uint8_t)filler);
 8000c1a:	682b      	ldr	r3, [r5, #0]
 8000c1c:	4639      	mov	r1, r7
 8000c1e:	4628      	mov	r0, r5
 8000c20:	68db      	ldr	r3, [r3, #12]
 8000c22:	4798      	blx	r3
    while (width) {
 8000c24:	3e01      	subs	r6, #1
 8000c26:	d1f8      	bne.n	8000c1a <chprintf.constprop.0+0x1aa>
    c = *fmt++;
 8000c28:	4626      	mov	r6, r4
 8000c2a:	f816 1b01 	ldrb.w	r1, [r6], #1
 8000c2e:	44da      	add	sl, fp
    if (c == 0) {
 8000c30:	2900      	cmp	r1, #0
 8000c32:	f47f af38 	bne.w	8000aa6 <chprintf.constprop.0+0x36>
  formatted_bytes = chvprintf(chp, fmt, ap);
  va_end(ap);

  return formatted_bytes;
}
 8000c36:	4650      	mov	r0, sl
 8000c38:	b006      	add	sp, #24
 8000c3a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000c3e:	b003      	add	sp, #12
 8000c40:	4770      	bx	lr
      if (c == 0) {
 8000c42:	f04f 0c0a 	mov.w	ip, #10
 8000c46:	e795      	b.n	8000b74 <chprintf.constprop.0+0x104>
        c = *fmt++;
 8000c48:	1c74      	adds	r4, r6, #1
        if (c == 0) {
 8000c4a:	2b00      	cmp	r3, #0
 8000c4c:	d0f3      	beq.n	8000c36 <chprintf.constprop.0+0x1c6>
      width = 0;
 8000c4e:	2200      	movs	r2, #0
        if (c >= '0' && c <= '9') {
 8000c50:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
 8000c54:	b2c9      	uxtb	r1, r1
 8000c56:	2909      	cmp	r1, #9
          width = width * 10 + c;
 8000c58:	eb02 0682 	add.w	r6, r2, r2, lsl #2
        if (c >= '0' && c <= '9') {
 8000c5c:	f63f af42 	bhi.w	8000ae4 <chprintf.constprop.0+0x74>
        c = *fmt++;
 8000c60:	f814 3b01 	ldrb.w	r3, [r4], #1
          width = width * 10 + c;
 8000c64:	eb01 0246 	add.w	r2, r1, r6, lsl #1
        if (c == 0) {
 8000c68:	2b00      	cmp	r3, #0
 8000c6a:	d1f1      	bne.n	8000c50 <chprintf.constprop.0+0x1e0>
 8000c6c:	e7e3      	b.n	8000c36 <chprintf.constprop.0+0x1c6>
      c = *fmt++;
 8000c6e:	f814 3b01 	ldrb.w	r3, [r4], #1
      if (c == 0) {
 8000c72:	2b00      	cmp	r3, #0
 8000c74:	d0df      	beq.n	8000c36 <chprintf.constprop.0+0x1c6>
 8000c76:	f1a3 0644 	sub.w	r6, r3, #68	; 0x44
 8000c7a:	2e34      	cmp	r6, #52	; 0x34
 8000c7c:	f200 80e0 	bhi.w	8000e40 <chprintf.constprop.0+0x3d0>
 8000c80:	f20f 0c04 	addw	ip, pc, #4
 8000c84:	f85c f026 	ldr.w	pc, [ip, r6, lsl #2]
 8000c88:	08000dd9 	.word	0x08000dd9
 8000c8c:	08000e41 	.word	0x08000e41
 8000c90:	08000e41 	.word	0x08000e41
 8000c94:	08000e41 	.word	0x08000e41
 8000c98:	08000e41 	.word	0x08000e41
 8000c9c:	08000dd9 	.word	0x08000dd9
 8000ca0:	08000e41 	.word	0x08000e41
 8000ca4:	08000e41 	.word	0x08000e41
 8000ca8:	08000e41 	.word	0x08000e41
 8000cac:	08000e41 	.word	0x08000e41
 8000cb0:	08000e41 	.word	0x08000e41
 8000cb4:	08000e47 	.word	0x08000e47
 8000cb8:	08000b71 	.word	0x08000b71
 8000cbc:	08000e41 	.word	0x08000e41
 8000cc0:	08000e41 	.word	0x08000e41
 8000cc4:	08000e41 	.word	0x08000e41
 8000cc8:	08000e41 	.word	0x08000e41
 8000ccc:	08000c43 	.word	0x08000c43
 8000cd0:	08000e41 	.word	0x08000e41
 8000cd4:	08000e41 	.word	0x08000e41
 8000cd8:	08000b71 	.word	0x08000b71
 8000cdc:	08000e41 	.word	0x08000e41
 8000ce0:	08000e41 	.word	0x08000e41
 8000ce4:	08000e41 	.word	0x08000e41
 8000ce8:	08000e41 	.word	0x08000e41
 8000cec:	08000e41 	.word	0x08000e41
 8000cf0:	08000e41 	.word	0x08000e41
 8000cf4:	08000e41 	.word	0x08000e41
 8000cf8:	08000e41 	.word	0x08000e41
 8000cfc:	08000e41 	.word	0x08000e41
 8000d00:	08000e41 	.word	0x08000e41
 8000d04:	08000db3 	.word	0x08000db3
 8000d08:	08000dd9 	.word	0x08000dd9
 8000d0c:	08000e41 	.word	0x08000e41
 8000d10:	08000e41 	.word	0x08000e41
 8000d14:	08000e41 	.word	0x08000e41
 8000d18:	08000e41 	.word	0x08000e41
 8000d1c:	08000dd9 	.word	0x08000dd9
 8000d20:	08000e41 	.word	0x08000e41
 8000d24:	08000e41 	.word	0x08000e41
 8000d28:	08000e41 	.word	0x08000e41
 8000d2c:	08000e41 	.word	0x08000e41
 8000d30:	08000e41 	.word	0x08000e41
 8000d34:	08000e47 	.word	0x08000e47
 8000d38:	08000b71 	.word	0x08000b71
 8000d3c:	08000e41 	.word	0x08000e41
 8000d40:	08000e41 	.word	0x08000e41
 8000d44:	08000d7d 	.word	0x08000d7d
 8000d48:	08000e41 	.word	0x08000e41
 8000d4c:	08000c43 	.word	0x08000c43
 8000d50:	08000e41 	.word	0x08000e41
 8000d54:	08000e41 	.word	0x08000e41
 8000d58:	08000b71 	.word	0x08000b71
      c = *fmt++;
 8000d5c:	7823      	ldrb	r3, [r4, #0]
      if (c == 0) {
 8000d5e:	2b00      	cmp	r3, #0
 8000d60:	f43f af69 	beq.w	8000c36 <chprintf.constprop.0+0x1c6>
      if (c == '*') {
 8000d64:	2b2a      	cmp	r3, #42	; 0x2a
 8000d66:	d171      	bne.n	8000e4c <chprintf.constprop.0+0x3dc>
        c = *fmt++;
 8000d68:	7863      	ldrb	r3, [r4, #1]
        precision = va_arg(ap, int);
 8000d6a:	f858 1b04 	ldr.w	r1, [r8], #4
        c = *fmt++;
 8000d6e:	3402      	adds	r4, #2
 8000d70:	e6bc      	b.n	8000aec <chprintf.constprop.0+0x7c>
 8000d72:	bf00      	nop
 8000d74:	08001e5d 	.word	0x08001e5d
 8000d78:	20000800 	.word	0x20000800
      if ((s = va_arg(ap, char *)) == 0) {
 8000d7c:	f858 3b04 	ldr.w	r3, [r8], #4
 8000d80:	2b00      	cmp	r3, #0
 8000d82:	f000 80b6 	beq.w	8000ef2 <chprintf.constprop.0+0x482>
      if (precision == 0) {
 8000d86:	2900      	cmp	r1, #0
 8000d88:	f040 80a4 	bne.w	8000ed4 <chprintf.constprop.0+0x464>
      for (p = s; *p && (--precision >= 0); p++)
 8000d8c:	7819      	ldrb	r1, [r3, #0]
 8000d8e:	4699      	mov	r9, r3
 8000d90:	2900      	cmp	r1, #0
 8000d92:	f000 80a5 	beq.w	8000ee0 <chprintf.constprop.0+0x470>
 8000d96:	f647 71fe 	movw	r1, #32766	; 0x7ffe
 8000d9a:	464e      	mov	r6, r9
 8000d9c:	e001      	b.n	8000da2 <chprintf.constprop.0+0x332>
 8000d9e:	42cb      	cmn	r3, r1
 8000da0:	d405      	bmi.n	8000dae <chprintf.constprop.0+0x33e>
 8000da2:	f816 0f01 	ldrb.w	r0, [r6, #1]!
 8000da6:	eba9 0306 	sub.w	r3, r9, r6
 8000daa:	2800      	cmp	r0, #0
 8000dac:	d1f7      	bne.n	8000d9e <chprintf.constprop.0+0x32e>
      filler = ' ';
 8000dae:	2720      	movs	r7, #32
 8000db0:	e709      	b.n	8000bc6 <chprintf.constprop.0+0x156>
      filler = ' ';
 8000db2:	2720      	movs	r7, #32
      *p++ = va_arg(ap, int);
 8000db4:	f858 3b04 	ldr.w	r3, [r8], #4
 8000db8:	f88d 300c 	strb.w	r3, [sp, #12]
    if ((width -= i) < 0) {
 8000dbc:	3a01      	subs	r2, #1
 8000dbe:	ea22 7be2 	bic.w	fp, r2, r2, asr #31
    if (left_align == false) {
 8000dc2:	f1be 0f00 	cmp.w	lr, #0
 8000dc6:	d103      	bne.n	8000dd0 <chprintf.constprop.0+0x360>
    if (width < 0) {
 8000dc8:	2a00      	cmp	r2, #0
      width = -width;
 8000dca:	f1cb 0b00 	rsb	fp, fp, #0
    if (width < 0) {
 8000dce:	dc7b      	bgt.n	8000ec8 <chprintf.constprop.0+0x458>
    i = (int)(p - s);
 8000dd0:	2601      	movs	r6, #1
    if (left_align == false) {
 8000dd2:	f10d 090c 	add.w	r9, sp, #12
 8000dd6:	e705      	b.n	8000be4 <chprintf.constprop.0+0x174>
        l = va_arg(ap, int);
 8000dd8:	f858 cb04 	ldr.w	ip, [r8], #4
      if (l < 0) {
 8000ddc:	f1bc 0f00 	cmp.w	ip, #0
 8000de0:	db68      	blt.n	8000eb4 <chprintf.constprop.0+0x444>
        if (do_sign) {
 8000de2:	2800      	cmp	r0, #0
 8000de4:	f000 808b 	beq.w	8000efe <chprintf.constprop.0+0x48e>
          *p++ = '+';
 8000de8:	232b      	movs	r3, #43	; 0x2b
 8000dea:	f10d 010d 	add.w	r1, sp, #13
 8000dee:	f88d 300c 	strb.w	r3, [sp, #12]
 8000df2:	9101      	str	r1, [sp, #4]
 8000df4:	ab03      	add	r3, sp, #12
  q = p + MAX_FILLER;
 8000df6:	9901      	ldr	r1, [sp, #4]
 8000df8:	f101 0b0b 	add.w	fp, r1, #11
 8000dfc:	4658      	mov	r0, fp
    i = (int)(l % radix);
 8000dfe:	4943      	ldr	r1, [pc, #268]	; (8000f0c <chprintf.constprop.0+0x49c>)
 8000e00:	46e1      	mov	r9, ip
 8000e02:	fba1 610c 	umull	r6, r1, r1, ip
 8000e06:	08c9      	lsrs	r1, r1, #3
 8000e08:	460e      	mov	r6, r1
 8000e0a:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8000e0e:	ebac 0141 	sub.w	r1, ip, r1, lsl #1
    i += '0';
 8000e12:	3130      	adds	r1, #48	; 0x30
  } while ((ll /= radix) != 0);
 8000e14:	f1b9 0f09 	cmp.w	r9, #9
    l /= radix;
 8000e18:	46b4      	mov	ip, r6
    *--q = i;
 8000e1a:	f800 1d01 	strb.w	r1, [r0, #-1]!
  } while ((ll /= radix) != 0);
 8000e1e:	dcee      	bgt.n	8000dfe <chprintf.constprop.0+0x38e>
 8000e20:	46d9      	mov	r9, fp
 8000e22:	9901      	ldr	r1, [sp, #4]
  i = (int)(p + MAX_FILLER - q);
 8000e24:	ebab 0600 	sub.w	r6, fp, r0
 8000e28:	3901      	subs	r1, #1
    *p++ = *q++;
 8000e2a:	f810 cb01 	ldrb.w	ip, [r0], #1
  while (--i);
 8000e2e:	4548      	cmp	r0, r9
    *p++ = *q++;
 8000e30:	f801 cf01 	strb.w	ip, [r1, #1]!
  while (--i);
 8000e34:	d1f9      	bne.n	8000e2a <chprintf.constprop.0+0x3ba>
 8000e36:	9901      	ldr	r1, [sp, #4]
    s = tmpbuf;
 8000e38:	4699      	mov	r9, r3
 8000e3a:	4431      	add	r1, r6
 8000e3c:	460e      	mov	r6, r1
 8000e3e:	e6c2      	b.n	8000bc6 <chprintf.constprop.0+0x156>
      *p++ = c;
 8000e40:	f88d 300c 	strb.w	r3, [sp, #12]
 8000e44:	e7ba      	b.n	8000dbc <chprintf.constprop.0+0x34c>
      c = 8;
 8000e46:	f04f 0c08 	mov.w	ip, #8
 8000e4a:	e693      	b.n	8000b74 <chprintf.constprop.0+0x104>
    precision = 0;
 8000e4c:	2100      	movs	r1, #0
      c = *fmt++;
 8000e4e:	3401      	adds	r4, #1
        while (c >= '0' && c <= '9') {
 8000e50:	f1a3 0630 	sub.w	r6, r3, #48	; 0x30
 8000e54:	b2f6      	uxtb	r6, r6
 8000e56:	2e09      	cmp	r6, #9
          precision = precision * 10 + c;
 8000e58:	eb01 0c81 	add.w	ip, r1, r1, lsl #2
        while (c >= '0' && c <= '9') {
 8000e5c:	f63f ae46 	bhi.w	8000aec <chprintf.constprop.0+0x7c>
          c = *fmt++;
 8000e60:	f814 3b01 	ldrb.w	r3, [r4], #1
          precision = precision * 10 + c;
 8000e64:	eb06 014c 	add.w	r1, r6, ip, lsl #1
          if (c == 0) {
 8000e68:	2b00      	cmp	r3, #0
 8000e6a:	d1f1      	bne.n	8000e50 <chprintf.constprop.0+0x3e0>
 8000e6c:	e6e3      	b.n	8000c36 <chprintf.constprop.0+0x1c6>
      width = -width;
 8000e6e:	f8cd b004 	str.w	fp, [sp, #4]
      if ((*s == '-' || *s == '+') && filler == '0') {
 8000e72:	f899 1000 	ldrb.w	r1, [r9]
 8000e76:	292d      	cmp	r1, #45	; 0x2d
 8000e78:	d010      	beq.n	8000e9c <chprintf.constprop.0+0x42c>
 8000e7a:	292b      	cmp	r1, #43	; 0x2b
 8000e7c:	d00e      	beq.n	8000e9c <chprintf.constprop.0+0x42c>
        streamPut(chp, (uint8_t)filler);
 8000e7e:	682b      	ldr	r3, [r5, #0]
 8000e80:	4639      	mov	r1, r7
 8000e82:	4628      	mov	r0, r5
 8000e84:	68db      	ldr	r3, [r3, #12]
 8000e86:	4798      	blx	r3
      } while (++width != 0);
 8000e88:	f11b 0b01 	adds.w	fp, fp, #1
 8000e8c:	d1f7      	bne.n	8000e7e <chprintf.constprop.0+0x40e>
 8000e8e:	9b01      	ldr	r3, [sp, #4]
    while (--i >= 0) {
 8000e90:	2e00      	cmp	r6, #0
 8000e92:	ebaa 0a03 	sub.w	sl, sl, r3
 8000e96:	f73f aea5 	bgt.w	8000be4 <chprintf.constprop.0+0x174>
 8000e9a:	e5fe      	b.n	8000a9a <chprintf.constprop.0+0x2a>
      if ((*s == '-' || *s == '+') && filler == '0') {
 8000e9c:	2f30      	cmp	r7, #48	; 0x30
 8000e9e:	d1ee      	bne.n	8000e7e <chprintf.constprop.0+0x40e>
        streamPut(chp, (uint8_t)*s++);
 8000ea0:	682a      	ldr	r2, [r5, #0]
 8000ea2:	481b      	ldr	r0, [pc, #108]	; (8000f10 <chprintf.constprop.0+0x4a0>)
 8000ea4:	68d2      	ldr	r2, [r2, #12]
 8000ea6:	4790      	blx	r2
 8000ea8:	f109 0901 	add.w	r9, r9, #1
        n++;
 8000eac:	f10a 0a01 	add.w	sl, sl, #1
        i--;
 8000eb0:	3e01      	subs	r6, #1
 8000eb2:	e7e4      	b.n	8000e7e <chprintf.constprop.0+0x40e>
        *p++ = '-';
 8000eb4:	232d      	movs	r3, #45	; 0x2d
 8000eb6:	f88d 300c 	strb.w	r3, [sp, #12]
 8000eba:	f10d 030d 	add.w	r3, sp, #13
 8000ebe:	9301      	str	r3, [sp, #4]
        l = -l;
 8000ec0:	f1cc 0c00 	rsb	ip, ip, #0
 8000ec4:	ab03      	add	r3, sp, #12
 8000ec6:	e796      	b.n	8000df6 <chprintf.constprop.0+0x386>
    i = (int)(p - s);
 8000ec8:	2601      	movs	r6, #1
      width = -width;
 8000eca:	f8cd b004 	str.w	fp, [sp, #4]
    if (width < 0) {
 8000ece:	f10d 090c 	add.w	r9, sp, #12
 8000ed2:	e7ce      	b.n	8000e72 <chprintf.constprop.0+0x402>
      for (p = s; *p && (--precision >= 0); p++)
 8000ed4:	7818      	ldrb	r0, [r3, #0]
 8000ed6:	b1b8      	cbz	r0, 8000f08 <chprintf.constprop.0+0x498>
 8000ed8:	3901      	subs	r1, #1
 8000eda:	4699      	mov	r9, r3
 8000edc:	f57f af5d 	bpl.w	8000d9a <chprintf.constprop.0+0x32a>
    i = (int)(p - s);
 8000ee0:	2600      	movs	r6, #0
    if (left_align == false) {
 8000ee2:	2720      	movs	r7, #32
 8000ee4:	ea22 7be2 	bic.w	fp, r2, r2, asr #31
 8000ee8:	f1be 0f00 	cmp.w	lr, #0
 8000eec:	f43f ae73 	beq.w	8000bd6 <chprintf.constprop.0+0x166>
 8000ef0:	e68e      	b.n	8000c10 <chprintf.constprop.0+0x1a0>
      if (precision == 0) {
 8000ef2:	b939      	cbnz	r1, 8000f04 <chprintf.constprop.0+0x494>
      for (p = s; *p && (--precision >= 0); p++)
 8000ef4:	f647 71fe 	movw	r1, #32766	; 0x7ffe
      if (precision == 0) {
 8000ef8:	f8df 9018 	ldr.w	r9, [pc, #24]	; 8000f14 <chprintf.constprop.0+0x4a4>
 8000efc:	e74d      	b.n	8000d9a <chprintf.constprop.0+0x32a>
    p = tmpbuf;
 8000efe:	ab03      	add	r3, sp, #12
 8000f00:	9301      	str	r3, [sp, #4]
 8000f02:	e778      	b.n	8000df6 <chprintf.constprop.0+0x386>
        s = "(null)";
 8000f04:	4b03      	ldr	r3, [pc, #12]	; (8000f14 <chprintf.constprop.0+0x4a4>)
 8000f06:	e7e7      	b.n	8000ed8 <chprintf.constprop.0+0x468>
      for (p = s; *p && (--precision >= 0); p++)
 8000f08:	4699      	mov	r9, r3
 8000f0a:	e7e9      	b.n	8000ee0 <chprintf.constprop.0+0x470>
 8000f0c:	cccccccd 	.word	0xcccccccd
 8000f10:	20000800 	.word	0x20000800
 8000f14:	08001e74 	.word	0x08001e74
	...

08000f20 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
 8000f20:	b430      	push	{r4, r5}
  ntp->state = CH_STATE_CURRENT;
 8000f22:	2501      	movs	r5, #1
  thread_t *otp = __instance_get_currthread(oip);
 8000f24:	4b07      	ldr	r3, [pc, #28]	; (8000f44 <chSchGoSleepS+0x24>)
 8000f26:	68d9      	ldr	r1, [r3, #12]
  ch_priority_queue_t *p = pqp->next;
 8000f28:	681a      	ldr	r2, [r3, #0]
  otp->state = newstate;
 8000f2a:	f881 0028 	strb.w	r0, [r1, #40]	; 0x28
  pqp->next       = p->next;
 8000f2e:	6814      	ldr	r4, [r2, #0]
  chSysSwitch(ntp, otp);
 8000f30:	4610      	mov	r0, r2
  pqp->next->prev = pqp;
 8000f32:	6063      	str	r3, [r4, #4]
  ntp->state = CH_STATE_CURRENT;
 8000f34:	f882 5028 	strb.w	r5, [r2, #40]	; 0x28
  pqp->next       = p->next;
 8000f38:	601c      	str	r4, [r3, #0]
}
 8000f3a:	bc30      	pop	{r4, r5}
  __instance_set_currthread(oip, ntp);
 8000f3c:	60da      	str	r2, [r3, #12]
  chSysSwitch(ntp, otp);
 8000f3e:	f7ff b9a5 	b.w	800028c <__port_switch>
 8000f42:	bf00      	nop
 8000f44:	20000d98 	.word	0x20000d98
	...

08000f50 <chThdEnqueueTimeoutS>:
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
 8000f50:	e92d 42f0 	stmdb	sp!, {r4, r5, r6, r7, r9, lr}
  return __sch_get_currthread();
 8000f54:	4e3c      	ldr	r6, [pc, #240]	; (8001048 <chThdEnqueueTimeoutS+0xf8>)
 8000f56:	b086      	sub	sp, #24
 8000f58:	68f7      	ldr	r7, [r6, #12]
  if (unlikely(TIME_IMMEDIATE == timeout)) {
 8000f5a:	2900      	cmp	r1, #0
 8000f5c:	d065      	beq.n	800102a <chThdEnqueueTimeoutS+0xda>
  p->prev       = qp->prev;
 8000f5e:	6843      	ldr	r3, [r0, #4]
 8000f60:	460a      	mov	r2, r1
 8000f62:	e9c7 0300 	strd	r0, r3, [r7]
  p->prev->next = p;
 8000f66:	601f      	str	r7, [r3, #0]
  if (TIME_INFINITE != timeout) {
 8000f68:	1c4b      	adds	r3, r1, #1
  qp->prev      = p;
 8000f6a:	6047      	str	r7, [r0, #4]
 8000f6c:	d042      	beq.n	8000ff4 <chThdEnqueueTimeoutS+0xa4>
  return (bool)(dlhp == dlhp->next);
 8000f6e:	46b1      	mov	r9, r6
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  /* Timer initialization.*/
  vtp->par     = par;
  vtp->func    = vtfunc;
  vtp->reload  = (sysinterval_t)0;
 8000f70:	2400      	movs	r4, #0
 8000f72:	f859 5f10 	ldr.w	r5, [r9, #16]!
  vtp->par     = par;
 8000f76:	e9cd 7404 	strd	r7, r4, [sp, #16]
 8000f7a:	4834      	ldr	r0, [pc, #208]	; (800104c <chThdEnqueueTimeoutS+0xfc>)
  vtp->func    = vtfunc;
 8000f7c:	4b34      	ldr	r3, [pc, #208]	; (8001050 <chThdEnqueueTimeoutS+0x100>)
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8000f7e:	454d      	cmp	r5, r9
 8000f80:	6800      	ldr	r0, [r0, #0]
  vtp->func    = vtfunc;
 8000f82:	9303      	str	r3, [sp, #12]
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8000f84:	d056      	beq.n	8001034 <chThdEnqueueTimeoutS+0xe4>
 8000f86:	69f3      	ldr	r3, [r6, #28]
 8000f88:	1ac3      	subs	r3, r0, r3
    if (delta < nowdelta) {
 8000f8a:	18cb      	adds	r3, r1, r3
 8000f8c:	bf34      	ite	cc
 8000f8e:	461c      	movcc	r4, r3
 8000f90:	460c      	movcs	r4, r1
    if (delta < vtlp->dlist.next->delta) {
 8000f92:	68ab      	ldr	r3, [r5, #8]
 8000f94:	42a3      	cmp	r3, r4
 8000f96:	d907      	bls.n	8000fa8 <chThdEnqueueTimeoutS+0x58>
      vt_set_alarm(now, delay);
 8000f98:	f7ff fd42 	bl	8000a20 <vt_set_alarm>
 8000f9c:	6935      	ldr	r5, [r6, #16]
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
  while (likely(dlp->delta < delta)) {
 8000f9e:	68ab      	ldr	r3, [r5, #8]
 8000fa0:	42a3      	cmp	r3, r4
 8000fa2:	d204      	bcs.n	8000fae <chThdEnqueueTimeoutS+0x5e>
    /* Debug assert if the element is already in the list.*/
    chDbgAssert(dlp != dlep, "element already in list");

    delta -= dlp->delta;
    dlp = dlp->next;
 8000fa4:	682d      	ldr	r5, [r5, #0]
    delta -= dlp->delta;
 8000fa6:	1ae4      	subs	r4, r4, r3
  while (likely(dlp->delta < delta)) {
 8000fa8:	68ab      	ldr	r3, [r5, #8]
 8000faa:	42a3      	cmp	r3, r4
 8000fac:	d3fa      	bcc.n	8000fa4 <chThdEnqueueTimeoutS+0x54>
  dlp->delta      = delta;
 8000fae:	9402      	str	r4, [sp, #8]
  dlp->prev       = dlp->next->prev;
 8000fb0:	e9d5 3201 	ldrd	r3, r2, [r5, #4]
  dlp->delta -= delta;

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
 8000fb4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  dlp->delta -= delta;
 8000fb8:	1b12      	subs	r2, r2, r4
  dlp->prev->next = dlp;
 8000fba:	466c      	mov	r4, sp
  dlp->prev       = dlp->next->prev;
 8000fbc:	e9cd 5300 	strd	r5, r3, [sp]
  dlp->prev->next = dlp;
 8000fc0:	601c      	str	r4, [r3, #0]
  dlhp->prev      = dlp;
 8000fc2:	e9c5 4201 	strd	r4, r2, [r5, #4]
  dlhp->delta = (sysinterval_t)-1;
 8000fc6:	61b1      	str	r1, [r6, #24]
    chSchGoSleepS(newstate);
 8000fc8:	2004      	movs	r0, #4
 8000fca:	f7ff ffa9 	bl	8000f20 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8000fce:	9b00      	ldr	r3, [sp, #0]
 8000fd0:	b163      	cbz	r3, 8000fec <chThdEnqueueTimeoutS+0x9c>
  systime_t now;
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (!ch_dlist_isfirst(&vtlp->dlist, &vtp->dlist)) {
 8000fd2:	6932      	ldr	r2, [r6, #16]
 8000fd4:	42a2      	cmp	r2, r4
 8000fd6:	d011      	beq.n	8000ffc <chThdEnqueueTimeoutS+0xac>
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {

  dlp->prev->next = dlp->next;
 8000fd8:	e9dd 1401 	ldrd	r1, r4, [sp, #4]
    vtp->dlist.next = NULL;

    /* Special case when the removed element from the last position in the list,
       the value in the header must be restored, just doing it is faster than
       checking then doing.*/
    vtlp->dlist.delta = (sysinterval_t)-1;
 8000fdc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    vtp->dlist.next->delta += vtp->dlist.delta;
 8000fe0:	689a      	ldr	r2, [r3, #8]
 8000fe2:	600b      	str	r3, [r1, #0]
 8000fe4:	4422      	add	r2, r4
  dlp->next->prev = dlp->prev;
 8000fe6:	e9c3 1201 	strd	r1, r2, [r3, #4]
    vtlp->dlist.delta = (sysinterval_t)-1;
 8000fea:	61b0      	str	r0, [r6, #24]
  return tp->u.rdymsg;
 8000fec:	6af8      	ldr	r0, [r7, #44]	; 0x2c
}
 8000fee:	b006      	add	sp, #24
 8000ff0:	e8bd 82f0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, pc}
    chSchGoSleepS(newstate);
 8000ff4:	2004      	movs	r0, #4
 8000ff6:	f7ff ff93 	bl	8000f20 <chSchGoSleepS>
 8000ffa:	e7f7      	b.n	8000fec <chThdEnqueueTimeoutS+0x9c>
    return;
  }

  /* Removing the first timer from the list, marking it as not armed.*/
  ch_dlist_remove_first(&vtlp->dlist);
  vtp->dlist.next = NULL;
 8000ffc:	2100      	movs	r1, #0
  dlhp->next       = dlp->next;
 8000ffe:	6133      	str	r3, [r6, #16]
  dlhp->next->prev = dlhp;
 8001000:	f8c3 9004 	str.w	r9, [r3, #4]
  return (bool)(dlhp == dlhp->next);
 8001004:	6932      	ldr	r2, [r6, #16]
 8001006:	9100      	str	r1, [sp, #0]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8001008:	454a      	cmp	r2, r9
 800100a:	d019      	beq.n	8001040 <chThdEnqueueTimeoutS+0xf0>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  vtlp->dlist.next->delta += vtp->dlist.delta;
 800100c:	6893      	ldr	r3, [r2, #8]
 800100e:	9902      	ldr	r1, [sp, #8]
 8001010:	480e      	ldr	r0, [pc, #56]	; (800104c <chThdEnqueueTimeoutS+0xfc>)
 8001012:	440b      	add	r3, r1
 8001014:	6093      	str	r3, [r2, #8]

  /* Distance in ticks between the last alarm event and current time.*/
  now = chVTGetSystemTimeX();
  nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8001016:	69f1      	ldr	r1, [r6, #28]
 8001018:	6800      	ldr	r0, [r0, #0]
 800101a:	1a42      	subs	r2, r0, r1

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= vtlp->dlist.next->delta) {
 800101c:	4293      	cmp	r3, r2
 800101e:	d9e5      	bls.n	8000fec <chThdEnqueueTimeoutS+0x9c>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = vtlp->dlist.next->delta - nowdelta;
 8001020:	1a09      	subs	r1, r1, r0

  /* Setting up the alarm.*/
  vt_set_alarm(now, delta);
 8001022:	4419      	add	r1, r3
 8001024:	f7ff fcfc 	bl	8000a20 <vt_set_alarm>
 8001028:	e7e0      	b.n	8000fec <chThdEnqueueTimeoutS+0x9c>
    return MSG_TIMEOUT;
 800102a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 800102e:	b006      	add	sp, #24
 8001030:	e8bd 82f0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, pc}
      vt_insert_first(vtlp, vtp, now, delay);
 8001034:	466c      	mov	r4, sp
 8001036:	4601      	mov	r1, r0
 8001038:	4620      	mov	r0, r4
 800103a:	f7ff fba9 	bl	8000790 <vt_insert_first.constprop.0>
 800103e:	e7c3      	b.n	8000fc8 <chThdEnqueueTimeoutS+0x78>
  TIMER_DMAINTEN(TIMER1) = 0;
 8001040:	4b04      	ldr	r3, [pc, #16]	; (8001054 <chThdEnqueueTimeoutS+0x104>)
 8001042:	6019      	str	r1, [r3, #0]
 8001044:	e7d2      	b.n	8000fec <chThdEnqueueTimeoutS+0x9c>
 8001046:	bf00      	nop
 8001048:	20000d98 	.word	0x20000d98
 800104c:	40000024 	.word	0x40000024
 8001050:	08000811 	.word	0x08000811
 8001054:	4000000c 	.word	0x4000000c
	...

08001060 <oqPutTimeout>:
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, sysinterval_t timeout) {
 8001060:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001062:	4604      	mov	r4, r0
 8001064:	460f      	mov	r7, r1
 8001066:	4616      	mov	r6, r2
 8001068:	2320      	movs	r3, #32
 800106a:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  __stats_start_measure_crit_thd();
  __dbg_check_lock();
 800106e:	e005      	b.n	800107c <oqPutTimeout+0x1c>
  return chThdEnqueueTimeoutS(tqp, timeout);
 8001070:	4631      	mov	r1, r6
 8001072:	4620      	mov	r0, r4
 8001074:	f7ff ff6c 	bl	8000f50 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 8001078:	2800      	cmp	r0, #0
 800107a:	db17      	blt.n	80010ac <oqPutTimeout+0x4c>
  while (oqIsFullI(oqp)) {
 800107c:	68a5      	ldr	r5, [r4, #8]
 800107e:	2d00      	cmp	r5, #0
 8001080:	d0f6      	beq.n	8001070 <oqPutTimeout+0x10>
  *oqp->q_wrptr++ = b;
 8001082:	6962      	ldr	r2, [r4, #20]
  oqp->q_counter--;
 8001084:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8001086:	1c51      	adds	r1, r2, #1
  oqp->q_counter--;
 8001088:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 800108a:	6161      	str	r1, [r4, #20]
  oqp->q_counter--;
 800108c:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 800108e:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8001090:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
 8001094:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 8001096:	bf24      	itt	cs
 8001098:	68e3      	ldrcs	r3, [r4, #12]
 800109a:	6163      	strcs	r3, [r4, #20]
  if (oqp->q_notify != NULL) {
 800109c:	69e3      	ldr	r3, [r4, #28]
 800109e:	b10b      	cbz	r3, 80010a4 <oqPutTimeout+0x44>
    oqp->q_notify(oqp);
 80010a0:	4620      	mov	r0, r4
 80010a2:	4798      	blx	r3
 80010a4:	2000      	movs	r0, #0
 80010a6:	f380 8811 	msr	BASEPRI, r0
}
 80010aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80010ac:	f385 8811 	msr	BASEPRI, r5
 80010b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80010b2:	bf00      	nop
	...

080010c0 <_putt>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 80010c0:	3030      	adds	r0, #48	; 0x30
 80010c2:	f7ff bfcd 	b.w	8001060 <oqPutTimeout>
 80010c6:	bf00      	nop
	...

080010d0 <_put>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 80010d0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80010d4:	3030      	adds	r0, #48	; 0x30
 80010d6:	f7ff bfc3 	b.w	8001060 <oqPutTimeout>
 80010da:	bf00      	nop
 80010dc:	0000      	movs	r0, r0
	...

080010e0 <iqGetTimeout>:
msg_t iqGetTimeout(input_queue_t *iqp, sysinterval_t timeout) {
 80010e0:	b570      	push	{r4, r5, r6, lr}
 80010e2:	2320      	movs	r3, #32
 80010e4:	4605      	mov	r5, r0
 80010e6:	460e      	mov	r6, r1
 80010e8:	f383 8811 	msr	BASEPRI, r3
 80010ec:	e005      	b.n	80010fa <iqGetTimeout+0x1a>
 80010ee:	4631      	mov	r1, r6
 80010f0:	4628      	mov	r0, r5
 80010f2:	f7ff ff2d 	bl	8000f50 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 80010f6:	2800      	cmp	r0, #0
 80010f8:	db18      	blt.n	800112c <iqGetTimeout+0x4c>
  while (iqIsEmptyI(iqp)) {
 80010fa:	68ac      	ldr	r4, [r5, #8]
 80010fc:	2c00      	cmp	r4, #0
 80010fe:	d0f6      	beq.n	80010ee <iqGetTimeout+0xe>
  b = *iqp->q_rdptr++;
 8001100:	69a9      	ldr	r1, [r5, #24]
  iqp->q_counter--;
 8001102:	68ab      	ldr	r3, [r5, #8]
  if (iqp->q_rdptr >= iqp->q_top) {
 8001104:	6928      	ldr	r0, [r5, #16]
  b = *iqp->q_rdptr++;
 8001106:	1c4a      	adds	r2, r1, #1
  iqp->q_counter--;
 8001108:	3b01      	subs	r3, #1
  if (iqp->q_rdptr >= iqp->q_top) {
 800110a:	4282      	cmp	r2, r0
  iqp->q_counter--;
 800110c:	60ab      	str	r3, [r5, #8]
    iqp->q_rdptr = iqp->q_buffer;
 800110e:	bf28      	it	cs
 8001110:	68eb      	ldrcs	r3, [r5, #12]
  b = *iqp->q_rdptr++;
 8001112:	61aa      	str	r2, [r5, #24]
 8001114:	780c      	ldrb	r4, [r1, #0]
    iqp->q_rdptr = iqp->q_buffer;
 8001116:	bf28      	it	cs
 8001118:	61ab      	strcs	r3, [r5, #24]
  if (iqp->q_notify != NULL) {
 800111a:	69eb      	ldr	r3, [r5, #28]
 800111c:	b10b      	cbz	r3, 8001122 <iqGetTimeout+0x42>
    iqp->q_notify(iqp);
 800111e:	4628      	mov	r0, r5
 8001120:	4798      	blx	r3
 8001122:	2300      	movs	r3, #0
 8001124:	f383 8811 	msr	BASEPRI, r3
  return (msg_t)b;
 8001128:	4620      	mov	r0, r4
}
 800112a:	bd70      	pop	{r4, r5, r6, pc}
 800112c:	f384 8811 	msr	BASEPRI, r4
 8001130:	bd70      	pop	{r4, r5, r6, pc}
 8001132:	bf00      	nop
	...

08001140 <_gett>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8001140:	300c      	adds	r0, #12
 8001142:	f7ff bfcd 	b.w	80010e0 <iqGetTimeout>
 8001146:	bf00      	nop
	...

08001150 <_get>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8001150:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8001154:	300c      	adds	r0, #12
 8001156:	f7ff bfc3 	b.w	80010e0 <iqGetTimeout>
 800115a:	bf00      	nop
 800115c:	0000      	movs	r0, r0
	...

08001160 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 8001160:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001164:	b085      	sub	sp, #20
 8001166:	f04f 0920 	mov.w	r9, #32
 800116a:	e9cd 3202 	strd	r3, r2, [sp, #8]
  qnotify_t nfy = oqp->q_notify;
 800116e:	69c7      	ldr	r7, [r0, #28]
 8001170:	f389 8811 	msr	BASEPRI, r9

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
 8001174:	b3aa      	cbz	r2, 80011e2 <oqWriteTimeout+0x82>
 8001176:	4604      	mov	r4, r0
 8001178:	460e      	mov	r6, r1
 800117a:	f04f 0a00 	mov.w	sl, #0
 800117e:	f8dd b00c 	ldr.w	fp, [sp, #12]
  if (n > oqGetEmptyI(oqp)) {
 8001182:	68a2      	ldr	r2, [r4, #8]
 8001184:	4593      	cmp	fp, r2
 8001186:	bf98      	it	ls
 8001188:	465d      	movls	r5, fp
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 800118a:	e9d4 2004 	ldrd	r2, r0, [r4, #16]
    n = oqGetEmptyI(oqp);
 800118e:	bf88      	it	hi
 8001190:	68a5      	ldrhi	r5, [r4, #8]
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 8001192:	eba2 0800 	sub.w	r8, r2, r0
  if (n < s1) {
 8001196:	45a8      	cmp	r8, r5
 8001198:	d844      	bhi.n	8001224 <oqWriteTimeout+0xc4>
  else if (n > s1) {
 800119a:	d229      	bcs.n	80011f0 <oqWriteTimeout+0x90>
    s2 = n - s1;
 800119c:	eba5 0308 	sub.w	r3, r5, r8
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 80011a0:	4642      	mov	r2, r8
 80011a2:	4631      	mov	r1, r6
    s2 = n - s1;
 80011a4:	9301      	str	r3, [sp, #4]
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 80011a6:	f7ff f887 	bl	80002b8 <memcpy>
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
 80011aa:	eb06 0108 	add.w	r1, r6, r8
 80011ae:	f8dd 8004 	ldr.w	r8, [sp, #4]
 80011b2:	68e0      	ldr	r0, [r4, #12]
 80011b4:	4642      	mov	r2, r8
 80011b6:	f7ff f87f 	bl	80002b8 <memcpy>
    oqp->q_wrptr = oqp->q_buffer + s2;
 80011ba:	4643      	mov	r3, r8
  oqp->q_counter -= n;
 80011bc:	68a2      	ldr	r2, [r4, #8]
    oqp->q_wrptr = oqp->q_buffer + s2;
 80011be:	68e1      	ldr	r1, [r4, #12]
  oqp->q_counter -= n;
 80011c0:	1b52      	subs	r2, r2, r5
    oqp->q_wrptr = oqp->q_buffer + s2;
 80011c2:	18cb      	adds	r3, r1, r3
 80011c4:	6163      	str	r3, [r4, #20]
  oqp->q_counter -= n;
 80011c6:	60a2      	str	r2, [r4, #8]
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
 80011c8:	b10f      	cbz	r7, 80011ce <oqWriteTimeout+0x6e>
        nfy(oqp);
 80011ca:	4620      	mov	r0, r4
 80011cc:	47b8      	blx	r7
 80011ce:	f38a 8811 	msr	BASEPRI, sl
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      n  -= done;
 80011d2:	ebab 0b05 	sub.w	fp, fp, r5
      bp += done;
 80011d6:	442e      	add	r6, r5
 80011d8:	f389 8811 	msr	BASEPRI, r9
  while (n > 0U) {
 80011dc:	f1bb 0f00 	cmp.w	fp, #0
 80011e0:	d1cf      	bne.n	8001182 <oqWriteTimeout+0x22>
 80011e2:	2300      	movs	r3, #0
  if (n > oqGetEmptyI(oqp)) {
 80011e4:	9803      	ldr	r0, [sp, #12]
 80011e6:	f383 8811 	msr	BASEPRI, r3
    }
  }

  osalSysUnlock();
  return max - n;
}
 80011ea:	b005      	add	sp, #20
 80011ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 80011f0:	462a      	mov	r2, r5
 80011f2:	4631      	mov	r1, r6
 80011f4:	f7ff f860 	bl	80002b8 <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
 80011f8:	68e2      	ldr	r2, [r4, #12]
 80011fa:	6162      	str	r2, [r4, #20]
  oqp->q_counter -= n;
 80011fc:	68a2      	ldr	r2, [r4, #8]
 80011fe:	1b52      	subs	r2, r2, r5
 8001200:	60a2      	str	r2, [r4, #8]
    if (done == (size_t)0) {
 8001202:	2d00      	cmp	r5, #0
 8001204:	d1e0      	bne.n	80011c8 <oqWriteTimeout+0x68>
 8001206:	4620      	mov	r0, r4
 8001208:	9902      	ldr	r1, [sp, #8]
 800120a:	f7ff fea1 	bl	8000f50 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
 800120e:	2800      	cmp	r0, #0
 8001210:	d0b7      	beq.n	8001182 <oqWriteTimeout+0x22>
 8001212:	9b03      	ldr	r3, [sp, #12]
 8001214:	eba3 000b 	sub.w	r0, r3, fp
 8001218:	2300      	movs	r3, #0
 800121a:	f383 8811 	msr	BASEPRI, r3
}
 800121e:	b005      	add	sp, #20
 8001220:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8001224:	462a      	mov	r2, r5
 8001226:	4631      	mov	r1, r6
 8001228:	f7ff f846 	bl	80002b8 <memcpy>
    oqp->q_wrptr += n;
 800122c:	6962      	ldr	r2, [r4, #20]
 800122e:	442a      	add	r2, r5
 8001230:	6162      	str	r2, [r4, #20]
 8001232:	e7e3      	b.n	80011fc <oqWriteTimeout+0x9c>
	...

08001240 <_writet>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8001240:	3030      	adds	r0, #48	; 0x30
 8001242:	f7ff bf8d 	b.w	8001160 <oqWriteTimeout>
 8001246:	bf00      	nop
	...

08001250 <_write>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8001250:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8001254:	3030      	adds	r0, #48	; 0x30
 8001256:	f7ff bf83 	b.w	8001160 <oqWriteTimeout>
 800125a:	bf00      	nop
 800125c:	0000      	movs	r0, r0
	...

08001260 <iqReadTimeout>:
                     size_t n, sysinterval_t timeout) {
 8001260:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001264:	b085      	sub	sp, #20
 8001266:	f04f 0920 	mov.w	r9, #32
 800126a:	e9cd 3202 	strd	r3, r2, [sp, #8]
  qnotify_t nfy = iqp->q_notify;
 800126e:	69c7      	ldr	r7, [r0, #28]
 8001270:	f389 8811 	msr	BASEPRI, r9
  while (n > 0U) {
 8001274:	2a00      	cmp	r2, #0
 8001276:	d035      	beq.n	80012e4 <iqReadTimeout+0x84>
 8001278:	4604      	mov	r4, r0
 800127a:	460e      	mov	r6, r1
 800127c:	f04f 0a00 	mov.w	sl, #0
 8001280:	f8dd b00c 	ldr.w	fp, [sp, #12]
  if (n > iqGetFullI(iqp)) {
 8001284:	68a2      	ldr	r2, [r4, #8]
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8001286:	69a1      	ldr	r1, [r4, #24]
  if (n > iqGetFullI(iqp)) {
 8001288:	4593      	cmp	fp, r2
 800128a:	bf98      	it	ls
 800128c:	465d      	movls	r5, fp
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 800128e:	6922      	ldr	r2, [r4, #16]
    n = iqGetFullI(iqp);
 8001290:	bf88      	it	hi
 8001292:	68a5      	ldrhi	r5, [r4, #8]
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8001294:	eba2 0801 	sub.w	r8, r2, r1
  if (n < s1) {
 8001298:	45a8      	cmp	r8, r5
 800129a:	d844      	bhi.n	8001326 <iqReadTimeout+0xc6>
  else if (n > s1) {
 800129c:	d229      	bcs.n	80012f2 <iqReadTimeout+0x92>
    s2 = n - s1;
 800129e:	eba5 0308 	sub.w	r3, r5, r8
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 80012a2:	4642      	mov	r2, r8
 80012a4:	4630      	mov	r0, r6
    s2 = n - s1;
 80012a6:	9301      	str	r3, [sp, #4]
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 80012a8:	f7ff f806 	bl	80002b8 <memcpy>
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
 80012ac:	eb06 0008 	add.w	r0, r6, r8
 80012b0:	f8dd 8004 	ldr.w	r8, [sp, #4]
 80012b4:	68e1      	ldr	r1, [r4, #12]
 80012b6:	4642      	mov	r2, r8
 80012b8:	f7fe fffe 	bl	80002b8 <memcpy>
    iqp->q_rdptr = iqp->q_buffer + s2;
 80012bc:	4643      	mov	r3, r8
  iqp->q_counter -= n;
 80012be:	68a2      	ldr	r2, [r4, #8]
    iqp->q_rdptr = iqp->q_buffer + s2;
 80012c0:	68e1      	ldr	r1, [r4, #12]
  iqp->q_counter -= n;
 80012c2:	1b52      	subs	r2, r2, r5
    iqp->q_rdptr = iqp->q_buffer + s2;
 80012c4:	18cb      	adds	r3, r1, r3
 80012c6:	61a3      	str	r3, [r4, #24]
  iqp->q_counter -= n;
 80012c8:	60a2      	str	r2, [r4, #8]
      if (nfy != NULL) {
 80012ca:	b10f      	cbz	r7, 80012d0 <iqReadTimeout+0x70>
        nfy(iqp);
 80012cc:	4620      	mov	r0, r4
 80012ce:	47b8      	blx	r7
 80012d0:	f38a 8811 	msr	BASEPRI, sl
      n  -= done;
 80012d4:	ebab 0b05 	sub.w	fp, fp, r5
      bp += done;
 80012d8:	442e      	add	r6, r5
 80012da:	f389 8811 	msr	BASEPRI, r9
  while (n > 0U) {
 80012de:	f1bb 0f00 	cmp.w	fp, #0
 80012e2:	d1cf      	bne.n	8001284 <iqReadTimeout+0x24>
 80012e4:	2300      	movs	r3, #0
  if (n > iqGetFullI(iqp)) {
 80012e6:	9803      	ldr	r0, [sp, #12]
 80012e8:	f383 8811 	msr	BASEPRI, r3
}
 80012ec:	b005      	add	sp, #20
 80012ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 80012f2:	462a      	mov	r2, r5
 80012f4:	4630      	mov	r0, r6
 80012f6:	f7fe ffdf 	bl	80002b8 <memcpy>
    iqp->q_rdptr = iqp->q_buffer;
 80012fa:	68e2      	ldr	r2, [r4, #12]
 80012fc:	61a2      	str	r2, [r4, #24]
  iqp->q_counter -= n;
 80012fe:	68a2      	ldr	r2, [r4, #8]
 8001300:	1b52      	subs	r2, r2, r5
 8001302:	60a2      	str	r2, [r4, #8]
    if (done == (size_t)0) {
 8001304:	2d00      	cmp	r5, #0
 8001306:	d1e0      	bne.n	80012ca <iqReadTimeout+0x6a>
 8001308:	4620      	mov	r0, r4
 800130a:	9902      	ldr	r1, [sp, #8]
 800130c:	f7ff fe20 	bl	8000f50 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
 8001310:	2800      	cmp	r0, #0
 8001312:	d0b7      	beq.n	8001284 <iqReadTimeout+0x24>
 8001314:	9b03      	ldr	r3, [sp, #12]
 8001316:	eba3 000b 	sub.w	r0, r3, fp
 800131a:	2300      	movs	r3, #0
 800131c:	f383 8811 	msr	BASEPRI, r3
}
 8001320:	b005      	add	sp, #20
 8001322:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8001326:	462a      	mov	r2, r5
 8001328:	4630      	mov	r0, r6
 800132a:	f7fe ffc5 	bl	80002b8 <memcpy>
    iqp->q_rdptr += n;
 800132e:	69a2      	ldr	r2, [r4, #24]
 8001330:	442a      	add	r2, r5
 8001332:	61a2      	str	r2, [r4, #24]
 8001334:	e7e3      	b.n	80012fe <iqReadTimeout+0x9e>
 8001336:	bf00      	nop
	...

08001340 <_readt>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8001340:	300c      	adds	r0, #12
 8001342:	f7ff bf8d 	b.w	8001260 <iqReadTimeout>
 8001346:	bf00      	nop
	...

08001350 <_read>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8001350:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8001354:	300c      	adds	r0, #12
 8001356:	f7ff bf83 	b.w	8001260 <iqReadTimeout>
 800135a:	bf00      	nop
 800135c:	0000      	movs	r0, r0
	...

08001360 <main>:
void nvicInit(void) {
#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC) ||   \
    defined(__CORE_CM23_H_GENERIC)
  uint32_t n = 0U;
#else
  uint32_t n = SCnSCB->ICTR;
 8001360:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
#endif

  for (uint32_t i = 0U; i <= n; i++) {
 8001364:	2200      	movs	r2, #0
    NVIC->__ICER[i] = 0xFFFFFFFFU;
 8001366:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff

/*
* Application entry point.
*/

int main(void) {
 800136a:	b580      	push	{r7, lr}
  uint32_t n = SCnSCB->ICTR;
 800136c:	6858      	ldr	r0, [r3, #4]
 800136e:	b086      	sub	sp, #24
    NVIC->__ICER[i] = 0xFFFFFFFFU;
 8001370:	0093      	lsls	r3, r2, #2
 8001372:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 8001376:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
  for (uint32_t i = 0U; i <= n; i++) {
 800137a:	4290      	cmp	r0, r2
    NVIC->__ICER[i] = 0xFFFFFFFFU;
 800137c:	f8c3 8080 	str.w	r8, [r3, #128]	; 0x80
  for (uint32_t i = 0U; i <= n; i++) {
 8001380:	f102 0201 	add.w	r2, r2, #1
    NVIC->__ICPR[i] = 0xFFFFFFFFU;
 8001384:	f8c3 8180 	str.w	r8, [r3, #384]	; 0x180
  for (uint32_t i = 0U; i <= n; i++) {
 8001388:	d1f2      	bne.n	8001370 <main+0x10>
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
 800138a:	2701      	movs	r7, #1
  sdObjectInit(&SD3, NULL, notify3);
 800138c:	4cc8      	ldr	r4, [pc, #800]	; (80016b0 <main+0x350>)
 800138e:	49c9      	ldr	r1, [pc, #804]	; (80016b4 <main+0x354>)
 8001390:	4620      	mov	r0, r4
 8001392:	f7ff f80d 	bl	80003b0 <sdObjectInit.constprop.0>
  SD3.uart_basic = UART3;
 8001396:	4bc8      	ldr	r3, [pc, #800]	; (80016b8 <main+0x358>)
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 8001398:	2600      	movs	r6, #0
 800139a:	f8c4 3254 	str.w	r3, [r4, #596]	; 0x254
 */
void usb_lld_init(void) {

#if PLATFORM_USB_USE_USB1 == TRUE
  /* Driver initialization.*/
    USBD1.dev_gr = (usb_gr*)USBHS_REG_BASE;
 800139e:	f04f 44a0 	mov.w	r4, #1342177280	; 0x50000000
  sdObjectInit(&SD4, NULL, notify4);
 80013a2:	4dc6      	ldr	r5, [pc, #792]	; (80016bc <main+0x35c>)
 80013a4:	49c6      	ldr	r1, [pc, #792]	; (80016c0 <main+0x360>)
 80013a6:	4628      	mov	r0, r5
 80013a8:	f7ff f802 	bl	80003b0 <sdObjectInit.constprop.0>
 80013ac:	4bc5      	ldr	r3, [pc, #788]	; (80016c4 <main+0x364>)
    reg = RCU_CFG0;
 80013ae:	49c6      	ldr	r1, [pc, #792]	; (80016c8 <main+0x368>)
  usbp->state        = USB_STOP;
 80013b0:	701f      	strb	r7, [r3, #0]
 80013b2:	680a      	ldr	r2, [r1, #0]
  SD4.uart_basic = UART4;
 80013b4:	48c5      	ldr	r0, [pc, #788]	; (80016cc <main+0x36c>)
    reg &= ~RCU_CFG0_USBHSPSC;
 80013b6:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
    RCU_CFG0 = (reg | usb_psc);
 80013ba:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 80013be:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 80013c2:	600a      	str	r2, [r1, #0]
    USBD1.dev_dr = (usb_dr*)(USBHS_REG_BASE + 0x0800);
 80013c4:	4ac2      	ldr	r2, [pc, #776]	; (80016d0 <main+0x370>)
    usbp->out_params[i] = NULL;
  }
  usbp->transmitting = 0;
 80013c6:	e9c3 6601 	strd	r6, r6, [r3, #4]
 80013ca:	f8c5 0254 	str.w	r0, [r5, #596]	; 0x254
    usbObjectInit(&USBD1);

    rcu_usb_clock_config(RCU_CKUSB_CKPLL_DIV3_5);   
    rcu_periph_clock_enable(RCU_USBHS);
 80013ce:	f240 500c 	movw	r0, #1292	; 0x50c
    USBD1.dev_dr = (usb_dr*)(USBHS_REG_BASE + 0x0800);
 80013d2:	e9c3 4218 	strd	r4, r2, [r3, #96]	; 0x60
    usbp->in_params[i]  = NULL;
 80013d6:	621e      	str	r6, [r3, #32]
    usbp->out_params[i] = NULL;
 80013d8:	631e      	str	r6, [r3, #48]	; 0x30
    usbp->in_params[i]  = NULL;
 80013da:	625e      	str	r6, [r3, #36]	; 0x24
    usbp->out_params[i] = NULL;
 80013dc:	635e      	str	r6, [r3, #52]	; 0x34
    usbp->in_params[i]  = NULL;
 80013de:	629e      	str	r6, [r3, #40]	; 0x28
    usbp->out_params[i] = NULL;
 80013e0:	639e      	str	r6, [r3, #56]	; 0x38
    usbp->in_params[i]  = NULL;
 80013e2:	62de      	str	r6, [r3, #44]	; 0x2c
    usbp->out_params[i] = NULL;
 80013e4:	63de      	str	r6, [r3, #60]	; 0x3c
    rcu_periph_clock_enable(RCU_USBHS);
 80013e6:	f7ff f943 	bl	8000670 <rcu_periph_clock_enable>
 */

void st_lld_init(void) {
    timer_parameter_struct timer_initpara;

    rcu_periph_clock_enable(RCU_TIMER1);
 80013ea:	f44f 60e0 	mov.w	r0, #1792	; 0x700
 80013ee:	f7ff f93f 	bl	8000670 <rcu_periph_clock_enable>
        rcu_periph_reset_enable(RCU_TIMER0RST);
        rcu_periph_reset_disable(RCU_TIMER0RST);
        break;
    case TIMER1:
        /* reset TIMER1 */
        rcu_periph_reset_enable(RCU_TIMER1RST);
 80013f2:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80013f6:	f7ff f93b 	bl	8000670 <rcu_periph_clock_enable>
    \retval     none
*/
void timer_init(uint32_t timer_periph, timer_parameter_struct* initpara)
{
    /* configure the counter prescaler value */
    TIMER_PSC(timer_periph) = (uint16_t)initpara->prescaler;
 80013fa:	f244 109f 	movw	r0, #16799	; 0x419f

    /* configure the counter direction and aligned mode */
    if((TIMER0 == timer_periph) || (TIMER1 == timer_periph) || (TIMER2 == timer_periph)
        || (TIMER3 == timer_periph) || (TIMER4 == timer_periph) || (TIMER7 == timer_periph)){
        TIMER_CTL0(timer_periph) &= (~(uint32_t)(TIMER_CTL0_DIR | TIMER_CTL0_CAM));
 80013fe:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    RCU_REG_VAL(periph_reset) &= ~BIT(RCU_BIT_POS(periph_reset));
 8001402:	49b4      	ldr	r1, [pc, #720]	; (80016d4 <main+0x374>)
  NVIC->__IPR[_IP_IDX(n)] = (NVIC->__IPR[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                            (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001404:	f04f 5c80 	mov.w	ip, #268435456	; 0x10000000
 8001408:	680a      	ldr	r2, [r1, #0]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 800140a:	f04f 0e40 	mov.w	lr, #64	; 0x40
 800140e:	f022 0201 	bic.w	r2, r2, #1
 8001412:	600a      	str	r2, [r1, #0]
    TIMER_PSC(timer_periph) = (uint16_t)initpara->prescaler;
 8001414:	4ab0      	ldr	r2, [pc, #704]	; (80016d8 <main+0x378>)
  tmp->cumulative = (rttime_t)0;
 8001416:	2100      	movs	r1, #0
 8001418:	6010      	str	r0, [r2, #0]
 800141a:	2000      	movs	r0, #0
        TIMER_CTL0(timer_periph) &= (~(uint32_t)(TIMER_CTL0_DIR | TIMER_CTL0_CAM));
 800141c:	681a      	ldr	r2, [r3, #0]
 800141e:	2404      	movs	r4, #4
 8001420:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8001424:	601a      	str	r2, [r3, #0]
        TIMER_CTL0(timer_periph) |= (uint32_t)(initpara->alignedmode & ALIGNEDMODE_MASK);
 8001426:	681a      	ldr	r2, [r3, #0]
        TIMER_CTL0(timer_periph) |= (uint32_t)(initpara->counterdirection & COUNTERDIRECTION_MASK);            
    }
    
    /* configure the autoreload value */
    TIMER_CAR(timer_periph) = (uint32_t)initpara->period;
 8001428:	f8df 930c 	ldr.w	r9, [pc, #780]	; 8001738 <main+0x3d8>
        TIMER_CTL0(timer_periph) |= (uint32_t)(initpara->alignedmode & ALIGNEDMODE_MASK);
 800142c:	601a      	str	r2, [r3, #0]
        TIMER_CTL0(timer_periph) |= (uint32_t)(initpara->counterdirection & COUNTERDIRECTION_MASK);            
 800142e:	681a      	ldr	r2, [r3, #0]
 8001430:	601a      	str	r2, [r3, #0]
    TIMER_CAR(timer_periph) = (uint32_t)initpara->period;
 8001432:	f8c9 8000 	str.w	r8, [r9]

    if((TIMER5 != timer_periph) && (TIMER6 != timer_periph)){
        /* reset the CKDIV bit */
        TIMER_CTL0(timer_periph) &= (~(uint32_t)TIMER_CTL0_CKDIV);
 8001436:	681a      	ldr	r2, [r3, #0]
 8001438:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 800143c:	601a      	str	r2, [r3, #0]
        TIMER_CTL0(timer_periph) |= (uint32_t)(initpara->clockdivision & CLOCKDIVISION_MASK);
 800143e:	681a      	ldr	r2, [r3, #0]
 8001440:	601a      	str	r2, [r3, #0]
        /* configure the repetition counter value */
        TIMER_CREP(timer_periph) = (uint32_t)initpara->repetitioncounter;
    }

    /* generate an update event */
    TIMER_SWEVG(timer_periph) |= (uint32_t)TIMER_SWEVG_UPG;
 8001442:	f859 2c18 	ldr.w	r2, [r9, #-24]
 8001446:	433a      	orrs	r2, r7
 8001448:	f849 2c18 	str.w	r2, [r9, #-24]
    \param[out] none
    \retval     none
*/
void timer_auto_reload_shadow_enable(uint32_t timer_periph)
{
    TIMER_CTL0(timer_periph) |= (uint32_t)TIMER_CTL0_ARSE;
 800144c:	681a      	ldr	r2, [r3, #0]
 */
void chSysInit(void) {
  unsigned i;

  /* System object initialization.*/
  ch_system.state = ch_sys_initializing;
 800144e:	f8df 92ec 	ldr.w	r9, [pc, #748]	; 800173c <main+0x3dc>
 8001452:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8001456:	601a      	str	r2, [r3, #0]
    TIMER_CTL0(timer_periph) |= (uint32_t)TIMER_CTL0_CEN;
 8001458:	681a      	ldr	r2, [r3, #0]
 800145a:	433a      	orrs	r2, r7
 800145c:	601a      	str	r2, [r3, #0]
 800145e:	4b9f      	ldr	r3, [pc, #636]	; (80016dc <main+0x37c>)
 8001460:	f883 e31c 	strb.w	lr, [r3, #796]	; 0x31c
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001464:	f8c3 c180 	str.w	ip, [r3, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001468:	f8c3 c000 	str.w	ip, [r3]
 800146c:	e9cd 0104 	strd	r0, r1, [sp, #16]
  tmp->last       = (rtcnt_t)0;
 8001470:	e9cd 6601 	strd	r6, r6, [sp, #4]
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  tcp->offset = (rtcnt_t)0;
 8001474:	e9c9 6601 	strd	r6, r6, [r9, #4]
  tmp->n          = (ucnt_t)0;
 8001478:	9603      	str	r6, [sp, #12]
  tmp->best       = (rtcnt_t)-1;
 800147a:	f8cd 8000 	str.w	r8, [sp]
 800147e:	f889 7000 	strb.w	r7, [r9]
  chTMObjectInit(&tm);
  i = TM_CALIBRATION_LOOP;
  do {
    chTMStartMeasurementX(&tm);
 8001482:	4668      	mov	r0, sp
 8001484:	f7ff f96c 	bl	8000760 <chTMStartMeasurementX>
    chTMStopMeasurementX(&tm);
 8001488:	4668      	mov	r0, sp
 800148a:	f7ff f941 	bl	8000710 <chTMStopMeasurementX>
    i--;
  } while (i > 0U);
 800148e:	3c01      	subs	r4, #1
 8001490:	d1f7      	bne.n	8001482 <main+0x122>
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
  mp->object_size = size;
 8001492:	f04f 0c14 	mov.w	ip, #20
 8001496:	271c      	movs	r7, #28
  mp->align = align;
 8001498:	2604      	movs	r6, #4
  ch_memcore.basemem = __heap_base__;
 800149a:	4991      	ldr	r1, [pc, #580]	; (80016e0 <main+0x380>)
  ch_memcore.topmem  = __heap_end__;
 800149c:	f8df e2a0 	ldr.w	lr, [pc, #672]	; 8001740 <main+0x3e0>
 *
 * @notapi
 */
void __heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
 80014a0:	4a90      	ldr	r2, [pc, #576]	; (80016e4 <main+0x384>)
 */
void chCoreGetStatusX(memory_area_t *map) {

  map->base = ch_memcore.basemem;
  /*lint -save -e9033 [10.8] The cast is safe.*/
  map->size = (size_t)(ch_memcore.topmem - ch_memcore.basemem);
 80014a2:	ebae 0001 	sub.w	r0, lr, r1
 80014a6:	6090      	str	r0, [r2, #8]
  ch_memcore.basemem = __heap_base__;
 80014a8:	488f      	ldr	r0, [pc, #572]	; (80016e8 <main+0x388>)
  qp->next = qp;
 80014aa:	4b90      	ldr	r3, [pc, #576]	; (80016ec <main+0x38c>)
  ch_memcore.topmem  = __heap_end__;
 80014ac:	e9c0 1e00 	strd	r1, lr, [r0]
 80014b0:	488f      	ldr	r0, [pc, #572]	; (80016f0 <main+0x390>)
  mp->object_size = size;
 80014b2:	631f      	str	r7, [r3, #48]	; 0x30
 80014b4:	6010      	str	r0, [r2, #0]
 80014b6:	eb02 000c 	add.w	r0, r2, ip
  qp->prev = qp;
 80014ba:	e9c2 0005 	strd	r0, r0, [r2, #20]
  } while ((c != (char)0) && (i > 0U));
}

static inline void dyn_list_init(dyn_list_t *dlp) {

  dlp->next = (dyn_element_t *)dlp;
 80014be:	f103 0010 	add.w	r0, r3, #16
 80014c2:	6118      	str	r0, [r3, #16]
 80014c4:	f103 0024 	add.w	r0, r3, #36	; 0x24
 80014c8:	f103 073c 	add.w	r7, r3, #60	; 0x3c
 80014cc:	6258      	str	r0, [r3, #36]	; 0x24
 80014ce:	f103 0028 	add.w	r0, r3, #40	; 0x28
  core_id = port_get_core_id();
#else
  core_id = 0U;
#endif
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
  ch_system.instances[core_id] = oip;
 80014d2:	f8df 8270 	ldr.w	r8, [pc, #624]	; 8001744 <main+0x3e4>
  map->base = ch_memcore.basemem;
 80014d6:	6051      	str	r1, [r2, #4]
  chCoreGetStatusX(&default_heap.area);
  H_FREE_NEXT(&default_heap.header) = NULL;
  H_FREE_PAGES(&default_heap.header) = 0;
 80014d8:	e9c2 4403 	strd	r4, r4, [r2, #12]
  mp->provider = provider;
 80014dc:	4985      	ldr	r1, [pc, #532]	; (80016f4 <main+0x394>)
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  ch_queue_init(&mp->queue);
  mp->owner = NULL;
 80014de:	61d4      	str	r4, [r2, #28]
 80014e0:	6298      	str	r0, [r3, #40]	; 0x28
  tcp->offset = tm.best;
 80014e2:	9a00      	ldr	r2, [sp, #0]

  /* Core associated to this instance.*/
  oip->core_id = core_id;

  /* Keeping a reference to the configuration data.*/
  oip->config = oicp;
 80014e4:	4884      	ldr	r0, [pc, #528]	; (80016f8 <main+0x398>)
 80014e6:	63df      	str	r7, [r3, #60]	; 0x3c
 80014e8:	f103 0740 	add.w	r7, r3, #64	; 0x40
 80014ec:	641f      	str	r7, [r3, #64]	; 0x40
 80014ee:	f103 0744 	add.w	r7, r3, #68	; 0x44
 80014f2:	e9c3 3300 	strd	r3, r3, [r3]
  ch_system.instances[core_id] = oip;
 80014f6:	e9c9 8201 	strd	r8, r2, [r9, #4]
 80014fa:	609c      	str	r4, [r3, #8]
  mp->next = NULL;
 80014fc:	615c      	str	r4, [r3, #20]
 80014fe:	62dc      	str	r4, [r3, #44]	; 0x2c
  mp->object_size = size;
 8001500:	f8c3 c018 	str.w	ip, [r3, #24]
 8001504:	645f      	str	r7, [r3, #68]	; 0x44
  mp->align = align;
 8001506:	61de      	str	r6, [r3, #28]
 8001508:	635e      	str	r6, [r3, #52]	; 0x34
  mp->provider = provider;
 800150a:	6219      	str	r1, [r3, #32]
 800150c:	6399      	str	r1, [r3, #56]	; 0x38
  oip->core_id = core_id;
 800150e:	f8c8 4030 	str.w	r4, [r8, #48]	; 0x30
  oip->config = oicp;
 8001512:	f8c8 0038 	str.w	r0, [r8, #56]	; 0x38
 8001516:	f384 8811 	msr	BASEPRI, r4
  __ASM volatile ("cpsie i" : : : "memory");
 800151a:	b662      	cpsie	i
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800151c:	f64f 02ff 	movw	r2, #63743	; 0xf8ff
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001520:	2010      	movs	r0, #16
 8001522:	f04f 0a20 	mov.w	sl, #32
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001526:	4b75      	ldr	r3, [pc, #468]	; (80016fc <main+0x39c>)
  pqp->prev = pqp;
 8001528:	f8c8 8004 	str.w	r8, [r8, #4]
 800152c:	68d9      	ldr	r1, [r3, #12]
  pqp->prio = (tprio_t)0;
 800152e:	f8c8 4008 	str.w	r4, [r8, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001532:	4011      	ands	r1, r2
  reg_value  =  (reg_value                                   |
 8001534:	4a72      	ldr	r2, [pc, #456]	; (8001700 <main+0x3a0>)
 *
 * @notapi
 */
static inline void __rfcu_object_init(rfcu_t *rfcup) {

  rfcup->mask = (rfcu_mask_t)0;
 8001536:	f8c8 4034 	str.w	r4, [r8, #52]	; 0x34
 800153a:	430a      	orrs	r2, r1
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800153c:	4971      	ldr	r1, [pc, #452]	; (8001704 <main+0x3a4>)
  SCB->AIRCR =  reg_value;
 800153e:	60da      	str	r2, [r3, #12]
 8001540:	68ca      	ldr	r2, [r1, #12]

  ch_dlist_init(&vtlp->dlist);
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  vtlp->lasttime = (systime_t)0;
 8001542:	f8c8 401c 	str.w	r4, [r8, #28]
 8001546:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800154a:	60ca      	str	r2, [r1, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 800154c:	496e      	ldr	r1, [pc, #440]	; (8001708 <main+0x3a8>)
  tp->owner             = oip;
 800154e:	f8c8 8054 	str.w	r8, [r8, #84]	; 0x54
 8001552:	680a      	ldr	r2, [r1, #0]
  tp->mtxlist           = NULL;
 8001554:	f8c8 407c 	str.w	r4, [r8, #124]	; 0x7c
 8001558:	f042 0201 	orr.w	r2, r2, #1
 800155c:	600a      	str	r2, [r1, #0]
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800155e:	77d8      	strb	r0, [r3, #31]
 8001560:	f883 a022 	strb.w	sl, [r3, #34]	; 0x22
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
#if CH_CFG_USE_TIMESTAMP == TRUE
  vtlp->laststamp = (systimestamp_t)chVTGetSystemTimeX();
 8001564:	2300      	movs	r3, #0
  tp->hdr.pqueue.prio   = prio;
 8001566:	f04f 0c80 	mov.w	ip, #128	; 0x80
  dlhp->delta = (sysinterval_t)-1;
 800156a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  oip->rlist.current->wabase = oicp->mainthread_base;
  oip->rlist.current->waend  = oicp->mainthread_end;
#endif

  /* Setting up the caller as current thread.*/
  oip->rlist.current->state = CH_STATE_CURRENT;
 800156e:	2101      	movs	r1, #1
  tp->state             = CH_STATE_WTSTART;
 8001570:	2702      	movs	r7, #2
  return (systime_t)TIMER_CNT(TIMER1);
 8001572:	4a66      	ldr	r2, [pc, #408]	; (800170c <main+0x3ac>)
  pqp->next = pqp;
 8001574:	f8c8 8000 	str.w	r8, [r8]
 8001578:	6812      	ldr	r2, [r2, #0]
  tp->hdr.pqueue.prio   = prio;
 800157a:	f8c8 c044 	str.w	ip, [r8, #68]	; 0x44
 800157e:	e9c8 2308 	strd	r2, r3, [r8, #32]
  tp->name              = name;
 8001582:	4a63      	ldr	r2, [pc, #396]	; (8001710 <main+0x3b0>)
  oip->rlist.current->wabase = oicp->mainthread_base;
 8001584:	4b63      	ldr	r3, [pc, #396]	; (8001714 <main+0x3b4>)
 8001586:	f8c8 2058 	str.w	r2, [r8, #88]	; 0x58
  lp->next = lp;
 800158a:	f108 026c 	add.w	r2, r8, #108	; 0x6c
 800158e:	f8c8 206c 	str.w	r2, [r8, #108]	; 0x6c
  tp->realprio          = prio;
 8001592:	f8c8 c080 	str.w	ip, [r8, #128]	; 0x80
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
 8001596:	f108 023c 	add.w	r2, r8, #60	; 0x3c
  qp->next = qp;
 800159a:	f108 0c70 	add.w	ip, r8, #112	; 0x70
  qp->prev = qp;
 800159e:	e9c8 cc1c 	strd	ip, ip, [r8, #112]	; 0x70
 80015a2:	f8c8 200c 	str.w	r2, [r8, #12]
  oip->rlist.current->waend  = oicp->mainthread_end;
 80015a6:	f8df c1a0 	ldr.w	ip, [pc, #416]	; 8001748 <main+0x3e8>
  dlhp->next  = dlhp;
 80015aa:	f108 0210 	add.w	r2, r8, #16
  oip->rlist.current->wabase = oicp->mainthread_base;
 80015ae:	f8c8 305c 	str.w	r3, [r8, #92]	; 0x5c
  tp->wabase = tdp->wbase;
 80015b2:	4b59      	ldr	r3, [pc, #356]	; (8001718 <main+0x3b8>)
  dlhp->prev  = dlhp;
 80015b4:	e9c8 2204 	strd	r2, r2, [r8, #16]
  dlhp->delta = (sysinterval_t)-1;
 80015b8:	f8c8 0018 	str.w	r0, [r8, #24]
  p->prev->next = p;
 80015bc:	f108 024c 	add.w	r2, r8, #76	; 0x4c
  p->prev       = qp->prev;
 80015c0:	f108 0028 	add.w	r0, r8, #40	; 0x28
 80015c4:	f8c8 0050 	str.w	r0, [r8, #80]	; 0x50
  p->prev->next = p;
 80015c8:	f8c8 2028 	str.w	r2, [r8, #40]	; 0x28
  tp->epending          = (eventmask_t)0;
 80015cc:	f8c8 4078 	str.w	r4, [r8, #120]	; 0x78
 *
 * @notapi
 */
static inline void __dbg_object_init(system_debug_t *sdp) {

  sdp->panic_msg = NULL;
 80015d0:	f8c8 4088 	str.w	r4, [r8, #136]	; 0x88
  oip->rlist.current->waend  = oicp->mainthread_end;
 80015d4:	f8c8 c060 	str.w	ip, [r8, #96]	; 0x60
  p->prev       = qp->prev;
 80015d8:	e9c3 0224 	strd	r0, r2, [r3, #144]	; 0x90
  tp->waend  = tdp->wend;
 80015dc:	f103 02e0 	add.w	r2, r3, #224	; 0xe0
 80015e0:	e9c3 3228 	strd	r3, r2, [r3, #160]	; 0xa0
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 80015e4:	f103 025c 	add.w	r2, r3, #92	; 0x5c
 80015e8:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
 80015ec:	4a4b      	ldr	r2, [pc, #300]	; (800171c <main+0x3bc>)
 80015ee:	484c      	ldr	r0, [pc, #304]	; (8001720 <main+0x3c0>)
 80015f0:	67da      	str	r2, [r3, #124]	; 0x7c
  tp->name              = name;
 80015f2:	4a4c      	ldr	r2, [pc, #304]	; (8001724 <main+0x3c4>)
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 80015f4:	65d8      	str	r0, [r3, #92]	; 0x5c
  tp->name              = name;
 80015f6:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  lp->next = lp;
 80015fa:	f103 02b0 	add.w	r2, r3, #176	; 0xb0
  p->prev->next = p;
 80015fe:	f103 0090 	add.w	r0, r3, #144	; 0x90
  lp->next = lp;
 8001602:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
  qp->next = qp;
 8001606:	f103 02b4 	add.w	r2, r3, #180	; 0xb4
  p->prev->next = p;
 800160a:	f8c8 004c 	str.w	r0, [r8, #76]	; 0x4c
  qp->prev      = p;
 800160e:	f8c8 002c 	str.w	r0, [r8, #44]	; 0x2c
  tp->epending          = (eventmask_t)0;
 8001612:	e9c3 442f 	strd	r4, r4, [r3, #188]	; 0xbc
  qp->prev = qp;
 8001616:	e9c3 222d 	strd	r2, r2, [r3, #180]	; 0xb4
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800161a:	661c      	str	r4, [r3, #96]	; 0x60
  tp->owner             = oip;
 800161c:	f8c3 8098 	str.w	r8, [r3, #152]	; 0x98
  oip->rlist.current->state = CH_STATE_CURRENT;
 8001620:	f8a8 1064 	strh.w	r1, [r8, #100]	; 0x64
  tp->refs              = (trefs_t)1;
 8001624:	f888 1066 	strb.w	r1, [r8, #102]	; 0x66
  tp->hdr.pqueue.prio   = prio;
 8001628:	f8c3 1088 	str.w	r1, [r3, #136]	; 0x88
  tp->realprio          = prio;
 800162c:	f8c3 10c4 	str.w	r1, [r3, #196]	; 0xc4
  tp->refs              = (trefs_t)1;
 8001630:	f883 10aa 	strb.w	r1, [r3, #170]	; 0xaa
  return chSchReadyI(chThdCreateSuspendedI(tdp));
 8001634:	f103 0080 	add.w	r0, r3, #128	; 0x80
  tp->state             = CH_STATE_WTSTART;
 8001638:	f8a3 70a8 	strh.w	r7, [r3, #168]	; 0xa8
  return chSchReadyI(chThdCreateSuspendedI(tdp));
 800163c:	f7ff f920 	bl	8000880 <chSchReadyI>

  /* Initializing default OS instance.*/
  chInstanceObjectInit(&ch0, &ch_core0_cfg);

  /* It is alive now.*/
  ch_system.state = ch_sys_running;
 8001640:	f889 7000 	strb.w	r7, [r9]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001644:	f384 8811 	msr	BASEPRI, r4
    *   RTOS is active.
    */
    halInit();
    chSysInit();

    palSetLineMode(LINE_UART3_TX, GDPAL_MODE(GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ));
 8001648:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800164c:	2118      	movs	r1, #24
 800164e:	4836      	ldr	r0, [pc, #216]	; (8001728 <main+0x3c8>)
 8001650:	f7fe fede 	bl	8000410 <gpio_init.constprop.0>
    palSetLineMode(LINE_UART3_RX, GDPAL_MODE(GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ));
 8001654:	4631      	mov	r1, r6
 8001656:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800165a:	4833      	ldr	r0, [pc, #204]	; (8001728 <main+0x3c8>)
 800165c:	f7fe fed8 	bl	8000410 <gpio_init.constprop.0>

    palSetLineMode(LINE_UART4_TX, GDPAL_MODE(GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ));
 8001660:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8001664:	2118      	movs	r1, #24
 8001666:	4830      	ldr	r0, [pc, #192]	; (8001728 <main+0x3c8>)
 8001668:	f7fe fed2 	bl	8000410 <gpio_init.constprop.0>
    palSetLineMode(LINE_UART4_RX, GDPAL_MODE(GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ));
 800166c:	4632      	mov	r2, r6
 800166e:	4631      	mov	r1, r6
 8001670:	482e      	ldr	r0, [pc, #184]	; (800172c <main+0x3cc>)
 8001672:	f7fe fecd 	bl	8000410 <gpio_init.constprop.0>
 8001676:	f38a 8811 	msr	BASEPRI, sl
  if (sdp->state == SD_STOP) {
 800167a:	7a2b      	ldrb	r3, [r5, #8]
 800167c:	2b01      	cmp	r3, #1
 800167e:	f000 80a9 	beq.w	80017d4 <main+0x474>
    sdp->state = SD_READY;
 8001682:	2602      	movs	r6, #2
 8001684:	2400      	movs	r4, #0
 8001686:	722e      	strb	r6, [r5, #8]
 8001688:	f384 8811 	msr	BASEPRI, r4
    if(USART5 == usart_periph){
        USART5_RT(usart_periph) &= ~(USART5_RT_RT);
        /* configure USART5 receiver timeout threshold */
        USART5_RT(usart_periph) |= (USART5_RT_RT & rtimeout);
    }else{
        USART_RT(usart_periph) &= ~(USART_RT_RT);
 800168c:	4a28      	ldr	r2, [pc, #160]	; (8001730 <main+0x3d0>)
        USART_CTL3(usart_periph) |= USART_CTL3_RTEN;
 800168e:	4b29      	ldr	r3, [pc, #164]	; (8001734 <main+0x3d4>)
        USART_RT(usart_periph) &= ~(USART_RT_RT);
 8001690:	6811      	ldr	r1, [r2, #0]

    // x1 = chSysGetRealtimeCounterX();
    // x2 = chSysGetRealtimeCounterX();

    // uint32_t system_clock = ;
    chprintf((void*)&SD3, "hello, chibios, %dMHz\n", rcu_clock_freq_get(CK_SYS) / 1000000);  
 8001692:	4620      	mov	r0, r4
 8001694:	f001 417f 	and.w	r1, r1, #4278190080	; 0xff000000
 8001698:	6011      	str	r1, [r2, #0]
        /* configure USARTx(x=0,1,2) receiver timeout threshold */
        USART_RT(usart_periph) |= (USART_RT_RT & rtimeout);
 800169a:	6811      	ldr	r1, [r2, #0]
 800169c:	f04f 0920 	mov.w	r9, #32
 80016a0:	f041 011e 	orr.w	r1, r1, #30
 80016a4:	6011      	str	r1, [r2, #0]
        USART_CTL3(usart_periph) |= USART_CTL3_RTEN;
 80016a6:	681a      	ldr	r2, [r3, #0]
 80016a8:	f042 0201 	orr.w	r2, r2, #1
 80016ac:	601a      	str	r2, [r3, #0]
 80016ae:	e04d      	b.n	800174c <main+0x3ec>
 80016b0:	20000800 	.word	0x20000800
 80016b4:	080004d1 	.word	0x080004d1
 80016b8:	40004c00 	.word	0x40004c00
 80016bc:	20000a58 	.word	0x20000a58
 80016c0:	080004e1 	.word	0x080004e1
 80016c4:	20000cb0 	.word	0x20000cb0
 80016c8:	40021004 	.word	0x40021004
 80016cc:	40005000 	.word	0x40005000
 80016d0:	50000800 	.word	0x50000800
 80016d4:	40021010 	.word	0x40021010
 80016d8:	40000028 	.word	0x40000028
 80016dc:	e000e100 	.word	0xe000e100
 80016e0:	20000fa8 	.word	0x20000fa8
 80016e4:	20000f7c 	.word	0x20000f7c
 80016e8:	20000f68 	.word	0x20000f68
 80016ec:	20000f20 	.word	0x20000f20
 80016f0:	08000491 	.word	0x08000491
 80016f4:	080006e1 	.word	0x080006e1
 80016f8:	08001e88 	.word	0x08001e88
 80016fc:	e000ed00 	.word	0xe000ed00
 8001700:	05fa0300 	.word	0x05fa0300
 8001704:	e000edf0 	.word	0xe000edf0
 8001708:	e0001000 	.word	0xe0001000
 800170c:	40000024 	.word	0x40000024
 8001710:	08001e9c 	.word	0x08001e9c
 8001714:	20000400 	.word	0x20000400
 8001718:	20000e40 	.word	0x20000e40
 800171c:	0800029d 	.word	0x0800029d
 8001720:	08000481 	.word	0x08000481
 8001724:	08001e7c 	.word	0x08001e7c
 8001728:	40011000 	.word	0x40011000
 800172c:	40011400 	.word	0x40011400
 8001730:	40005084 	.word	0x40005084
 8001734:	40005080 	.word	0x40005080
 8001738:	4000002c 	.word	0x4000002c
 800173c:	20000f70 	.word	0x20000f70
 8001740:	20020000 	.word	0x20020000
 8001744:	20000d98 	.word	0x20000d98
 8001748:	20000800 	.word	0x20000800
    \param[out] none
    \retval     none
*/
void usart_interrupt_enable(uint32_t usart_periph, usart_interrupt_enum interrupt)
{
    USART_REG_VAL(usart_periph, interrupt) |= BIT(USART_BIT_POS(interrupt));
 800174c:	681a      	ldr	r2, [r3, #0]
 800174e:	f042 0210 	orr.w	r2, r2, #16
 8001752:	601a      	str	r2, [r3, #0]
 8001754:	f7fe fecc 	bl	80004f0 <rcu_clock_freq_get>
 8001758:	4b7a      	ldr	r3, [pc, #488]	; (8001944 <main+0x5e4>)
 800175a:	497b      	ldr	r1, [pc, #492]	; (8001948 <main+0x5e8>)
 800175c:	fba3 3200 	umull	r3, r2, r3, r0
 8001760:	487a      	ldr	r0, [pc, #488]	; (800194c <main+0x5ec>)
 8001762:	0c92      	lsrs	r2, r2, #18
 8001764:	f7ff f984 	bl	8000a70 <chprintf.constprop.0>
 8001768:	f389 8811 	msr	BASEPRI, r9
  elp->wflags   = wflags;
 800176c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  elp->next     = esp->next;
 8001770:	6869      	ldr	r1, [r5, #4]
 8001772:	f8d8 200c 	ldr.w	r2, [r8, #12]
  elp->flags    = (eventflags_t)0;
 8001776:	e9cd 6402 	strd	r6, r4, [sp, #8]
  elp->next     = esp->next;
 800177a:	9100      	str	r1, [sp, #0]
  esp->next     = elp;
 800177c:	f8c5 d004 	str.w	sp, [r5, #4]
  elp->listener = currtp;
 8001780:	9201      	str	r2, [sp, #4]
  elp->wflags   = wflags;
 8001782:	9304      	str	r3, [sp, #16]
 8001784:	f384 8811 	msr	BASEPRI, r4

    chEvtRegisterMaskWithFlags(&SD4.event, &el, EVENT_MASK(1), CHN_BREAK_DETECTED);
    while (true) {
        chEvtWaitOne(EVENT_MASK(1));

        size_t xlen = chnReadTimeout(&SD4, buff, 128, TIME_IMMEDIATE);
 8001788:	4f71      	ldr	r7, [pc, #452]	; (8001950 <main+0x5f0>)
 800178a:	4e72      	ldr	r6, [pc, #456]	; (8001954 <main+0x5f4>)
 800178c:	e011      	b.n	80017b2 <main+0x452>
    chSchGoSleepS(CH_STATE_WTOREVT);
    m = currtp->epending & events;
  }

  m ^= m & (m - (eventmask_t)1);
  currtp->epending &= ~m;
 800178e:	ea23 0302 	bic.w	r3, r3, r2
 8001792:	63e3      	str	r3, [r4, #60]	; 0x3c
 8001794:	2300      	movs	r3, #0
 8001796:	f383 8811 	msr	BASEPRI, r3
 800179a:	682a      	ldr	r2, [r5, #0]
 800179c:	4639      	mov	r1, r7
 800179e:	6a14      	ldr	r4, [r2, #32]
 80017a0:	4630      	mov	r0, r6
 80017a2:	2280      	movs	r2, #128	; 0x80
 80017a4:	47a0      	blx	r4
        // chprintf((void*)&SD4, "system size:%d\n", xlen); 
        chnWrite(&SD4, buff, xlen);  
 80017a6:	682b      	ldr	r3, [r5, #0]
        size_t xlen = chnReadTimeout(&SD4, buff, 128, TIME_IMMEDIATE);
 80017a8:	4602      	mov	r2, r0
        chnWrite(&SD4, buff, xlen);  
 80017aa:	4639      	mov	r1, r7
 80017ac:	4630      	mov	r0, r6
 80017ae:	685b      	ldr	r3, [r3, #4]
 80017b0:	4798      	blx	r3
 80017b2:	f8d8 400c 	ldr.w	r4, [r8, #12]
 80017b6:	f389 8811 	msr	BASEPRI, r9
  m = currtp->epending & events;
 80017ba:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  if (m == (eventmask_t)0) {
 80017bc:	f013 0202 	ands.w	r2, r3, #2
 80017c0:	d1e5      	bne.n	800178e <main+0x42e>
    currtp->u.ewmask = events;
 80017c2:	2302      	movs	r3, #2
    chSchGoSleepS(CH_STATE_WTOREVT);
 80017c4:	200a      	movs	r0, #10
    currtp->u.ewmask = events;
 80017c6:	62e3      	str	r3, [r4, #44]	; 0x2c
    chSchGoSleepS(CH_STATE_WTOREVT);
 80017c8:	f7ff fbaa 	bl	8000f20 <chSchGoSleepS>
    m = currtp->epending & events;
 80017cc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80017ce:	f003 0202 	and.w	r2, r3, #2
 80017d2:	e7dc      	b.n	800178e <main+0x42e>
    rcu_periph_clock_enable(RCU_UART3);
 80017d4:	f240 7013 	movw	r0, #1811	; 0x713
 80017d8:	f7fe ff4a 	bl	8000670 <rcu_periph_clock_enable>
        rcu_periph_reset_enable(RCU_UART3RST);
 80017dc:	f240 4013 	movw	r0, #1043	; 0x413
 80017e0:	f7fe ff46 	bl	8000670 <rcu_periph_clock_enable>
 80017e4:	4a5c      	ldr	r2, [pc, #368]	; (8001958 <main+0x5f8>)
        USART_CTL0(usart_periph) &= ~USART_CTL0_WL;
 80017e6:	4c5d      	ldr	r4, [pc, #372]	; (800195c <main+0x5fc>)
 80017e8:	6813      	ldr	r3, [r2, #0]
         uclk=rcu_clock_freq_get(CK_APB1);
 80017ea:	4638      	mov	r0, r7
 80017ec:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 80017f0:	6013      	str	r3, [r2, #0]
        USART_CTL0(usart_periph) &= ~USART_CTL0_WL;
 80017f2:	6822      	ldr	r2, [r4, #0]
        USART_CTL1(usart_periph) &= ~USART_CTL1_STB; 
 80017f4:	4b5a      	ldr	r3, [pc, #360]	; (8001960 <main+0x600>)
        USART_CTL0(usart_periph) &= ~USART_CTL0_WL;
 80017f6:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 80017fa:	6022      	str	r2, [r4, #0]
        USART_CTL0(usart_periph) |= (USART_CTL0_WL & wlen);
 80017fc:	6822      	ldr	r2, [r4, #0]
 80017fe:	6022      	str	r2, [r4, #0]
        USART_CTL1(usart_periph) &= ~USART_CTL1_STB; 
 8001800:	681a      	ldr	r2, [r3, #0]
 8001802:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8001806:	601a      	str	r2, [r3, #0]
        USART_CTL1(usart_periph) |= (USART_CTL1_STB & stblen);
 8001808:	681a      	ldr	r2, [r3, #0]
 800180a:	601a      	str	r2, [r3, #0]
        USART_CTL0(usart_periph) &= ~(USART_CTL0_PM | USART_CTL0_PCEN);
 800180c:	6823      	ldr	r3, [r4, #0]
 800180e:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 8001812:	6023      	str	r3, [r4, #0]
        USART_CTL0(usart_periph) |= ((USART_CTL0_PM | USART_CTL0_PCEN) & paritycfg);
 8001814:	6823      	ldr	r3, [r4, #0]
 8001816:	6023      	str	r3, [r4, #0]
         uclk=rcu_clock_freq_get(CK_APB1);
 8001818:	f7fe fe6a 	bl	80004f0 <rcu_clock_freq_get>
        if(USART_CTL0(usart_periph) & USART_CTL0_OVSMOD){
 800181c:	6822      	ldr	r2, [r4, #0]
 800181e:	f412 4f00 	tst.w	r2, #32768	; 0x8000
            udiv = ((2U*uclk) + baudval/2U)/baudval;
 8001822:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
        if(USART_CTL0(usart_periph) & USART_CTL0_OVSMOD){
 8001826:	d078      	beq.n	800191a <main+0x5ba>
            udiv = ((2U*uclk) + baudval/2U)/baudval;
 8001828:	0043      	lsls	r3, r0, #1
 800182a:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 800182e:	fbb3 f3f2 	udiv	r3, r3, r2
            intdiv = udiv & 0x0000fff0U;
 8001832:	f64f 72f0 	movw	r2, #65520	; 0xfff0
 8001836:	401a      	ands	r2, r3
            fradiv = (udiv>>1) & 0x00000007U;
 8001838:	f3c3 0342 	ubfx	r3, r3, #1, #3
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800183c:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8001840:	2450      	movs	r4, #80	; 0x50
        USART_BAUD(usart_periph) = ((USART_BAUD_FRADIV | USART_BAUD_INTDIV) & (intdiv | fradiv));
 8001842:	4948      	ldr	r1, [pc, #288]	; (8001964 <main+0x604>)
 8001844:	431a      	orrs	r2, r3
        ctl = USART_CTL0(usart_periph);
 8001846:	4b45      	ldr	r3, [pc, #276]	; (800195c <main+0x5fc>)
        USART_BAUD(usart_periph) = ((USART_BAUD_FRADIV | USART_BAUD_INTDIV) & (intdiv | fradiv));
 8001848:	600a      	str	r2, [r1, #0]
        ctl = USART_CTL0(usart_periph);
 800184a:	681a      	ldr	r2, [r3, #0]
        ctl |= (USART_CTL0_REN & rxconfig);
 800184c:	f042 0204 	orr.w	r2, r2, #4
        USART_CTL0(usart_periph) = ctl;
 8001850:	601a      	str	r2, [r3, #0]
        ctl = USART_CTL0(usart_periph);
 8001852:	681a      	ldr	r2, [r3, #0]
        ctl |= (USART_CTL0_TEN & txconfig);
 8001854:	f042 0208 	orr.w	r2, r2, #8
        USART_CTL0(usart_periph) = ctl;
 8001858:	601a      	str	r2, [r3, #0]
        USART_CTL0(usart_periph) |= USART_CTL0_UEN;
 800185a:	6819      	ldr	r1, [r3, #0]
 800185c:	4a42      	ldr	r2, [pc, #264]	; (8001968 <main+0x608>)
 800185e:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
 8001862:	6019      	str	r1, [r3, #0]
 8001864:	f882 4334 	strb.w	r4, [r2, #820]	; 0x334
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001868:	f8c2 0184 	str.w	r0, [r2, #388]	; 0x184
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 800186c:	6050      	str	r0, [r2, #4]
    USART_REG_VAL(usart_periph, interrupt) |= BIT(USART_BIT_POS(interrupt));
 800186e:	681a      	ldr	r2, [r3, #0]
    rcu_periph_clock_enable(RCU_UART4);
 8001870:	f240 7014 	movw	r0, #1812	; 0x714
 8001874:	f042 0220 	orr.w	r2, r2, #32
 8001878:	601a      	str	r2, [r3, #0]
 800187a:	f7fe fef9 	bl	8000670 <rcu_periph_clock_enable>
        rcu_periph_reset_enable(RCU_UART4RST);
 800187e:	f240 4014 	movw	r0, #1044	; 0x414
 8001882:	f7fe fef5 	bl	8000670 <rcu_periph_clock_enable>
 8001886:	4934      	ldr	r1, [pc, #208]	; (8001958 <main+0x5f8>)
        USART_CTL0(usart_periph) &= ~USART_CTL0_WL;
 8001888:	4c38      	ldr	r4, [pc, #224]	; (800196c <main+0x60c>)
 800188a:	680a      	ldr	r2, [r1, #0]
        USART_CTL1(usart_periph) &= ~USART_CTL1_STB; 
 800188c:	4b38      	ldr	r3, [pc, #224]	; (8001970 <main+0x610>)
 800188e:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 8001892:	600a      	str	r2, [r1, #0]
        USART_CTL0(usart_periph) &= ~USART_CTL0_WL;
 8001894:	6822      	ldr	r2, [r4, #0]
         uclk=rcu_clock_freq_get(CK_APB1);
 8001896:	2002      	movs	r0, #2
        USART_CTL0(usart_periph) &= ~USART_CTL0_WL;
 8001898:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 800189c:	6022      	str	r2, [r4, #0]
        USART_CTL0(usart_periph) |= (USART_CTL0_WL & wlen);
 800189e:	6822      	ldr	r2, [r4, #0]
 80018a0:	6022      	str	r2, [r4, #0]
        USART_CTL1(usart_periph) &= ~USART_CTL1_STB; 
 80018a2:	681a      	ldr	r2, [r3, #0]
 80018a4:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 80018a8:	601a      	str	r2, [r3, #0]
        USART_CTL1(usart_periph) |= (USART_CTL1_STB & stblen);
 80018aa:	681a      	ldr	r2, [r3, #0]
 80018ac:	601a      	str	r2, [r3, #0]
        USART_CTL0(usart_periph) &= ~(USART_CTL0_PM | USART_CTL0_PCEN);
 80018ae:	6823      	ldr	r3, [r4, #0]
 80018b0:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 80018b4:	6023      	str	r3, [r4, #0]
        USART_CTL0(usart_periph) |= ((USART_CTL0_PM | USART_CTL0_PCEN) & paritycfg);
 80018b6:	6823      	ldr	r3, [r4, #0]
 80018b8:	6023      	str	r3, [r4, #0]
         uclk=rcu_clock_freq_get(CK_APB1);
 80018ba:	f7fe fe19 	bl	80004f0 <rcu_clock_freq_get>
        if(USART_CTL0(usart_periph) & USART_CTL0_OVSMOD){
 80018be:	6822      	ldr	r2, [r4, #0]
 80018c0:	f412 4f00 	tst.w	r2, #32768	; 0x8000
            udiv = ((2U*uclk) + baudval/2U)/baudval;
 80018c4:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
        if(USART_CTL0(usart_periph) & USART_CTL0_OVSMOD){
 80018c8:	d031      	beq.n	800192e <main+0x5ce>
            udiv = ((2U*uclk) + baudval/2U)/baudval;
 80018ca:	0043      	lsls	r3, r0, #1
 80018cc:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 80018d0:	fbb3 f3f2 	udiv	r3, r3, r2
            intdiv = udiv & 0x0000fff0U;
 80018d4:	f64f 72f0 	movw	r2, #65520	; 0xfff0
 80018d8:	401a      	ands	r2, r3
            fradiv = (udiv>>1) & 0x00000007U;
 80018da:	f3c3 0342 	ubfx	r3, r3, #1, #3
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80018de:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 80018e2:	2450      	movs	r4, #80	; 0x50
        USART_BAUD(usart_periph) = ((USART_BAUD_FRADIV | USART_BAUD_INTDIV) & (intdiv | fradiv));
 80018e4:	4923      	ldr	r1, [pc, #140]	; (8001974 <main+0x614>)
 80018e6:	431a      	orrs	r2, r3
        ctl = USART_CTL0(usart_periph);
 80018e8:	4b20      	ldr	r3, [pc, #128]	; (800196c <main+0x60c>)
        USART_BAUD(usart_periph) = ((USART_BAUD_FRADIV | USART_BAUD_INTDIV) & (intdiv | fradiv));
 80018ea:	600a      	str	r2, [r1, #0]
        ctl = USART_CTL0(usart_periph);
 80018ec:	681a      	ldr	r2, [r3, #0]
        ctl |= (USART_CTL0_REN & rxconfig);
 80018ee:	f042 0204 	orr.w	r2, r2, #4
        USART_CTL0(usart_periph) = ctl;
 80018f2:	601a      	str	r2, [r3, #0]
        ctl = USART_CTL0(usart_periph);
 80018f4:	681a      	ldr	r2, [r3, #0]
        ctl |= (USART_CTL0_TEN & txconfig);
 80018f6:	f042 0208 	orr.w	r2, r2, #8
        USART_CTL0(usart_periph) = ctl;
 80018fa:	601a      	str	r2, [r3, #0]
        USART_CTL0(usart_periph) |= USART_CTL0_UEN;
 80018fc:	6819      	ldr	r1, [r3, #0]
 80018fe:	4a1a      	ldr	r2, [pc, #104]	; (8001968 <main+0x608>)
 8001900:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
 8001904:	6019      	str	r1, [r3, #0]
 8001906:	f882 4335 	strb.w	r4, [r2, #821]	; 0x335
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800190a:	f8c2 0184 	str.w	r0, [r2, #388]	; 0x184
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 800190e:	6050      	str	r0, [r2, #4]
    USART_REG_VAL(usart_periph, interrupt) |= BIT(USART_BIT_POS(interrupt));
 8001910:	681a      	ldr	r2, [r3, #0]
 8001912:	f042 0220 	orr.w	r2, r2, #32
 8001916:	601a      	str	r2, [r3, #0]
 8001918:	e6b3      	b.n	8001682 <main+0x322>
            udiv = (uclk+baudval/2U)/baudval;
 800191a:	f500 4361 	add.w	r3, r0, #57600	; 0xe100
 800191e:	fbb3 f3f2 	udiv	r3, r3, r2
            intdiv = udiv & 0x0000fff0U;
 8001922:	f64f 72f0 	movw	r2, #65520	; 0xfff0
 8001926:	401a      	ands	r2, r3
            fradiv = udiv & 0x0000000fU;
 8001928:	f003 030f 	and.w	r3, r3, #15
 800192c:	e786      	b.n	800183c <main+0x4dc>
            udiv = (uclk+baudval/2U)/baudval;
 800192e:	f500 4361 	add.w	r3, r0, #57600	; 0xe100
 8001932:	fbb3 f3f2 	udiv	r3, r3, r2
            intdiv = udiv & 0x0000fff0U;
 8001936:	f64f 72f0 	movw	r2, #65520	; 0xfff0
 800193a:	401a      	ands	r2, r3
            fradiv = udiv & 0x0000000fU;
 800193c:	f003 030f 	and.w	r3, r3, #15
 8001940:	e7cd      	b.n	80018de <main+0x57e>
 8001942:	bf00      	nop
 8001944:	431bde83 	.word	0x431bde83
 8001948:	08001e5c 	.word	0x08001e5c
 800194c:	20000800 	.word	0x20000800
 8001950:	20000d18 	.word	0x20000d18
 8001954:	20000a58 	.word	0x20000a58
 8001958:	40021010 	.word	0x40021010
 800195c:	40004c0c 	.word	0x40004c0c
 8001960:	40004c10 	.word	0x40004c10
 8001964:	40004c08 	.word	0x40004c08
 8001968:	e000e100 	.word	0xe000e100
 800196c:	4000500c 	.word	0x4000500c
 8001970:	40005010 	.word	0x40005010
 8001974:	40005008 	.word	0x40005008
	...

08001980 <SVC_Handler>:
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8001980:	f3ef 8309 	mrs	r3, PSP
    psp += sizeof (struct port_extctx);
 8001984:	3320      	adds	r3, #32
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8001986:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800198a:	2300      	movs	r3, #0
 800198c:	f383 8811 	msr	BASEPRI, r3
}
 8001990:	4770      	bx	lr
 8001992:	bf00      	nop
	...

080019a0 <chThdExit>:
void chThdExit(msg_t msg) {
 80019a0:	b538      	push	{r3, r4, r5, lr}
 80019a2:	2320      	movs	r3, #32
 80019a4:	f383 8811 	msr	BASEPRI, r3
 80019a8:	4b12      	ldr	r3, [pc, #72]	; (80019f4 <chThdExit+0x54>)
 80019aa:	68dc      	ldr	r4, [r3, #12]
  return (bool)(lp->next != lp);
 80019ac:	6b23      	ldr	r3, [r4, #48]	; 0x30
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 80019ae:	f104 0530 	add.w	r5, r4, #48	; 0x30
 80019b2:	429d      	cmp	r5, r3
  currtp->u.exitcode = msg;
 80019b4:	62e0      	str	r0, [r4, #44]	; 0x2c
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 80019b6:	d107      	bne.n	80019c8 <chThdExit+0x28>
  if (unlikely(currtp->refs == (trefs_t)0)) {
 80019b8:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 80019bc:	b183      	cbz	r3, 80019e0 <chThdExit+0x40>
}
 80019be:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSchGoSleepS(CH_STATE_FINAL);
 80019c2:	200f      	movs	r0, #15
 80019c4:	f7ff baac 	b.w	8000f20 <chSchGoSleepS>
  lp->next = p->next;
 80019c8:	681a      	ldr	r2, [r3, #0]
    (void) chSchReadyI(threadref(ch_list_unlink(&currtp->waiting)));
 80019ca:	4618      	mov	r0, r3
 80019cc:	6322      	str	r2, [r4, #48]	; 0x30
 80019ce:	f7fe ff57 	bl	8000880 <chSchReadyI>
  return (bool)(lp->next != lp);
 80019d2:	6b23      	ldr	r3, [r4, #48]	; 0x30
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 80019d4:	42ab      	cmp	r3, r5
 80019d6:	d1f7      	bne.n	80019c8 <chThdExit+0x28>
  if (unlikely(currtp->refs == (trefs_t)0)) {
 80019d8:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 80019dc:	2b00      	cmp	r3, #0
 80019de:	d1ee      	bne.n	80019be <chThdExit+0x1e>
    if (unlikely(((currtp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC))) {
 80019e0:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
 80019e4:	079b      	lsls	r3, r3, #30
 80019e6:	d1ea      	bne.n	80019be <chThdExit+0x1e>
  p->prev->next = p->next;
 80019e8:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
 80019ec:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 80019ee:	605a      	str	r2, [r3, #4]
  return p;
 80019f0:	e7e5      	b.n	80019be <chThdExit+0x1e>
 80019f2:	bf00      	nop
 80019f4:	20000d98 	.word	0x20000d98
	...

08001a00 <chSchDoPreemption>:
  thread_t *otp = __instance_get_currthread(oip);
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  ntp->state = CH_STATE_CURRENT;
 8001a00:	2301      	movs	r3, #1
void chSchDoPreemption(void) {
 8001a02:	b430      	push	{r4, r5}
  tp->state = CH_STATE_READY;
 8001a04:	2500      	movs	r5, #0
  thread_t *otp = __instance_get_currthread(oip);
 8001a06:	4a0c      	ldr	r2, [pc, #48]	; (8001a38 <chSchDoPreemption+0x38>)
  ch_priority_queue_t *p = pqp->next;
 8001a08:	6810      	ldr	r0, [r2, #0]
 8001a0a:	68d1      	ldr	r1, [r2, #12]
  pqp->next       = p->next;
 8001a0c:	6804      	ldr	r4, [r0, #0]
  pqp->next->prev = pqp;
 8001a0e:	6062      	str	r2, [r4, #4]
  ntp->state = CH_STATE_CURRENT;
 8001a10:	f880 3028 	strb.w	r3, [r0, #40]	; 0x28
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
 8001a14:	698b      	ldr	r3, [r1, #24]
  pqp->next       = p->next;
 8001a16:	6014      	str	r4, [r2, #0]
  tp->state = CH_STATE_READY;
 8001a18:	f881 5028 	strb.w	r5, [r1, #40]	; 0x28
  } while (unlikely(pqp->prio > p->prio));
 8001a1c:	688c      	ldr	r4, [r1, #8]
  __instance_set_currthread(oip, ntp);
 8001a1e:	60d0      	str	r0, [r2, #12]
    pqp = pqp->next;
 8001a20:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio > p->prio));
 8001a22:	689a      	ldr	r2, [r3, #8]
 8001a24:	42a2      	cmp	r2, r4
 8001a26:	d8fb      	bhi.n	8001a20 <chSchDoPreemption+0x20>
  otp = __sch_ready_ahead(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
}
 8001a28:	bc30      	pop	{r4, r5}
  p->prev       = pqp->prev;
 8001a2a:	685a      	ldr	r2, [r3, #4]
 8001a2c:	e9c1 3200 	strd	r3, r2, [r1]
  p->prev->next = p;
 8001a30:	6011      	str	r1, [r2, #0]
  pqp->prev     = p;
 8001a32:	6059      	str	r1, [r3, #4]
  chSysSwitch(ntp, otp);
 8001a34:	f7fe bc2a 	b.w	800028c <__port_switch>
 8001a38:	20000d98 	.word	0x20000d98
 8001a3c:	00000000 	.word	0x00000000

08001a40 <__early_init>:
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
#endif
    /* reset the RCU clock configuration to the default reset state */
    /* Set IRC8MEN bit */
    RCU_CTL |= RCU_CTL_IRC8MEN;
 8001a40:	4b70      	ldr	r3, [pc, #448]	; (8001c04 <__early_init+0x1c4>)
 */
void boardInit(void) {

}

void __early_init(void) {
 8001a42:	b570      	push	{r4, r5, r6, lr}
    while(0U == (RCU_CTL & RCU_CTL_IRC8MSTB)){
 8001a44:	4619      	mov	r1, r3
    RCU_CTL |= RCU_CTL_IRC8MEN;
 8001a46:	681a      	ldr	r2, [r3, #0]
 8001a48:	b082      	sub	sp, #8
 8001a4a:	f042 0201 	orr.w	r2, r2, #1
 8001a4e:	601a      	str	r2, [r3, #0]
    while(0U == (RCU_CTL & RCU_CTL_IRC8MSTB)){
 8001a50:	680b      	ldr	r3, [r1, #0]
 8001a52:	079b      	lsls	r3, r3, #30
 8001a54:	d5fc      	bpl.n	8001a50 <__early_init+0x10>
    }
    RCU_MODIFY(0x100);
 8001a56:	2100      	movs	r1, #0
 8001a58:	4a6b      	ldr	r2, [pc, #428]	; (8001c08 <__early_init+0x1c8>)
 8001a5a:	6813      	ldr	r3, [r2, #0]
 8001a5c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001a60:	6013      	str	r3, [r2, #0]
 8001a62:	9101      	str	r1, [sp, #4]
 8001a64:	9b01      	ldr	r3, [sp, #4]
 8001a66:	2bff      	cmp	r3, #255	; 0xff
 8001a68:	d805      	bhi.n	8001a76 <__early_init+0x36>
 8001a6a:	9b01      	ldr	r3, [sp, #4]
 8001a6c:	3301      	adds	r3, #1
 8001a6e:	9301      	str	r3, [sp, #4]
 8001a70:	9b01      	ldr	r3, [sp, #4]
 8001a72:	2bff      	cmp	r3, #255	; 0xff
 8001a74:	d9f9      	bls.n	8001a6a <__early_init+0x2a>
 8001a76:	2100      	movs	r1, #0
 8001a78:	4a63      	ldr	r2, [pc, #396]	; (8001c08 <__early_init+0x1c8>)
 8001a7a:	6813      	ldr	r3, [r2, #0]
 8001a7c:	f043 0390 	orr.w	r3, r3, #144	; 0x90
 8001a80:	6013      	str	r3, [r2, #0]
 8001a82:	9101      	str	r1, [sp, #4]
 8001a84:	9b01      	ldr	r3, [sp, #4]
 8001a86:	2bff      	cmp	r3, #255	; 0xff
 8001a88:	d805      	bhi.n	8001a96 <__early_init+0x56>
 8001a8a:	9b01      	ldr	r3, [sp, #4]
 8001a8c:	3301      	adds	r3, #1
 8001a8e:	9301      	str	r3, [sp, #4]
 8001a90:	9b01      	ldr	r3, [sp, #4]
 8001a92:	2bff      	cmp	r3, #255	; 0xff
 8001a94:	d9f9      	bls.n	8001a8a <__early_init+0x4a>
    /* disable all interrupts */
    RCU_INT = 0x00ff0000U;
#endif /* GD32F50X_EPRT and GD32F50X_HD */

    /* Reset CFG0 and CFG1 registers */
    RCU_CFG0 = 0x00000000U;
 8001a96:	2400      	movs	r4, #0
    RCU_INT = 0x00ff0000U;
 8001a98:	f44f 067f 	mov.w	r6, #16711680	; 0xff0000
    RCU_CFG0 &= ~RCU_CFG0_SCS;
 8001a9c:	495a      	ldr	r1, [pc, #360]	; (8001c08 <__early_init+0x1c8>)
    RCU_CTL &= ~(RCU_CTL_PLLEN |RCU_CTL_PLL1EN | RCU_CTL_PLL2EN | RCU_CTL_CKMEN | RCU_CTL_HXTALEN);
 8001a9e:	4b59      	ldr	r3, [pc, #356]	; (8001c04 <__early_init+0x1c4>)
    RCU_CFG0 &= ~RCU_CFG0_SCS;
 8001aa0:	680a      	ldr	r2, [r1, #0]
{
    uint32_t timeout = 0U;
    uint32_t stab_flag = 0U;

    /* enable HXTAL */
    RCU_CTL |= RCU_CTL_HXTALEN;
 8001aa2:	f64f 70ff 	movw	r0, #65535	; 0xffff
    RCU_CFG0 &= ~RCU_CFG0_SCS;
 8001aa6:	f022 0203 	bic.w	r2, r2, #3
 8001aaa:	600a      	str	r2, [r1, #0]
    RCU_CTL &= ~(RCU_CTL_PLLEN |RCU_CTL_PLL1EN | RCU_CTL_PLL2EN | RCU_CTL_CKMEN | RCU_CTL_HXTALEN);
 8001aac:	681a      	ldr	r2, [r3, #0]

    /* wait until HXTAL is stable or the startup time is longer than HXTAL_STARTUP_TIMEOUT */
    do{
        timeout++;
        stab_flag = (RCU_CTL & RCU_CTL_HXTALSTB);
 8001aae:	461d      	mov	r5, r3
    RCU_CTL &= ~(RCU_CTL_PLLEN |RCU_CTL_PLL1EN | RCU_CTL_PLL2EN | RCU_CTL_CKMEN | RCU_CTL_HXTALEN);
 8001ab0:	f022 52a8 	bic.w	r2, r2, #352321536	; 0x15000000
 8001ab4:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000
 8001ab8:	601a      	str	r2, [r3, #0]
    RCU_INT = 0x00ff0000U;
 8001aba:	4a54      	ldr	r2, [pc, #336]	; (8001c0c <__early_init+0x1cc>)
 8001abc:	6016      	str	r6, [r2, #0]
    RCU_CFG0 = 0x00000000U;
 8001abe:	600c      	str	r4, [r1, #0]
    RCU_CFG1 = 0x00000000U;
 8001ac0:	6254      	str	r4, [r2, #36]	; 0x24
    RCU_CTL &= ~(RCU_CTL_HXTALBPS);
 8001ac2:	681a      	ldr	r2, [r3, #0]
 8001ac4:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8001ac8:	601a      	str	r2, [r3, #0]
    RCU_CTL |= RCU_CTL_HXTALEN;
 8001aca:	681a      	ldr	r2, [r3, #0]
 8001acc:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8001ad0:	601a      	str	r2, [r3, #0]
 8001ad2:	e001      	b.n	8001ad8 <__early_init+0x98>
    }while((0U == stab_flag) && (HXTAL_STARTUP_TIMEOUT != timeout));
 8001ad4:	3801      	subs	r0, #1
 8001ad6:	d002      	beq.n	8001ade <__early_init+0x9e>
        stab_flag = (RCU_CTL & RCU_CTL_HXTALSTB);
 8001ad8:	682b      	ldr	r3, [r5, #0]
    }while((0U == stab_flag) && (HXTAL_STARTUP_TIMEOUT != timeout));
 8001ada:	039e      	lsls	r6, r3, #14
 8001adc:	d5fa      	bpl.n	8001ad4 <__early_init+0x94>

    /* if fail */
    if(0U == (RCU_CTL & RCU_CTL_HXTALSTB)){
 8001ade:	4a49      	ldr	r2, [pc, #292]	; (8001c04 <__early_init+0x1c4>)
 8001ae0:	6813      	ldr	r3, [r2, #0]
 8001ae2:	039d      	lsls	r5, r3, #14
 8001ae4:	f140 808c 	bpl.w	8001c00 <__early_init+0x1c0>
        while(1){
        }
    }

    FMC_WS = (FMC_WS & (~FMC_WS_WSCNT)) | WS_WSCNT(4);
 8001ae8:	4849      	ldr	r0, [pc, #292]	; (8001c10 <__early_init+0x1d0>)

    RCU_APB1EN |= RCU_APB1EN_PMUEN;
 8001aea:	4c4a      	ldr	r4, [pc, #296]	; (8001c14 <__early_init+0x1d4>)
    FMC_WS = (FMC_WS & (~FMC_WS_WSCNT)) | WS_WSCNT(4);
 8001aec:	6801      	ldr	r1, [r0, #0]

    /* HXTAL is stable */
    /* AHB = SYSCLK */
    RCU_CFG0 |= RCU_AHB_CKSYS_DIV1;
 8001aee:	4b46      	ldr	r3, [pc, #280]	; (8001c08 <__early_init+0x1c8>)
    FMC_WS = (FMC_WS & (~FMC_WS_WSCNT)) | WS_WSCNT(4);
 8001af0:	f021 0107 	bic.w	r1, r1, #7
 8001af4:	f041 0104 	orr.w	r1, r1, #4
 8001af8:	6001      	str	r1, [r0, #0]
    RCU_APB1EN |= RCU_APB1EN_PMUEN;
 8001afa:	6821      	ldr	r1, [r4, #0]
    RCU_CFG1 |= (RCU_PLLPRESRC_HXTAL | RCU_PREDV0SRC_CKPLL1 | RCU_PLL1_MUL8 | RCU_PREDV1_DIV5 | RCU_PREDV0_DIV10);

    /* enable PLL1 */
    RCU_CTL |= RCU_CTL_PLL1EN;
    /* wait till PLL1 is ready */
    while((RCU_CTL & RCU_CTL_PLL1STB) == 0U){
 8001afc:	4610      	mov	r0, r2
    RCU_APB1EN |= RCU_APB1EN_PMUEN;
 8001afe:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8001b02:	6021      	str	r1, [r4, #0]
    RCU_CFG0 |= RCU_AHB_CKSYS_DIV1;
 8001b04:	6819      	ldr	r1, [r3, #0]
    RCU_CFG1 &= ~(RCU_CFG1_PLLPRESEL | RCU_CFG1_PREDV0SEL | RCU_CFG1_PLL1MF | RCU_CFG1_PREDV1 | RCU_CFG1_PREDV0);
 8001b06:	4d44      	ldr	r5, [pc, #272]	; (8001c18 <__early_init+0x1d8>)
    RCU_CFG0 |= RCU_AHB_CKSYS_DIV1;
 8001b08:	6019      	str	r1, [r3, #0]
    RCU_CFG0 |= RCU_APB2_CKAHB_DIV1;
 8001b0a:	6819      	ldr	r1, [r3, #0]
 8001b0c:	6019      	str	r1, [r3, #0]
    RCU_CFG0 |= RCU_APB1_CKAHB_DIV2;
 8001b0e:	6819      	ldr	r1, [r3, #0]
 8001b10:	f441 6180 	orr.w	r1, r1, #1024	; 0x400
 8001b14:	6019      	str	r1, [r3, #0]
    RCU_CFG0 &= ~(RCU_CFG0_PLLMF | RCU_CFG0_PLLMF_4 | RCU_CFG0_PLLMF_5);
 8001b16:	6819      	ldr	r1, [r3, #0]
 8001b18:	f021 41c0 	bic.w	r1, r1, #1610612736	; 0x60000000
 8001b1c:	f421 1170 	bic.w	r1, r1, #3932160	; 0x3c0000
 8001b20:	6019      	str	r1, [r3, #0]
    RCU_CFG0 |= (RCU_PLLSRC_HXTAL_IRC48M | RCU_PLL_MUL42);
 8001b22:	6819      	ldr	r1, [r3, #0]
 8001b24:	f041 4180 	orr.w	r1, r1, #1073741824	; 0x40000000
 8001b28:	f441 1114 	orr.w	r1, r1, #2424832	; 0x250000
 8001b2c:	6019      	str	r1, [r3, #0]
    RCU_CFG1 &= ~(RCU_CFG1_PLLPRESEL | RCU_CFG1_PREDV0SEL | RCU_CFG1_PLL1MF | RCU_CFG1_PREDV1 | RCU_CFG1_PREDV0);
 8001b2e:	6923      	ldr	r3, [r4, #16]
 8001b30:	402b      	ands	r3, r5
 8001b32:	6123      	str	r3, [r4, #16]
    RCU_CFG1 |= (RCU_PLLPRESRC_HXTAL | RCU_PREDV0SRC_CKPLL1 | RCU_PLL1_MUL8 | RCU_PREDV1_DIV5 | RCU_PREDV0_DIV10);
 8001b34:	6923      	ldr	r3, [r4, #16]
 8001b36:	f443 3383 	orr.w	r3, r3, #67072	; 0x10600
 8001b3a:	f043 0349 	orr.w	r3, r3, #73	; 0x49
 8001b3e:	6123      	str	r3, [r4, #16]
    RCU_CTL |= RCU_CTL_PLL1EN;
 8001b40:	6813      	ldr	r3, [r2, #0]
 8001b42:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8001b46:	6013      	str	r3, [r2, #0]
    while((RCU_CTL & RCU_CTL_PLL1STB) == 0U){
 8001b48:	6803      	ldr	r3, [r0, #0]
 8001b4a:	011c      	lsls	r4, r3, #4
 8001b4c:	d5fc      	bpl.n	8001b48 <__early_init+0x108>
    while((RCU_CTL & RCU_CTL_PLL1STB) == 0U){
    }
#endif /* GD32F50X_HD */

    /* enable PLL */
    RCU_CTL |= RCU_CTL_PLLEN;
 8001b4e:	6803      	ldr	r3, [r0, #0]

    /* wait until PLL is stable */
    while(0U == (RCU_CTL & RCU_CTL_PLLSTB)){
 8001b50:	4a2c      	ldr	r2, [pc, #176]	; (8001c04 <__early_init+0x1c4>)
    RCU_CTL |= RCU_CTL_PLLEN;
 8001b52:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8001b56:	6003      	str	r3, [r0, #0]
    while(0U == (RCU_CTL & RCU_CTL_PLLSTB)){
 8001b58:	6813      	ldr	r3, [r2, #0]
 8001b5a:	0199      	lsls	r1, r3, #6
 8001b5c:	d5fc      	bpl.n	8001b58 <__early_init+0x118>
    }

    /* enable the high-drive to extend the clock frequency to 180 MHz */
    PMU_CTL0 |= PMU_CTL0_HDEN;
 8001b5e:	4a2f      	ldr	r2, [pc, #188]	; (8001c1c <__early_init+0x1dc>)
    while(0U == (PMU_CS0 & PMU_CS0_HDRF)){
 8001b60:	492f      	ldr	r1, [pc, #188]	; (8001c20 <__early_init+0x1e0>)
    PMU_CTL0 |= PMU_CTL0_HDEN;
 8001b62:	6813      	ldr	r3, [r2, #0]
 8001b64:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001b68:	6013      	str	r3, [r2, #0]
    while(0U == (PMU_CS0 & PMU_CS0_HDRF)){
 8001b6a:	680b      	ldr	r3, [r1, #0]
 8001b6c:	03da      	lsls	r2, r3, #15
 8001b6e:	d5fc      	bpl.n	8001b6a <__early_init+0x12a>
    }

    /* select the high-drive mode */
    PMU_CTL0 |= PMU_CTL0_HDS;
 8001b70:	4a2a      	ldr	r2, [pc, #168]	; (8001c1c <__early_init+0x1dc>)
    while(0U == (PMU_CS0 & PMU_CS0_HDSRF)){
 8001b72:	492b      	ldr	r1, [pc, #172]	; (8001c20 <__early_init+0x1e0>)
    PMU_CTL0 |= PMU_CTL0_HDS;
 8001b74:	6813      	ldr	r3, [r2, #0]
 8001b76:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8001b7a:	6013      	str	r3, [r2, #0]
    while(0U == (PMU_CS0 & PMU_CS0_HDSRF)){
 8001b7c:	680b      	ldr	r3, [r1, #0]
 8001b7e:	039b      	lsls	r3, r3, #14
 8001b80:	d5fc      	bpl.n	8001b7c <__early_init+0x13c>
    }

    /* select PLL as system clock */
    RCU_CFG0 &= ~RCU_CFG0_SCS;
 8001b82:	4b21      	ldr	r3, [pc, #132]	; (8001c08 <__early_init+0x1c8>)
    RCU_CFG0 |= RCU_CKSYSSRC_PLL;

    /* wait until PLL is selected as system clock */
    while(RCU_SCSS_PLL != (RCU_CFG0 & RCU_CFG0_SCSS)){
 8001b84:	4619      	mov	r1, r3
    RCU_CFG0 &= ~RCU_CFG0_SCS;
 8001b86:	681a      	ldr	r2, [r3, #0]
 8001b88:	f022 0203 	bic.w	r2, r2, #3
 8001b8c:	601a      	str	r2, [r3, #0]
    RCU_CFG0 |= RCU_CKSYSSRC_PLL;
 8001b8e:	681a      	ldr	r2, [r3, #0]
 8001b90:	f042 0202 	orr.w	r2, r2, #2
 8001b94:	601a      	str	r2, [r3, #0]
    while(RCU_SCSS_PLL != (RCU_CFG0 & RCU_CFG0_SCSS)){
 8001b96:	680b      	ldr	r3, [r1, #0]
 8001b98:	f003 030c 	and.w	r3, r3, #12
 8001b9c:	2b08      	cmp	r3, #8
 8001b9e:	d1fa      	bne.n	8001b96 <__early_init+0x156>
    \param[out] none
    \retval     none
*/
void nvic_vector_table_set(uint32_t nvic_vict_tab, uint32_t offset)
{
    SCB->VTOR = nvic_vict_tab | (offset & NVIC_VECTTAB_OFFSET_MASK);
 8001ba0:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8001ba4:	4b1f      	ldr	r3, [pc, #124]	; (8001c24 <__early_init+0x1e4>)
 8001ba6:	609a      	str	r2, [r3, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8001ba8:	f3bf 8f4f 	dsb	sy
    SystemInit();

    rcu_periph_clock_enable(RCU_GPIOA);
 8001bac:	f240 6002 	movw	r0, #1538	; 0x602
 8001bb0:	f7fe fd5e 	bl	8000670 <rcu_periph_clock_enable>
    rcu_periph_clock_enable(RCU_GPIOB);
 8001bb4:	f240 6003 	movw	r0, #1539	; 0x603
 8001bb8:	f7fe fd5a 	bl	8000670 <rcu_periph_clock_enable>
    rcu_periph_clock_enable(RCU_GPIOC);
 8001bbc:	f240 6004 	movw	r0, #1540	; 0x604
 8001bc0:	f7fe fd56 	bl	8000670 <rcu_periph_clock_enable>
    rcu_periph_clock_enable(RCU_GPIOD);
 8001bc4:	f240 6005 	movw	r0, #1541	; 0x605
 8001bc8:	f7fe fd52 	bl	8000670 <rcu_periph_clock_enable>
    // palSetLineMode(LINE_LED2, GDPAL_MODE(GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ));
    // palSetLineMode(LINE_LED3, GDPAL_MODE(GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ));

    // gpio_init(GPIOA, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_7);

    palSetPadMode(GPIOA, GPIO_PIN_7, GDPAL_MODE(GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ));
 8001bcc:	2280      	movs	r2, #128	; 0x80
 8001bce:	2110      	movs	r1, #16
 8001bd0:	4815      	ldr	r0, [pc, #84]	; (8001c28 <__early_init+0x1e8>)
 8001bd2:	f7fe fc1d 	bl	8000410 <gpio_init.constprop.0>
    palSetPadMode(GPIOA, GPIO_PIN_8, GDPAL_MODE(GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ));
 8001bd6:	f44f 7280 	mov.w	r2, #256	; 0x100
 8001bda:	2110      	movs	r1, #16
 8001bdc:	4812      	ldr	r0, [pc, #72]	; (8001c28 <__early_init+0x1e8>)
 8001bde:	f7fe fc17 	bl	8000410 <gpio_init.constprop.0>
    palSetPadMode(GPIOA, GPIO_PIN_10, GDPAL_MODE(GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ));
 8001be2:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8001be6:	2110      	movs	r1, #16
 8001be8:	480f      	ldr	r0, [pc, #60]	; (8001c28 <__early_init+0x1e8>)
 8001bea:	f7fe fc11 	bl	8000410 <gpio_init.constprop.0>
    palSetPadMode(GPIOC, GPIO_PIN_13, GDPAL_MODE(GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ));    
 8001bee:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8001bf2:	2110      	movs	r1, #16
 8001bf4:	480d      	ldr	r0, [pc, #52]	; (8001c2c <__early_init+0x1ec>)
}
 8001bf6:	b002      	add	sp, #8
 8001bf8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    palSetPadMode(GPIOC, GPIO_PIN_13, GDPAL_MODE(GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ));    
 8001bfc:	f7fe bc08 	b.w	8000410 <gpio_init.constprop.0>
        while(1){
 8001c00:	e7fe      	b.n	8001c00 <__early_init+0x1c0>
 8001c02:	bf00      	nop
 8001c04:	40021000 	.word	0x40021000
 8001c08:	40021004 	.word	0x40021004
 8001c0c:	40021008 	.word	0x40021008
 8001c10:	40022000 	.word	0x40022000
 8001c14:	4002101c 	.word	0x4002101c
 8001c18:	bffef000 	.word	0xbffef000
 8001c1c:	40007000 	.word	0x40007000
 8001c20:	40007004 	.word	0x40007004
 8001c24:	e000ed00 	.word	0xe000ed00
 8001c28:	40010800 	.word	0x40010800
 8001c2c:	40011000 	.word	0x40011000

08001c30 <Vector14C>:
  kkk ++;
 8001c30:	4a02      	ldr	r2, [pc, #8]	; (8001c3c <Vector14C+0xc>)
 8001c32:	6813      	ldr	r3, [r2, #0]
 8001c34:	3301      	adds	r3, #1
 8001c36:	6013      	str	r3, [r2, #0]
  OSAL_IRQ_EPILOGUE();
 8001c38:	f7fe bd2a 	b.w	8000690 <__port_irq_epilogue>
 8001c3c:	20000fa0 	.word	0x20000fa0

08001c40 <Vector114>:
OSAL_IRQ_HANDLER(Vector114) {
 8001c40:	b510      	push	{r4, lr}
  sd_lld_serve_interrupt(&SD4);
 8001c42:	480c      	ldr	r0, [pc, #48]	; (8001c74 <Vector114+0x34>)
 8001c44:	f7fe fe5c 	bl	8000900 <sd_lld_serve_interrupt>
{
    uint32_t intenable = 0U, flagstatus = 0U;
    /* get the interrupt enable bit status */
    intenable = (USART_REG_VAL(usart_periph, int_flag) & BIT(USART_BIT_POS(int_flag)));
    /* get the corresponding flag bit status */
    flagstatus = (USART_REG_VAL2(usart_periph, int_flag) & BIT(USART_BIT_POS2(int_flag)));
 8001c48:	4c0b      	ldr	r4, [pc, #44]	; (8001c78 <Vector114+0x38>)
    intenable = (USART_REG_VAL(usart_periph, int_flag) & BIT(USART_BIT_POS(int_flag)));
 8001c4a:	4b0c      	ldr	r3, [pc, #48]	; (8001c7c <Vector114+0x3c>)
 8001c4c:	681a      	ldr	r2, [r3, #0]
    flagstatus = (USART_REG_VAL2(usart_periph, int_flag) & BIT(USART_BIT_POS2(int_flag)));
 8001c4e:	6823      	ldr	r3, [r4, #0]

    if((0U != flagstatus) && (0U != intenable)){
 8001c50:	0519      	lsls	r1, r3, #20
 8001c52:	d50a      	bpl.n	8001c6a <Vector114+0x2a>
 8001c54:	06d3      	lsls	r3, r2, #27
 8001c56:	d508      	bpl.n	8001c6a <Vector114+0x2a>
  chEvtBroadcastFlagsI(esp, flags);
 8001c58:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8001c5c:	4808      	ldr	r0, [pc, #32]	; (8001c80 <Vector114+0x40>)
 8001c5e:	f7fe fe1f 	bl	80008a0 <chEvtBroadcastFlagsI>
    USART_REG_VAL(usart_periph, flag) &= ~BIT(USART_BIT_POS(flag));
 8001c62:	6823      	ldr	r3, [r4, #0]
 8001c64:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8001c68:	6023      	str	r3, [r4, #0]
}
 8001c6a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8001c6e:	f7fe bd0f 	b.w	8000690 <__port_irq_epilogue>
 8001c72:	bf00      	nop
 8001c74:	20000a58 	.word	0x20000a58
 8001c78:	40005088 	.word	0x40005088
 8001c7c:	40005080 	.word	0x40005080
 8001c80:	20000a5c 	.word	0x20000a5c
	...

08001c90 <Vector110>:
OSAL_IRQ_HANDLER(Vector110) {
 8001c90:	b508      	push	{r3, lr}
  sd_lld_serve_interrupt(&SD3);
 8001c92:	4803      	ldr	r0, [pc, #12]	; (8001ca0 <Vector110+0x10>)
 8001c94:	f7fe fe34 	bl	8000900 <sd_lld_serve_interrupt>
}
 8001c98:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8001c9c:	f7fe bcf8 	b.w	8000690 <__port_irq_epilogue>
 8001ca0:	20000800 	.word	0x20000800
	...

08001cb0 <VectorB0>:

OSAL_IRQ_HANDLER(VectorB0) {
    uint32_t sr;

    OSAL_IRQ_PROLOGUE();
    sr = TIMER_INTF(TIMER1);
 8001cb0:	4a39      	ldr	r2, [pc, #228]	; (8001d98 <VectorB0+0xe8>)
 8001cb2:	6813      	ldr	r3, [r2, #0]
    TIMER_INTF(TIMER1) = ~sr;
 8001cb4:	43d9      	mvns	r1, r3

    if(sr & TIMER_INT_CH0){
 8001cb6:	079b      	lsls	r3, r3, #30
    TIMER_INTF(TIMER1) = ~sr;
 8001cb8:	6011      	str	r1, [r2, #0]
    if(sr & TIMER_INT_CH0){
 8001cba:	d401      	bmi.n	8001cc0 <VectorB0+0x10>
        osalSysLockFromISR();
        osalOsTimerHandlerI();
        osalSysUnlockFromISR();
    }

    OSAL_IRQ_EPILOGUE();
 8001cbc:	f7fe bce8 	b.w	8000690 <__port_irq_epilogue>
OSAL_IRQ_HANDLER(VectorB0) {
 8001cc0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001cc4:	2320      	movs	r3, #32
 8001cc6:	f383 8811 	msr	BASEPRI, r3
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
void chVTDoTickI(void) {
 8001cca:	4d34      	ldr	r5, [pc, #208]	; (8001d9c <VectorB0+0xec>)
 8001ccc:	4e34      	ldr	r6, [pc, #208]	; (8001da0 <VectorB0+0xf0>)
  TIMER_DMAINTEN(TIMER1) = 0;
 8001cce:	4f35      	ldr	r7, [pc, #212]	; (8001da4 <VectorB0+0xf4>)
 8001cd0:	f105 0810 	add.w	r8, r5, #16
    lasttime = chTimeAddX(vtlp->lasttime, vtp->dlist.delta);
    vtlp->lasttime = lasttime;

    /* Removing the timer from the list, marking it as not armed.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
    vtp->dlist.next = NULL;
 8001cd4:	f04f 0a00 	mov.w	sl, #0
    vtp = (virtual_timer_t *)vtlp->dlist.next;
 8001cd8:	692c      	ldr	r4, [r5, #16]
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8001cda:	69e9      	ldr	r1, [r5, #28]
  return (systime_t)TIMER_CNT(TIMER1);
 8001cdc:	6830      	ldr	r0, [r6, #0]
    if (nowdelta < vtp->dlist.delta) {
 8001cde:	68a3      	ldr	r3, [r4, #8]
 8001ce0:	1a42      	subs	r2, r0, r1
 8001ce2:	429a      	cmp	r2, r3
  return systime + (systime_t)interval;
 8001ce4:	eb01 0903 	add.w	r9, r1, r3
 8001ce8:	d335      	bcc.n	8001d56 <VectorB0+0xa6>
  dlp->prev->next = dlp->next;
 8001cea:	e9d4 3200 	ldrd	r3, r2, [r4]
    vtlp->lasttime = lasttime;
 8001cee:	f8c5 901c 	str.w	r9, [r5, #28]
 8001cf2:	6013      	str	r3, [r2, #0]
  dlp->next->prev = dlp->prev;
 8001cf4:	605a      	str	r2, [r3, #4]
    vtp->dlist.next = NULL;
 8001cf6:	f8c4 a000 	str.w	sl, [r4]

    /* If the list becomes empty then the alarm is disabled.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8001cfa:	692b      	ldr	r3, [r5, #16]
 8001cfc:	4543      	cmp	r3, r8
  TIMER_DMAINTEN(TIMER1) = 0;
 8001cfe:	bf08      	it	eq
 8001d00:	f8c7 a000 	streq.w	sl, [r7]
 8001d04:	f38a 8811 	msr	BASEPRI, sl
    /* The callback is invoked outside the kernel critical section, it
       is re-entered on the callback return. Note that "lasttime" can be
       modified within the callback if some timer function is called.*/
    chSysUnlockFromISR();

    vtp->func(vtp, vtp->par);
 8001d08:	4620      	mov	r0, r4
 8001d0a:	e9d4 2103 	ldrd	r2, r1, [r4, #12]
 8001d0e:	4790      	blx	r2
 8001d10:	2320      	movs	r3, #32
 8001d12:	f383 8811 	msr	BASEPRI, r3

    chSysLockFromISR();

    /* If a reload is defined the timer needs to be restarted.*/
    if (unlikely(vtp->reload > (sysinterval_t)0)) {
 8001d16:	6963      	ldr	r3, [r4, #20]
 8001d18:	2b00      	cmp	r3, #0
 8001d1a:	d0dd      	beq.n	8001cd8 <VectorB0+0x28>
  return (systime_t)TIMER_CNT(TIMER1);
 8001d1c:	6831      	ldr	r1, [r6, #0]
  return (sysinterval_t)((systime_t)(end - start));
 8001d1e:	eba1 0009 	sub.w	r0, r1, r9
      now = chVTGetSystemTimeX();
      nowdelta = chTimeDiffX(lasttime, now);

#if !defined(CH_VT_RFCU_DISABLED)
      /* Checking if the required reload is feasible.*/
      if (nowdelta > vtp->reload) {
 8001d22:	4283      	cmp	r3, r0
 8001d24:	d326      	bcc.n	8001d74 <VectorB0+0xc4>
  return (bool)(dlhp == dlhp->next);
 8001d26:	692a      	ldr	r2, [r5, #16]
      /* Enqueuing the timer again using the calculated delta.*/
      delay = vtp->reload - nowdelta;
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {
 8001d28:	4542      	cmp	r2, r8
 8001d2a:	d02c      	beq.n	8001d86 <VectorB0+0xd6>
  while (likely(dlp->delta < delta)) {
 8001d2c:	6891      	ldr	r1, [r2, #8]
 8001d2e:	428b      	cmp	r3, r1
 8001d30:	d904      	bls.n	8001d3c <VectorB0+0x8c>
    dlp = dlp->next;
 8001d32:	6812      	ldr	r2, [r2, #0]
    delta -= dlp->delta;
 8001d34:	1a5b      	subs	r3, r3, r1
  while (likely(dlp->delta < delta)) {
 8001d36:	6891      	ldr	r1, [r2, #8]
 8001d38:	4299      	cmp	r1, r3
 8001d3a:	d3fa      	bcc.n	8001d32 <VectorB0+0x82>
  dlhp->delta = (sysinterval_t)-1;
 8001d3c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  dlp->delta      = delta;
 8001d40:	60a3      	str	r3, [r4, #8]
  dlp->delta -= delta;
 8001d42:	6891      	ldr	r1, [r2, #8]
  dlp->next       = dlhp;
 8001d44:	6022      	str	r2, [r4, #0]
  dlp->delta -= delta;
 8001d46:	1acb      	subs	r3, r1, r3
  dlp->prev       = dlp->next->prev;
 8001d48:	6851      	ldr	r1, [r2, #4]
 8001d4a:	6061      	str	r1, [r4, #4]
  dlp->prev->next = dlp;
 8001d4c:	600c      	str	r4, [r1, #0]
  dlhp->prev      = dlp;
 8001d4e:	e9c2 4301 	strd	r4, r3, [r2, #4]
  dlhp->delta = (sysinterval_t)-1;
 8001d52:	61a8      	str	r0, [r5, #24]
 8001d54:	e7be      	b.n	8001cd4 <VectorB0+0x24>
      ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
    }
  }

  /* If the list is empty, nothing else to do.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8001d56:	4544      	cmp	r4, r8
 8001d58:	d005      	beq.n	8001d66 <VectorB0+0xb6>
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  vtlp->lasttime += nowdelta;
  vtp->dlist.delta -= nowdelta;
 8001d5a:	4419      	add	r1, r3
 8001d5c:	1a09      	subs	r1, r1, r0
  vtlp->lasttime += nowdelta;
 8001d5e:	61e8      	str	r0, [r5, #28]
  vtp->dlist.delta -= nowdelta;
 8001d60:	60a1      	str	r1, [r4, #8]

  /* Update alarm time to next timer.*/
  vt_set_alarm(now, vtp->dlist.delta);
 8001d62:	f7fe fe5d 	bl	8000a20 <vt_set_alarm>
 8001d66:	2300      	movs	r3, #0
 8001d68:	f383 8811 	msr	BASEPRI, r3
}
 8001d6c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    OSAL_IRQ_EPILOGUE();
 8001d70:	f7fe bc8e 	b.w	8000690 <__port_irq_epilogue>
 8001d74:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  return (bool)(dlhp == dlhp->next);
 8001d76:	692a      	ldr	r2, [r5, #16]
 8001d78:	f043 0302 	orr.w	r3, r3, #2
      if (ch_dlist_isempty(&vtlp->dlist)) {
 8001d7c:	4542      	cmp	r2, r8
 8001d7e:	636b      	str	r3, [r5, #52]	; 0x34
 8001d80:	d007      	beq.n	8001d92 <VectorB0+0xe2>
 8001d82:	4603      	mov	r3, r0
 8001d84:	e7d2      	b.n	8001d2c <VectorB0+0x7c>
        delay = vtp->reload - nowdelta;
 8001d86:	444b      	add	r3, r9
 8001d88:	1a5a      	subs	r2, r3, r1
        vt_insert_first(vtlp, vtp, now, delay);
 8001d8a:	4620      	mov	r0, r4
 8001d8c:	f7fe fd00 	bl	8000790 <vt_insert_first.constprop.0>
        return;
 8001d90:	e7e9      	b.n	8001d66 <VectorB0+0xb6>
        delay = (sysinterval_t)0;
 8001d92:	2200      	movs	r2, #0
 8001d94:	e7f9      	b.n	8001d8a <VectorB0+0xda>
 8001d96:	bf00      	nop
 8001d98:	40000010 	.word	0x40000010
 8001d9c:	20000d98 	.word	0x20000d98
 8001da0:	40000024 	.word	0x40000024
 8001da4:	4000000c 	.word	0x4000000c
	...

08001db0 <__init_ram_areas>:
#endif

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8001db0:	b4f0      	push	{r4, r5, r6, r7}
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8001db2:	2600      	movs	r6, #0
 8001db4:	4f13      	ldr	r7, [pc, #76]	; (8001e04 <__init_ram_areas+0x54>)
void __init_ram_areas(void) {
 8001db6:	4d14      	ldr	r5, [pc, #80]	; (8001e08 <__init_ram_areas+0x58>)
 8001db8:	4814      	ldr	r0, [pc, #80]	; (8001e0c <__init_ram_areas+0x5c>)
 8001dba:	4b15      	ldr	r3, [pc, #84]	; (8001e10 <__init_ram_areas+0x60>)
 8001dbc:	4915      	ldr	r1, [pc, #84]	; (8001e14 <__init_ram_areas+0x64>)
 8001dbe:	f107 0c70 	add.w	ip, r7, #112	; 0x70
    while (p < rap->clear_area) {
 8001dc2:	4298      	cmp	r0, r3
 8001dc4:	d911      	bls.n	8001dea <__init_ram_areas+0x3a>
 8001dc6:	461a      	mov	r2, r3
 8001dc8:	3904      	subs	r1, #4
      *p = *tp;
 8001dca:	f851 4f04 	ldr.w	r4, [r1, #4]!
 8001dce:	f842 4b04 	str.w	r4, [r2], #4
    while (p < rap->clear_area) {
 8001dd2:	4290      	cmp	r0, r2
 8001dd4:	d8f9      	bhi.n	8001dca <__init_ram_areas+0x1a>
 8001dd6:	1e42      	subs	r2, r0, #1
 8001dd8:	1ad2      	subs	r2, r2, r3
 8001dda:	f022 0203 	bic.w	r2, r2, #3
 8001dde:	3204      	adds	r2, #4
 8001de0:	4413      	add	r3, r2
    while (p < rap->no_init_area) {
 8001de2:	429d      	cmp	r5, r3
 8001de4:	d903      	bls.n	8001dee <__init_ram_areas+0x3e>
      *p = 0;
 8001de6:	f843 6b04 	str.w	r6, [r3], #4
    while (p < rap->no_init_area) {
 8001dea:	429d      	cmp	r5, r3
 8001dec:	d8fb      	bhi.n	8001de6 <__init_ram_areas+0x36>
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT0_AREAS_NUMBER]);
 8001dee:	4567      	cmp	r7, ip
 8001df0:	d005      	beq.n	8001dfe <__init_ram_areas+0x4e>
 8001df2:	e9d7 1304 	ldrd	r1, r3, [r7, #16]
 8001df6:	e9d7 0506 	ldrd	r0, r5, [r7, #24]
 8001dfa:	3710      	adds	r7, #16
 8001dfc:	e7e1      	b.n	8001dc2 <__init_ram_areas+0x12>
#endif
}
 8001dfe:	bcf0      	pop	{r4, r5, r6, r7}
 8001e00:	4770      	bx	lr
 8001e02:	bf00      	nop
 8001e04:	08001ec8 	.word	0x08001ec8
 8001e08:	20000fa4 	.word	0x20000fa4
 8001e0c:	20000fa4 	.word	0x20000fa4
 8001e10:	20000fa4 	.word	0x20000fa4
 8001e14:	08001f70 	.word	0x08001f70
	...

08001e20 <__default_exit>:
  while (true) {
 8001e20:	e7fe      	b.n	8001e20 <__default_exit>
 8001e22:	bf00      	nop
	...

08001e30 <__late_init>:
 8001e30:	4770      	bx	lr
 8001e32:	bf00      	nop
	...

08001e40 <__cpu_init>:
}
 8001e40:	4770      	bx	lr
 8001e42:	bf00      	nop
